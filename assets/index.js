var index = (function () {
  'use strict';

  function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
        if (k !== 'default' && !(k in n)) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    });
    return Object.freeze(n);
  }

  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

    _regeneratorRuntime = function () {
      return exports;
    };

    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");

          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }

          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);

            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }

            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if ("throw" !== record.type) {
          var result = record.arg,
              value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }

        reject(record.arg);
      }

      var previousPromise;

      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

            return next.value = undefined, next.done = !0, next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }

    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];

      for (var key in object) keys.push(key);

      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }

        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;

        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
              record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var PACKET_TYPES = Object.create(null); // no Map = no polyfill

  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  var PACKET_TYPES_REVERSE = Object.create(null);
  Object.keys(PACKET_TYPES).forEach(function (key) {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  var ERROR_PACKET = {
    type: "error",
    data: "parser error"
  };

  var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  var withNativeArrayBuffer$2 = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

  var isView$1 = function isView(obj) {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };

  var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
    var type = _ref.type,
        data = _ref.data;

    if (withNativeBlob$1 && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    } // plain string


    return callback(PACKET_TYPES[type] + (data || ""));
  };

  var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
    var fileReader = new FileReader();

    fileReader.onload = function () {
      var content = fileReader.result.split(",")[1];
      callback("b" + content);
    };

    return fileReader.readAsDataURL(data);
  };

  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.

  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);

  for (var i$1 = 0; i$1 < chars.length; i$1++) {
    lookup$1[chars.charCodeAt(i$1)] = i$1;
  }
  var decode$1 = function decode(base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i,
        p = 0,
        encoded1,
        encoded2,
        encoded3,
        encoded4;

    if (base64[base64.length - 1] === '=') {
      bufferLength--;

      if (base64[base64.length - 2] === '=') {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
      encoded1 = lookup$1[base64.charCodeAt(i)];
      encoded2 = lookup$1[base64.charCodeAt(i + 1)];
      encoded3 = lookup$1[base64.charCodeAt(i + 2)];
      encoded4 = lookup$1[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return arraybuffer;
  };

  var withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";

  var decodePacket = function decodePacket(encodedPacket, binaryType) {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }

    var type = encodedPacket.charAt(0);

    if (type === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }

    var packetType = PACKET_TYPES_REVERSE[type];

    if (!packetType) {
      return ERROR_PACKET;
    }

    return encodedPacket.length > 1 ? {
      type: PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: PACKET_TYPES_REVERSE[type]
    };
  };

  var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
    if (withNativeArrayBuffer$1) {
      var decoded = decode$1(data);
      return mapBinary(decoded, binaryType);
    } else {
      return {
        base64: true,
        data: data
      }; // fallback for old browsers
    }
  };

  var mapBinary = function mapBinary(data, binaryType) {
    switch (binaryType) {
      case "blob":
        return data instanceof ArrayBuffer ? new Blob([data]) : data;

      case "arraybuffer":
      default:
        return data;
      // assuming the data is already an ArrayBuffer
    }
  };

  var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

  var encodePayload = function encodePayload(packets, callback) {
    // some packets may be added to the array while encoding, so the initial length must be saved
    var length = packets.length;
    var encodedPackets = new Array(length);
    var count = 0;
    packets.forEach(function (packet, i) {
      // force base64 encoding for binary packets
      encodePacket(packet, false, function (encodedPacket) {
        encodedPackets[i] = encodedPacket;

        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };

  var decodePayload = function decodePayload(encodedPayload, binaryType) {
    var encodedPackets = encodedPayload.split(SEPARATOR);
    var packets = [];

    for (var i = 0; i < encodedPackets.length; i++) {
      var decodedPacket = decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);

      if (decodedPacket.type === "error") {
        break;
      }
    }

    return packets;
  };

  var protocol$1 = 4;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */
  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }

    return obj;
  }
  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
    return this;
  };
  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.once = function (event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };
  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */


  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
    this._callbacks = this._callbacks || {}; // all

    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    } // specific event


    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this; // remove all handlers

    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    } // remove specific handler


    var cb;

    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];

      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    } // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.


    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }

    return this;
  };
  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */


  Emitter.prototype.emit = function (event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1),
        callbacks = this._callbacks['$' + event];

    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }

    if (callbacks) {
      callbacks = callbacks.slice(0);

      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  }; // alias used for reserved events (protected method)


  Emitter.prototype.emitReserved = Emitter.prototype.emit;
  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function (event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };
  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */


  Emitter.prototype.hasListeners = function (event) {
    return !!this.listeners(event).length;
  };

  var globalThisShim = function () {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  }();

  function pick(obj) {
    for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      attr[_key - 1] = arguments[_key];
    }

    return attr.reduce(function (acc, k) {
      if (obj.hasOwnProperty(k)) {
        acc[k] = obj[k];
      }

      return acc;
    }, {});
  } // Keep a reference to the real timeout functions so they can be used when overridden

  var NATIVE_SET_TIMEOUT = setTimeout;
  var NATIVE_CLEAR_TIMEOUT = clearTimeout;
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
    } else {
      obj.setTimeoutFn = setTimeout.bind(globalThisShim);
      obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);
    }
  } // base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)

  var BASE64_OVERHEAD = 1.33; // we could also have used `new Blob([obj]).size`, but it isn't supported in IE9

  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    } // arraybuffer or blob


    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }

  function utf8Length(str) {
    var c = 0,
        length = 0;

    for (var i = 0, l = str.length; i < l; i++) {
      c = str.charCodeAt(i);

      if (c < 0x80) {
        length += 1;
      } else if (c < 0x800) {
        length += 2;
      } else if (c < 0xd800 || c >= 0xe000) {
        length += 3;
      } else {
        i++;
        length += 4;
      }
    }

    return length;
  }

  var TransportError = /*#__PURE__*/function (_Error) {
    _inherits(TransportError, _Error);

    var _super = _createSuper(TransportError);

    function TransportError(reason, description, context) {
      var _this;

      _classCallCheck(this, TransportError);

      _this = _super.call(this, reason);
      _this.description = description;
      _this.context = context;
      _this.type = "TransportError";
      return _this;
    }

    return _createClass(TransportError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var Transport = /*#__PURE__*/function (_Emitter) {
    _inherits(Transport, _Emitter);

    var _super2 = _createSuper(Transport);

    /**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */
    function Transport(opts) {
      var _this2;

      _classCallCheck(this, Transport);

      _this2 = _super2.call(this);
      _this2.writable = false;
      installTimerFunctions(_assertThisInitialized(_this2), opts);
      _this2.opts = opts;
      _this2.query = opts.query;
      _this2.readyState = "";
      _this2.socket = opts.socket;
      return _this2;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @api protected
     */


    _createClass(Transport, [{
      key: "onError",
      value: function onError(reason, description, context) {
        _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "error", new TransportError(reason, description, context));

        return this;
      }
      /**
       * Opens the transport.
       *
       * @api public
       */

    }, {
      key: "open",
      value: function open() {
        if ("closed" === this.readyState || "" === this.readyState) {
          this.readyState = "opening";
          this.doOpen();
        }

        return this;
      }
      /**
       * Closes the transport.
       *
       * @api public
       */

    }, {
      key: "close",
      value: function close() {
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.doClose();
          this.onClose();
        }

        return this;
      }
      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       * @api public
       */

    }, {
      key: "send",
      value: function send(packets) {
        if ("open" === this.readyState) {
          this.write(packets);
        }
      }
      /**
       * Called upon open
       *
       * @api protected
       */

    }, {
      key: "onOpen",
      value: function onOpen() {
        this.readyState = "open";
        this.writable = true;

        _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "open");
      }
      /**
       * Called with data.
       *
       * @param {String} data
       * @api protected
       */

    }, {
      key: "onData",
      value: function onData(data) {
        var packet = decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      /**
       * Called with a decoded packet.
       *
       * @api protected
       */

    }, {
      key: "onPacket",
      value: function onPacket(packet) {
        _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "packet", packet);
      }
      /**
       * Called upon close.
       *
       * @api protected
       */

    }, {
      key: "onClose",
      value: function onClose(details) {
        this.readyState = "closed";

        _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "close", details);
      }
    }]);

    return Transport;
  }(Emitter);

  // imported from https://github.com/unshiftio/yeast

  var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
      length = 64,
      map$1 = {};
  var seed = 0,
      i = 0,
      prev;
  /**
   * Return a string representing the specified number.
   *
   * @param {Number} num The number to convert.
   * @returns {String} The string representation of the number.
   * @api public
   */

  function encode$1(num) {
    var encoded = '';

    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);

    return encoded;
  }
  /**
   * Yeast: A tiny growing id generator.
   *
   * @returns {String} A unique id.
   * @api public
   */

  function yeast() {
    var now = encode$1(+new Date());
    if (now !== prev) return seed = 0, prev = now;
    return now + '.' + encode$1(seed++);
  } //
  // Map each character to its index.
  //

  for (; i < length; i++) {
    map$1[alphabet[i]] = i;
  }

  // imported from https://github.com/galkn/querystring

  /**
   * Compiles a querystring
   * Returns string representation of the object
   *
   * @param {Object}
   * @api private
   */
  function encode(obj) {
    var str = '';

    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length) str += '&';
        str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
      }
    }

    return str;
  }
  /**
   * Parses a simple querystring into an object
   *
   * @param {String} qs
   * @api private
   */

  function decode(qs) {
    var qry = {};
    var pairs = qs.split('&');

    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i].split('=');
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }

    return qry;
  }

  // imported from https://github.com/component/has-cors
  var value = false;

  try {
    value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (err) {// if XMLHttp support is disabled in IE then it will throw
    // when trying to create
  }

  var hasCORS = value;

  // browser shim for xmlhttprequest module
  function XHR(opts) {
    var xdomain = opts.xdomain; // XMLHttpRequest can be disabled on IE

    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {}

    if (!xdomain) {
      try {
        return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {}
    }
  }

  function empty() {}

  var hasXHR2 = function () {
    var xhr = new XHR({
      xdomain: false
    });
    return null != xhr.responseType;
  }();

  var Polling = /*#__PURE__*/function (_Transport) {
    _inherits(Polling, _Transport);

    var _super = _createSuper(Polling);

    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */
    function Polling(opts) {
      var _this;

      _classCallCheck(this, Polling);

      _this = _super.call(this, opts);
      _this.polling = false;

      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port; // some user agents have empty `location.port`

        if (!port) {
          port = isSSL ? "443" : "80";
        }

        _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        _this.xs = opts.secure !== isSSL;
      }
      /**
       * XHR supports binary
       */


      var forceBase64 = opts && opts.forceBase64;
      _this.supportsBinary = hasXHR2 && !forceBase64;
      return _this;
    }
    /**
     * Transport name.
     */


    _createClass(Polling, [{
      key: "name",
      get: function get() {
        return "polling";
      }
      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @api private
       */

    }, {
      key: "doOpen",
      value: function doOpen() {
        this.poll();
      }
      /**
       * Pauses polling.
       *
       * @param {Function} callback upon buffers are flushed and transport is paused
       * @api private
       */

    }, {
      key: "pause",
      value: function pause(onPause) {
        var _this2 = this;

        this.readyState = "pausing";

        var pause = function pause() {
          _this2.readyState = "paused";
          onPause();
        };

        if (this.polling || !this.writable) {
          var total = 0;

          if (this.polling) {
            total++;
            this.once("pollComplete", function () {
              --total || pause();
            });
          }

          if (!this.writable) {
            total++;
            this.once("drain", function () {
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      /**
       * Starts polling cycle.
       *
       * @api public
       */

    }, {
      key: "poll",
      value: function poll() {
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
      }
      /**
       * Overloads onData to detect payloads.
       *
       * @api private
       */

    }, {
      key: "onData",
      value: function onData(data) {
        var _this3 = this;

        var callback = function callback(packet) {
          // if its the first message we consider the transport open
          if ("opening" === _this3.readyState && packet.type === "open") {
            _this3.onOpen();
          } // if its a close packet, we close the ongoing requests


          if ("close" === packet.type) {
            _this3.onClose({
              description: "transport closed by the server"
            });

            return false;
          } // otherwise bypass onData and handle the message


          _this3.onPacket(packet);
        }; // decode payload


        decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing

        if ("closed" !== this.readyState) {
          // if we got data we're not polling
          this.polling = false;
          this.emitReserved("pollComplete");

          if ("open" === this.readyState) {
            this.poll();
          }
        }
      }
      /**
       * For polling, send a close packet.
       *
       * @api private
       */

    }, {
      key: "doClose",
      value: function doClose() {
        var _this4 = this;

        var close = function close() {
          _this4.write([{
            type: "close"
          }]);
        };

        if ("open" === this.readyState) {
          close();
        } else {
          // in case we're trying to close while
          // handshaking is in progress (GH-164)
          this.once("open", close);
        }
      }
      /**
       * Writes a packets payload.
       *
       * @param {Array} data packets
       * @param {Function} drain callback
       * @api private
       */

    }, {
      key: "write",
      value: function write(packets) {
        var _this5 = this;

        this.writable = false;
        encodePayload(packets, function (data) {
          _this5.doWrite(data, function () {
            _this5.writable = true;

            _this5.emitReserved("drain");
          });
        });
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */

    }, {
      key: "uri",
      value: function uri() {
        var query = this.query || {};
        var schema = this.opts.secure ? "https" : "http";
        var port = ""; // cache busting is forced

        if (false !== this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast();
        }

        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        } // avoid port if default for schema


        if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }

        var encodedQuery = encode(query);
        var ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Creates a request.
       *
       * @param {String} method
       * @api private
       */

    }, {
      key: "request",
      value: function request() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.assign(opts, {
          xd: this.xd,
          xs: this.xs
        }, this.opts);
        return new Request(this.uri(), opts);
      }
      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @api private
       */

    }, {
      key: "doWrite",
      value: function doWrite(data, fn) {
        var _this6 = this;

        var req = this.request({
          method: "POST",
          data: data
        });
        req.on("success", fn);
        req.on("error", function (xhrStatus, context) {
          _this6.onError("xhr post error", xhrStatus, context);
        });
      }
      /**
       * Starts a poll cycle.
       *
       * @api private
       */

    }, {
      key: "doPoll",
      value: function doPoll() {
        var _this7 = this;

        var req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", function (xhrStatus, context) {
          _this7.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
      }
    }]);

    return Polling;
  }(Transport);
  var Request = /*#__PURE__*/function (_Emitter) {
    _inherits(Request, _Emitter);

    var _super2 = _createSuper(Request);

    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */
    function Request(uri, opts) {
      var _this8;

      _classCallCheck(this, Request);

      _this8 = _super2.call(this);
      installTimerFunctions(_assertThisInitialized(_this8), opts);
      _this8.opts = opts;
      _this8.method = opts.method || "GET";
      _this8.uri = uri;
      _this8.async = false !== opts.async;
      _this8.data = undefined !== opts.data ? opts.data : null;

      _this8.create();

      return _this8;
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */


    _createClass(Request, [{
      key: "create",
      value: function create() {
        var _this9 = this;

        var opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        var xhr = this.xhr = new XHR(opts);

        try {
          xhr.open(this.method, this.uri, this.async);

          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

              for (var i in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {}

          if ("POST" === this.method) {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {}
          }

          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {} // ie6 check


          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }

          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }

          xhr.onreadystatechange = function () {
            if (4 !== xhr.readyState) return;

            if (200 === xhr.status || 1223 === xhr.status) {
              _this9.onLoad();
            } else {
              // make sure the `error` event handler that's user-set
              // does not throw in the same tick and gets caught here
              _this9.setTimeoutFn(function () {
                _this9.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };

          xhr.send(this.data);
        } catch (e) {
          // Need to defer since .create() is called directly from the constructor
          // and thus the 'error' event can only be only bound *after* this exception
          // occurs.  Therefore, also, we cannot throw here at all.
          this.setTimeoutFn(function () {
            _this9.onError(e);
          }, 0);
          return;
        }

        if (typeof document !== "undefined") {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      }
      /**
       * Called upon error.
       *
       * @api private
       */

    }, {
      key: "onError",
      value: function onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
      }
      /**
       * Cleans up house.
       *
       * @api private
       */

    }, {
      key: "cleanup",
      value: function cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
          return;
        }

        this.xhr.onreadystatechange = empty;

        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {}
        }

        if (typeof document !== "undefined") {
          delete Request.requests[this.index];
        }

        this.xhr = null;
      }
      /**
       * Called upon load.
       *
       * @api private
       */

    }, {
      key: "onLoad",
      value: function onLoad() {
        var data = this.xhr.responseText;

        if (data !== null) {
          this.emitReserved("data", data);
          this.emitReserved("success");
          this.cleanup();
        }
      }
      /**
       * Aborts the request.
       *
       * @api public
       */

    }, {
      key: "abort",
      value: function abort() {
        this.cleanup();
      }
    }]);

    return Request;
  }(Emitter);
  Request.requestsCount = 0;
  Request.requests = {};
  /**
   * Aborts pending requests when unloading the window. This is needed to prevent
   * memory leaks (e.g. when using IE) and to ensure that no spurious error is
   * emitted.
   */

  if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
      // @ts-ignore
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      var terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }

  function unloadHandler() {
    for (var i in Request.requests) {
      if (Request.requests.hasOwnProperty(i)) {
        Request.requests[i].abort();
      }
    }
  }

  var nextTick = function () {
    var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";

    if (isPromiseAvailable) {
      return function (cb) {
        return Promise.resolve().then(cb);
      };
    } else {
      return function (cb, setTimeoutFn) {
        return setTimeoutFn(cb, 0);
      };
    }
  }();
  var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
  var usingBrowserWebSocket = true;
  var defaultBinaryType = "arraybuffer";

  var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  var WS = /*#__PURE__*/function (_Transport) {
    _inherits(WS, _Transport);

    var _super = _createSuper(WS);

    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */
    function WS(opts) {
      var _this;

      _classCallCheck(this, WS);

      _this = _super.call(this, opts);
      _this.supportsBinary = !opts.forceBase64;
      return _this;
    }
    /**
     * Transport name.
     *
     * @api public
     */


    _createClass(WS, [{
      key: "name",
      get: function get() {
        return "websocket";
      }
      /**
       * Opens socket.
       *
       * @api private
       */

    }, {
      key: "doOpen",
      value: function doOpen() {
        if (!this.check()) {
          // let probe timeout
          return;
        }

        var uri = this.uri();
        var protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed

        var opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");

        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }

        try {
          this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emitReserved("error", err);
        }

        this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
        this.addEventListeners();
      }
      /**
       * Adds event listeners to the socket
       *
       * @api private
       */

    }, {
      key: "addEventListeners",
      value: function addEventListeners() {
        var _this2 = this;

        this.ws.onopen = function () {
          if (_this2.opts.autoUnref) {
            _this2.ws._socket.unref();
          }

          _this2.onOpen();
        };

        this.ws.onclose = function (closeEvent) {
          return _this2.onClose({
            description: "websocket connection closed",
            context: closeEvent
          });
        };

        this.ws.onmessage = function (ev) {
          return _this2.onData(ev.data);
        };

        this.ws.onerror = function (e) {
          return _this2.onError("websocket error", e);
        };
      }
      /**
       * Writes data to socket.
       *
       * @param {Array} array of packets.
       * @api private
       */

    }, {
      key: "write",
      value: function write(packets) {
        var _this3 = this;

        this.writable = false; // encodePacket efficient as it uses WS framing
        // no need for encodePayload

        var _loop = function _loop(i) {
          var packet = packets[i];
          var lastPacket = i === packets.length - 1;
          encodePacket(packet, _this3.supportsBinary, function (data) {
            // always create a new object (GH-437)
            var opts = {};
            // have a chance of informing us about it yet, in that case send will
            // throw an error


            try {
              if (usingBrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                _this3.ws.send(data);
              }
            } catch (e) {}

            if (lastPacket) {
              // fake drain
              // defer to next tick to allow Socket to clear writeBuffer
              nextTick(function () {
                _this3.writable = true;

                _this3.emitReserved("drain");
              }, _this3.setTimeoutFn);
            }
          });
        };

        for (var i = 0; i < packets.length; i++) {
          _loop(i);
        }
      }
      /**
       * Closes socket.
       *
       * @api private
       */

    }, {
      key: "doClose",
      value: function doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */

    }, {
      key: "uri",
      value: function uri() {
        var query = this.query || {};
        var schema = this.opts.secure ? "wss" : "ws";
        var port = ""; // avoid port if default for schema

        if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        } // append timestamp to URI


        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = yeast();
        } // communicate binary support capabilities


        if (!this.supportsBinary) {
          query.b64 = 1;
        }

        var encodedQuery = encode(query);
        var ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @api public
       */

    }, {
      key: "check",
      value: function check() {
        return !!WebSocket;
      }
    }]);

    return WS;
  }(Transport);

  var transports = {
    websocket: WS,
    polling: Polling
  };

  // imported from https://github.com/galkn/parseuri

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api private
   */
  var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
  function parse(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
      uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
      uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
  }

  function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
      names.splice(0, 1);
    }

    if (path.substr(path.length - 1, 1) == '/') {
      names.splice(names.length - 1, 1);
    }

    return names;
  }

  function queryKey(uri, query) {
    var data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }

  var Socket$1 = /*#__PURE__*/function (_Emitter) {
    _inherits(Socket, _Emitter);

    var _super = _createSuper(Socket);

    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} opts - options
     * @api public
     */
    function Socket(uri) {
      var _this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Socket);

      _this = _super.call(this);

      if (uri && "object" === _typeof$1(uri)) {
        opts = uri;
        uri = null;
      }

      if (uri) {
        uri = parse(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query) opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parse(opts.host).host;
      }

      installTimerFunctions(_assertThisInitialized(_this), opts);
      _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;

      if (opts.hostname && !opts.port) {
        // if no port is specified manually, use the protocol default
        opts.port = _this.secure ? "443" : "80";
      }

      _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
      _this.transports = opts.transports || ["polling", "websocket"];
      _this.readyState = "";
      _this.writeBuffer = [];
      _this.prevBufferLen = 0;
      _this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        timestampParam: "t",
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: true
      }, opts);
      _this.opts.path = _this.opts.path.replace(/\/$/, "") + "/";

      if (typeof _this.opts.query === "string") {
        _this.opts.query = decode(_this.opts.query);
      } // set on handshake


      _this.id = null;
      _this.upgrades = null;
      _this.pingInterval = null;
      _this.pingTimeout = null; // set on heartbeat

      _this.pingTimeoutTimer = null;

      if (typeof addEventListener === "function") {
        if (_this.opts.closeOnBeforeunload) {
          // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
          // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
          // closed/reloaded)
          addEventListener("beforeunload", function () {
            if (_this.transport) {
              // silently close the transport
              _this.transport.removeAllListeners();

              _this.transport.close();
            }
          }, false);
        }

        if (_this.hostname !== "localhost") {
          _this.offlineEventListener = function () {
            _this.onClose("transport close", {
              description: "network connection lost"
            });
          };

          addEventListener("offline", _this.offlineEventListener, false);
        }
      }

      _this.open();

      return _this;
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */


    _createClass(Socket, [{
      key: "createTransport",
      value: function createTransport(name) {
        var query = Object.assign({}, this.opts.query); // append engine.io protocol identifier

        query.EIO = protocol$1; // transport name

        query.transport = name; // session id if we already have one

        if (this.id) query.sid = this.id;
        var opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
          query: query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        });
        return new transports[name](opts);
      }
      /**
       * Initializes transport to use and starts probe.
       *
       * @api private
       */

    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        var transport;

        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
          transport = "websocket";
        } else if (0 === this.transports.length) {
          // Emit error on next tick so it can be listened to
          this.setTimeoutFn(function () {
            _this2.emitReserved("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }

        this.readyState = "opening"; // Retry with the next transport if the transport is disabled (jsonp: false)

        try {
          transport = this.createTransport(transport);
        } catch (e) {
          this.transports.shift();
          this.open();
          return;
        }

        transport.open();
        this.setTransport(transport);
      }
      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @api private
       */

    }, {
      key: "setTransport",
      value: function setTransport(transport) {
        var _this3 = this;

        if (this.transport) {
          this.transport.removeAllListeners();
        } // set up transport


        this.transport = transport; // set up transport listeners

        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", function (reason) {
          return _this3.onClose("transport close", reason);
        });
      }
      /**
       * Probes a transport.
       *
       * @param {String} transport name
       * @api private
       */

    }, {
      key: "probe",
      value: function probe(name) {
        var _this4 = this;

        var transport = this.createTransport(name);
        var failed = false;
        Socket.priorWebsocketSuccess = false;

        var onTransportOpen = function onTransportOpen() {
          if (failed) return;
          transport.send([{
            type: "ping",
            data: "probe"
          }]);
          transport.once("packet", function (msg) {
            if (failed) return;

            if ("pong" === msg.type && "probe" === msg.data) {
              _this4.upgrading = true;

              _this4.emitReserved("upgrading", transport);

              if (!transport) return;
              Socket.priorWebsocketSuccess = "websocket" === transport.name;

              _this4.transport.pause(function () {
                if (failed) return;
                if ("closed" === _this4.readyState) return;
                cleanup();

                _this4.setTransport(transport);

                transport.send([{
                  type: "upgrade"
                }]);

                _this4.emitReserved("upgrade", transport);

                transport = null;
                _this4.upgrading = false;

                _this4.flush();
              });
            } else {
              var err = new Error("probe error"); // @ts-ignore

              err.transport = transport.name;

              _this4.emitReserved("upgradeError", err);
            }
          });
        };

        function freezeTransport() {
          if (failed) return; // Any callback called by transport should be ignored since now

          failed = true;
          cleanup();
          transport.close();
          transport = null;
        } // Handle any error that happens while probing


        var onerror = function onerror(err) {
          var error = new Error("probe error: " + err); // @ts-ignore

          error.transport = transport.name;
          freezeTransport();

          _this4.emitReserved("upgradeError", error);
        };

        function onTransportClose() {
          onerror("transport closed");
        } // When the socket is closed while we're probing


        function onclose() {
          onerror("socket closed");
        } // When the socket is upgraded while we're probing


        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            freezeTransport();
          }
        } // Remove all listeners on the transport and on self


        var cleanup = function cleanup() {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);

          _this4.off("close", onclose);

          _this4.off("upgrading", onupgrade);
        };

        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      }
      /**
       * Called when connection is deemed open.
       *
       * @api private
       */

    }, {
      key: "onOpen",
      value: function onOpen() {
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush(); // we check for `readyState` in case an `open`
        // listener already closed the socket

        if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
          var i = 0;
          var l = this.upgrades.length;

          for (; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      }
      /**
       * Handles a packet.
       *
       * @api private
       */

    }, {
      key: "onPacket",
      value: function onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          this.emitReserved("packet", packet); // Socket is live - any packet counts

          this.emitReserved("heartbeat");

          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;

            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              break;

            case "error":
              var err = new Error("server error"); // @ts-ignore

              err.code = packet.data;
              this.onError(err);
              break;

            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        }
      }
      /**
       * Called upon handshake completion.
       *
       * @param {Object} data - handshake obj
       * @api private
       */

    }, {
      key: "onHandshake",
      value: function onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen(); // In case open handler closes socket

        if ("closed" === this.readyState) return;
        this.resetPingTimeout();
      }
      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @api private
       */

    }, {
      key: "resetPingTimeout",
      value: function resetPingTimeout() {
        var _this5 = this;

        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(function () {
          _this5.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);

        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }
      /**
       * Called on `drain` event
       *
       * @api private
       */

    }, {
      key: "onDrain",
      value: function onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`

        this.prevBufferLen = 0;

        if (0 === this.writeBuffer.length) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      /**
       * Flush write buffers.
       *
       * @api private
       */

    }, {
      key: "flush",
      value: function flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          var packets = this.getWritablePackets();
          this.transport.send(packets); // keep track of current length of writeBuffer
          // splice writeBuffer and callbackBuffer on `drain`

          this.prevBufferLen = packets.length;
          this.emitReserved("flush");
        }
      }
      /**
       * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
       * long-polling)
       *
       * @private
       */

    }, {
      key: "getWritablePackets",
      value: function getWritablePackets() {
        var shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;

        if (!shouldCheckPayloadSize) {
          return this.writeBuffer;
        }

        var payloadSize = 1; // first packet type

        for (var i = 0; i < this.writeBuffer.length; i++) {
          var data = this.writeBuffer[i].data;

          if (data) {
            payloadSize += byteLength(data);
          }

          if (i > 0 && payloadSize > this.maxPayload) {
            return this.writeBuffer.slice(0, i);
          }

          payloadSize += 2; // separator + packet type
        }

        return this.writeBuffer;
      }
      /**
       * Sends a message.
       *
       * @param {String} message.
       * @param {Function} callback function.
       * @param {Object} options.
       * @return {Socket} for chaining.
       * @api public
       */

    }, {
      key: "write",
      value: function write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
    }, {
      key: "send",
      value: function send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} callback function.
       * @api private
       */

    }, {
      key: "sendPacket",
      value: function sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = undefined;
        }

        if ("function" === typeof options) {
          fn = options;
          options = null;
        }

        if ("closing" === this.readyState || "closed" === this.readyState) {
          return;
        }

        options = options || {};
        options.compress = false !== options.compress;
        var packet = {
          type: type,
          data: data,
          options: options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn) this.once("flush", fn);
        this.flush();
      }
      /**
       * Closes the connection.
       *
       * @api public
       */

    }, {
      key: "close",
      value: function close() {
        var _this6 = this;

        var close = function close() {
          _this6.onClose("forced close");

          _this6.transport.close();
        };

        var cleanupAndClose = function cleanupAndClose() {
          _this6.off("upgrade", cleanupAndClose);

          _this6.off("upgradeError", cleanupAndClose);

          close();
        };

        var waitForUpgrade = function waitForUpgrade() {
          // wait for upgrade to finish since we can't send packets while pausing a transport
          _this6.once("upgrade", cleanupAndClose);

          _this6.once("upgradeError", cleanupAndClose);
        };

        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";

          if (this.writeBuffer.length) {
            this.once("drain", function () {
              if (_this6.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }

        return this;
      }
      /**
       * Called upon transport error
       *
       * @api private
       */

    }, {
      key: "onError",
      value: function onError(err) {
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
      }
      /**
       * Called upon transport close.
       *
       * @api private
       */

    }, {
      key: "onClose",
      value: function onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          // clear timers
          this.clearTimeoutFn(this.pingTimeoutTimer); // stop event from firing again for transport

          this.transport.removeAllListeners("close"); // ensure transport won't stay open

          this.transport.close(); // ignore further transport communication

          this.transport.removeAllListeners();

          if (typeof removeEventListener === "function") {
            removeEventListener("offline", this.offlineEventListener, false);
          } // set ready state


          this.readyState = "closed"; // clear session id

          this.id = null; // emit close event

          this.emitReserved("close", reason, description); // clean buffers after, so users can still
          // grab the buffers on `close` event

          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }
      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} server upgrades
       * @api private
       *
       */

    }, {
      key: "filterUpgrades",
      value: function filterUpgrades(upgrades) {
        var filteredUpgrades = [];
        var i = 0;
        var j = upgrades.length;

        for (; i < j; i++) {
          if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
        }

        return filteredUpgrades;
      }
    }]);

    return Socket;
  }(Emitter);
  Socket$1.protocol = protocol$1;

  Socket$1.protocol;

  /**
   * URL parser.
   *
   * @param uri - url
   * @param path - the request path of the connection
   * @param loc - An object meant to mimic window.location.
   *        Defaults to window.location.
   * @public
   */

  function url(uri) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var loc = arguments.length > 2 ? arguments[2] : undefined;
    var obj = uri; // default to window.location

    loc = loc || typeof location !== "undefined" && location;
    if (null == uri) uri = loc.protocol + "//" + loc.host; // relative path support

    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }

      if (!/^(https?|wss?):\/\//.test(uri)) {
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      } // parse


      obj = parse(uri);
    } // make sure we treat `localhost:80` and `localhost` equally


    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }

    obj.path = obj.path || "/";
    var ipv6 = obj.host.indexOf(":") !== -1;
    var host = ipv6 ? "[" + obj.host + "]" : obj.host; // define unique id

    obj.id = obj.protocol + "://" + host + ":" + obj.port + path; // define href

    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }

  var withNativeArrayBuffer = typeof ArrayBuffer === "function";

  var isView = function isView(obj) {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };

  var toString = Object.prototype.toString;
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
  var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
  /**
   * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
   *
   * @private
   */

  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  function hasBinary(obj, toJSON) {
    if (!obj || _typeof$1(obj) !== "object") {
      return false;
    }

    if (Array.isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (hasBinary(obj[i])) {
          return true;
        }
      }

      return false;
    }

    if (isBinary(obj)) {
      return true;
    }

    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }

    return false;
  }

  /**
   * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
   *
   * @param {Object} packet - socket.io event packet
   * @return {Object} with deconstructed packet and list of buffers
   * @public
   */

  function deconstructPacket(packet) {
    var buffers = [];
    var packetData = packet.data;
    var pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'

    return {
      packet: pack,
      buffers: buffers
    };
  }

  function _deconstructPacket(data, buffers) {
    if (!data) return data;

    if (isBinary(data)) {
      var placeholder = {
        _placeholder: true,
        num: buffers.length
      };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      var newData = new Array(data.length);

      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i], buffers);
      }

      return newData;
    } else if (_typeof$1(data) === "object" && !(data instanceof Date)) {
      var _newData = {};

      for (var key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          _newData[key] = _deconstructPacket(data[key], buffers);
        }
      }

      return _newData;
    }

    return data;
  }
  /**
   * Reconstructs a binary packet from its placeholder packet and buffers
   *
   * @param {Object} packet - event packet with placeholders
   * @param {Array} buffers - binary buffers to put in placeholder positions
   * @return {Object} reconstructed packet
   * @public
   */


  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = undefined; // no longer useful

    return packet;
  }

  function _reconstructPacket(data, buffers) {
    if (!data) return data;

    if (data && data._placeholder === true) {
      var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;

      if (isIndexValid) {
        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i], buffers);
      }
    } else if (_typeof$1(data) === "object") {
      for (var key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }

    return data;
  }

  /**
   * Protocol version.
   *
   * @public
   */

  var protocol = 5;
  var PacketType;

  (function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType || (PacketType = {}));
  /**
   * A socket.io Encoder instance
   */


  var Encoder = /*#__PURE__*/function () {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    function Encoder(replacer) {
      _classCallCheck(this, Encoder);

      this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */


    _createClass(Encoder, [{
      key: "encode",
      value: function encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if (hasBinary(obj)) {
            obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
            return this.encodeAsBinary(obj);
          }
        }

        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */

    }, {
      key: "encodeAsString",
      value: function encodeAsString(obj) {
        // first is type
        var str = "" + obj.type; // attachments if we have them

        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        } // if we have a namespace other than `/`
        // we append it followed by a comma `,`


        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        } // immediately followed by the id


        if (null != obj.id) {
          str += obj.id;
        } // json data


        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }

        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */

    }, {
      key: "encodeAsBinary",
      value: function encodeAsBinary(obj) {
        var deconstruction = deconstructPacket(obj);
        var pack = this.encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list

        return buffers; // write all the buffers
      }
    }]);

    return Encoder;
  }();
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   */

  var Decoder = /*#__PURE__*/function (_Emitter) {
    _inherits(Decoder, _Emitter);

    var _super = _createSuper(Decoder);

    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    function Decoder(reviver) {
      var _this;

      _classCallCheck(this, Decoder);

      _this = _super.call(this);
      _this.reviver = reviver;
      return _this;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */


    _createClass(Decoder, [{
      key: "add",
      value: function add(obj) {
        var packet;

        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }

          packet = this.decodeString(obj);

          if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
            // binary packet's json
            this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

            if (packet.attachments === 0) {
              _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
            }
          } else {
            // non-binary full packet
            _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
          }
        } else if (isBinary(obj) || obj.base64) {
          // raw binary data
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);

            if (packet) {
              // received final buffer
              this.reconstructor = null;

              _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */

    }, {
      key: "decodeString",
      value: function decodeString(str) {
        var i = 0; // look up type

        var p = {
          type: Number(str.charAt(0))
        };

        if (PacketType[p.type] === undefined) {
          throw new Error("unknown packet type " + p.type);
        } // look up attachments if type binary


        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          var start = i + 1;

          while (str.charAt(++i) !== "-" && i != str.length) {}

          var buf = str.substring(start, i);

          if (buf != Number(buf) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }

          p.attachments = Number(buf);
        } // look up namespace (if any)


        if ("/" === str.charAt(i + 1)) {
          var _start = i + 1;

          while (++i) {
            var c = str.charAt(i);
            if ("," === c) break;
            if (i === str.length) break;
          }

          p.nsp = str.substring(_start, i);
        } else {
          p.nsp = "/";
        } // look up id


        var next = str.charAt(i + 1);

        if ("" !== next && Number(next) == next) {
          var _start2 = i + 1;

          while (++i) {
            var _c = str.charAt(i);

            if (null == _c || Number(_c) != _c) {
              --i;
              break;
            }

            if (i === str.length) break;
          }

          p.id = Number(str.substring(_start2, i + 1));
        } // look up json data


        if (str.charAt(++i)) {
          var payload = this.tryParse(str.substr(i));

          if (Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }

        return p;
      }
    }, {
      key: "tryParse",
      value: function tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
    }, {
      key: "destroy",
      value:
      /**
       * Deallocates a parser's resources
       */
      function destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      }
    }], [{
      key: "isPayloadValid",
      value: function isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return _typeof$1(payload) === "object";

          case PacketType.DISCONNECT:
            return payload === undefined;

          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || _typeof$1(payload) === "object";

          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && payload.length > 0;

          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
    }]);

    return Decoder;
  }(Emitter);
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   */

  var BinaryReconstructor = /*#__PURE__*/function () {
    function BinaryReconstructor(packet) {
      _classCallCheck(this, BinaryReconstructor);

      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */


    _createClass(BinaryReconstructor, [{
      key: "takeBinaryData",
      value: function takeBinaryData(binData) {
        this.buffers.push(binData);

        if (this.buffers.length === this.reconPack.attachments) {
          // done with buffer list
          var packet = reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }

        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */

    }, {
      key: "finishedReconstruction",
      value: function finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    }]);

    return BinaryReconstructor;
  }();

  var parser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    protocol: protocol,
    get PacketType () { return PacketType; },
    Encoder: Encoder,
    Decoder: Decoder
  });

  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }

  /**
   * Internal events.
   * These events can't be emitted by the user.
   */

  var RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
  });
  var Socket = /*#__PURE__*/function (_Emitter) {
    _inherits(Socket, _Emitter);

    var _super = _createSuper(Socket);

    /**
     * `Socket` constructor.
     *
     * @public
     */
    function Socket(io, nsp, opts) {
      var _this;

      _classCallCheck(this, Socket);

      _this = _super.call(this);
      _this.connected = false;
      _this.receiveBuffer = [];
      _this.sendBuffer = [];
      _this.ids = 0;
      _this.acks = {};
      _this.flags = {};
      _this.io = io;
      _this.nsp = nsp;

      if (opts && opts.auth) {
        _this.auth = opts.auth;
      }

      if (_this.io._autoConnect) _this.open();
      return _this;
    }
    /**
     * Whether the socket is currently disconnected
     */


    _createClass(Socket, [{
      key: "disconnected",
      get: function get() {
        return !this.connected;
      }
      /**
       * Subscribe to open, close and packet events
       *
       * @private
       */

    }, {
      key: "subEvents",
      value: function subEvents() {
        if (this.subs) return;
        var io = this.io;
        this.subs = [on(io, "open", this.onopen.bind(this)), on(io, "packet", this.onpacket.bind(this)), on(io, "error", this.onerror.bind(this)), on(io, "close", this.onclose.bind(this))];
      }
      /**
       * Whether the Socket will try to reconnect when its Manager connects or reconnects
       */

    }, {
      key: "active",
      get: function get() {
        return !!this.subs;
      }
      /**
       * "Opens" the socket.
       *
       * @public
       */

    }, {
      key: "connect",
      value: function connect() {
        if (this.connected) return this;
        this.subEvents();
        if (!this.io["_reconnecting"]) this.io.open(); // ensure open

        if ("open" === this.io._readyState) this.onopen();
        return this;
      }
      /**
       * Alias for connect()
       */

    }, {
      key: "open",
      value: function open() {
        return this.connect();
      }
      /**
       * Sends a `message` event.
       *
       * @return self
       * @public
       */

    }, {
      key: "send",
      value: function send() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @return self
       * @public
       */

    }, {
      key: "emit",
      value: function emit(ev) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
          throw new Error('"' + ev + '" is a reserved event name');
        }

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        args.unshift(ev);
        var packet = {
          type: PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false; // event ack callback

        if ("function" === typeof args[args.length - 1]) {
          var id = this.ids++;
          var ack = args.pop();

          this._registerAckCallback(id, ack);

          packet.id = id;
        }

        var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        var discardPacket = this.flags["volatile"] && (!isTransportWritable || !this.connected);

        if (discardPacket) ; else if (this.connected) {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }

        this.flags = {};
        return this;
      }
      /**
       * @private
       */

    }, {
      key: "_registerAckCallback",
      value: function _registerAckCallback(id, ack) {
        var _this2 = this;

        var timeout = this.flags.timeout;

        if (timeout === undefined) {
          this.acks[id] = ack;
          return;
        } // @ts-ignore


        var timer = this.io.setTimeoutFn(function () {
          delete _this2.acks[id];

          for (var i = 0; i < _this2.sendBuffer.length; i++) {
            if (_this2.sendBuffer[i].id === id) {
              _this2.sendBuffer.splice(i, 1);
            }
          }

          ack.call(_this2, new Error("operation has timed out"));
        }, timeout);

        this.acks[id] = function () {
          // @ts-ignore
          _this2.io.clearTimeoutFn(timer);

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          ack.apply(_this2, [null].concat(args));
        };
      }
      /**
       * Sends a packet.
       *
       * @param packet
       * @private
       */

    }, {
      key: "packet",
      value: function packet(_packet) {
        _packet.nsp = this.nsp;

        this.io._packet(_packet);
      }
      /**
       * Called upon engine `open`.
       *
       * @private
       */

    }, {
      key: "onopen",
      value: function onopen() {
        var _this3 = this;

        if (typeof this.auth == "function") {
          this.auth(function (data) {
            _this3.packet({
              type: PacketType.CONNECT,
              data: data
            });
          });
        } else {
          this.packet({
            type: PacketType.CONNECT,
            data: this.auth
          });
        }
      }
      /**
       * Called upon engine or manager `error`.
       *
       * @param err
       * @private
       */

    }, {
      key: "onerror",
      value: function onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      /**
       * Called upon engine `close`.
       *
       * @param reason
       * @param description
       * @private
       */

    }, {
      key: "onclose",
      value: function onclose(reason, description) {
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
      }
      /**
       * Called with socket packet.
       *
       * @param packet
       * @private
       */

    }, {
      key: "onpacket",
      value: function onpacket(packet) {
        var sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace) return;

        switch (packet.type) {
          case PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              var id = packet.data.sid;
              this.onconnect(id);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }

            break;

          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;

          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            this.onack(packet);
            break;

          case PacketType.DISCONNECT:
            this.ondisconnect();
            break;

          case PacketType.CONNECT_ERROR:
            this.destroy();
            var err = new Error(packet.data.message); // @ts-ignore

            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      /**
       * Called upon a server event.
       *
       * @param packet
       * @private
       */

    }, {
      key: "onevent",
      value: function onevent(packet) {
        var args = packet.data || [];

        if (null != packet.id) {
          args.push(this.ack(packet.id));
        }

        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
    }, {
      key: "emitEvent",
      value: function emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          var listeners = this._anyListeners.slice();

          var _iterator = _createForOfIteratorHelper(listeners),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var listener = _step.value;
              listener.apply(this, args);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @private
       */

    }, {
      key: "ack",
      value: function ack(id) {
        var self = this;
        var sent = false;
        return function () {
          // prevent double callbacks
          if (sent) return;
          sent = true;

          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          self.packet({
            type: PacketType.ACK,
            id: id,
            data: args
          });
        };
      }
      /**
       * Called upon a server acknowlegement.
       *
       * @param packet
       * @private
       */

    }, {
      key: "onack",
      value: function onack(packet) {
        var ack = this.acks[packet.id];

        if ("function" === typeof ack) {
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        }
      }
      /**
       * Called upon server connect.
       *
       * @private
       */

    }, {
      key: "onconnect",
      value: function onconnect(id) {
        this.id = id;
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
      }
      /**
       * Emit buffered events (received and emitted).
       *
       * @private
       */

    }, {
      key: "emitBuffered",
      value: function emitBuffered() {
        var _this4 = this;

        this.receiveBuffer.forEach(function (args) {
          return _this4.emitEvent(args);
        });
        this.receiveBuffer = [];
        this.sendBuffer.forEach(function (packet) {
          _this4.notifyOutgoingListeners(packet);

          _this4.packet(packet);
        });
        this.sendBuffer = [];
      }
      /**
       * Called upon server disconnect.
       *
       * @private
       */

    }, {
      key: "ondisconnect",
      value: function ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
      }
      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @private
       */

    }, {
      key: "destroy",
      value: function destroy() {
        if (this.subs) {
          // clean subscriptions to avoid reconnections
          this.subs.forEach(function (subDestroy) {
            return subDestroy();
          });
          this.subs = undefined;
        }

        this.io["_destroy"](this);
      }
      /**
       * Disconnects the socket manually.
       *
       * @return self
       * @public
       */

    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this.connected) {
          this.packet({
            type: PacketType.DISCONNECT
          });
        } // remove socket from pool


        this.destroy();

        if (this.connected) {
          // fire events
          this.onclose("io client disconnect");
        }

        return this;
      }
      /**
       * Alias for disconnect()
       *
       * @return self
       * @public
       */

    }, {
      key: "close",
      value: function close() {
        return this.disconnect();
      }
      /**
       * Sets the compress flag.
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       * @public
       */

    }, {
      key: "compress",
      value: function compress(_compress) {
        this.flags.compress = _compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
       * ready to send messages.
       *
       * @returns self
       * @public
       */

    }, {
      key: "volatile",
      get: function get() {
        this.flags["volatile"] = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the server:
       *
       * ```
       * socket.timeout(5000).emit("my-event", (err) => {
       *   if (err) {
       *     // the server did not acknowledge the event in the given delay
       *   }
       * });
       * ```
       *
       * @returns self
       * @public
       */

    }, {
      key: "timeout",
      value: function timeout(_timeout) {
        this.flags.timeout = _timeout;
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @param listener
       * @public
       */

    }, {
      key: "onAny",
      value: function onAny(listener) {
        this._anyListeners = this._anyListeners || [];

        this._anyListeners.push(listener);

        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @param listener
       * @public
       */

    }, {
      key: "prependAny",
      value: function prependAny(listener) {
        this._anyListeners = this._anyListeners || [];

        this._anyListeners.unshift(listener);

        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @param listener
       * @public
       */

    }, {
      key: "offAny",
      value: function offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }

        if (listener) {
          var listeners = this._anyListeners;

          for (var i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }

        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       *
       * @public
       */

    }, {
      key: "listenersAny",
      value: function listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @param listener
       *
       * <pre><code>
       *
       * socket.onAnyOutgoing((event, ...args) => {
       *   console.log(event);
       * });
       *
       * </pre></code>
       *
       * @public
       */

    }, {
      key: "onAnyOutgoing",
      value: function onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];

        this._anyOutgoingListeners.push(listener);

        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @param listener
       *
       * <pre><code>
       *
       * socket.prependAnyOutgoing((event, ...args) => {
       *   console.log(event);
       * });
       *
       * </pre></code>
       *
       * @public
       */

    }, {
      key: "prependAnyOutgoing",
      value: function prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];

        this._anyOutgoingListeners.unshift(listener);

        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @param listener
       *
       * <pre><code>
       *
       * const handler = (event, ...args) => {
       *   console.log(event);
       * }
       *
       * socket.onAnyOutgoing(handler);
       *
       * // then later
       * socket.offAnyOutgoing(handler);
       *
       * </pre></code>
       *
       * @public
       */

    }, {
      key: "offAnyOutgoing",
      value: function offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }

        if (listener) {
          var listeners = this._anyOutgoingListeners;

          for (var i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }

        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       *
       * @public
       */

    }, {
      key: "listenersAnyOutgoing",
      value: function listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent
       *
       * @param packet
       *
       * @private
       */

    }, {
      key: "notifyOutgoingListeners",
      value: function notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          var listeners = this._anyOutgoingListeners.slice();

          var _iterator2 = _createForOfIteratorHelper(listeners),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var listener = _step2.value;
              listener.apply(this, packet.data);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    }]);

    return Socket;
  }(Emitter);

  /**
   * Initialize backoff timer with `opts`.
   *
   * - `min` initial timeout in milliseconds [100]
   * - `max` max timeout [10000]
   * - `jitter` [0]
   * - `factor` [2]
   *
   * @param {Object} opts
   * @api public
   */
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  /**
   * Return the backoff duration.
   *
   * @return {Number}
   * @api public
   */

  Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);

    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }

    return Math.min(ms, this.max) | 0;
  };
  /**
   * Reset the number of attempts.
   *
   * @api public
   */


  Backoff.prototype.reset = function () {
    this.attempts = 0;
  };
  /**
   * Set the minimum duration
   *
   * @api public
   */


  Backoff.prototype.setMin = function (min) {
    this.ms = min;
  };
  /**
   * Set the maximum duration
   *
   * @api public
   */


  Backoff.prototype.setMax = function (max) {
    this.max = max;
  };
  /**
   * Set the jitter
   *
   * @api public
   */


  Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
  };

  var Manager = /*#__PURE__*/function (_Emitter) {
    _inherits(Manager, _Emitter);

    var _super = _createSuper(Manager);

    function Manager(uri, opts) {
      var _this;

      _classCallCheck(this, Manager);

      var _a;

      _this = _super.call(this);
      _this.nsps = {};
      _this.subs = [];

      if (uri && "object" === _typeof$1(uri)) {
        opts = uri;
        uri = undefined;
      }

      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      _this.opts = opts;
      installTimerFunctions(_assertThisInitialized(_this), opts);

      _this.reconnection(opts.reconnection !== false);

      _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);

      _this.reconnectionDelay(opts.reconnectionDelay || 1000);

      _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);

      _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);

      _this.backoff = new Backoff({
        min: _this.reconnectionDelay(),
        max: _this.reconnectionDelayMax(),
        jitter: _this.randomizationFactor()
      });

      _this.timeout(null == opts.timeout ? 20000 : opts.timeout);

      _this._readyState = "closed";
      _this.uri = uri;

      var _parser = opts.parser || parser;

      _this.encoder = new _parser.Encoder();
      _this.decoder = new _parser.Decoder();
      _this._autoConnect = opts.autoConnect !== false;
      if (_this._autoConnect) _this.open();
      return _this;
    }

    _createClass(Manager, [{
      key: "reconnection",
      value: function reconnection(v) {
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        return this;
      }
    }, {
      key: "reconnectionAttempts",
      value: function reconnectionAttempts(v) {
        if (v === undefined) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
    }, {
      key: "reconnectionDelay",
      value: function reconnectionDelay(v) {
        var _a;

        if (v === undefined) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
      }
    }, {
      key: "randomizationFactor",
      value: function randomizationFactor(v) {
        var _a;

        if (v === undefined) return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
      }
    }, {
      key: "reconnectionDelayMax",
      value: function reconnectionDelayMax(v) {
        var _a;

        if (v === undefined) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
      }
    }, {
      key: "timeout",
      value: function timeout(v) {
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
      }
      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @private
       */

    }, {
      key: "maybeReconnectOnOpen",
      value: function maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          // keeps reconnection from firing twice for the same reconnection loop
          this.reconnect();
        }
      }
      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} fn - optional, callback
       * @return self
       * @public
       */

    }, {
      key: "open",
      value: function open(fn) {
        var _this2 = this;

        if (~this._readyState.indexOf("open")) return this;
        this.engine = new Socket$1(this.uri, this.opts);
        var socket = this.engine;
        var self = this;
        this._readyState = "opening";
        this.skipReconnect = false; // emit `open`

        var openSubDestroy = on(socket, "open", function () {
          self.onopen();
          fn && fn();
        }); // emit `error`

        var errorSub = on(socket, "error", function (err) {
          self.cleanup();
          self._readyState = "closed";

          _this2.emitReserved("error", err);

          if (fn) {
            fn(err);
          } else {
            // Only do this if there is no fn to handle the error
            self.maybeReconnectOnOpen();
          }
        });

        if (false !== this._timeout) {
          var timeout = this._timeout;

          if (timeout === 0) {
            openSubDestroy(); // prevents a race condition with the 'open' event
          } // set timer


          var timer = this.setTimeoutFn(function () {
            openSubDestroy();
            socket.close(); // @ts-ignore

            socket.emit("error", new Error("timeout"));
          }, timeout);

          if (this.opts.autoUnref) {
            timer.unref();
          }

          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }

        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      /**
       * Alias for open()
       *
       * @return self
       * @public
       */

    }, {
      key: "connect",
      value: function connect(fn) {
        return this.open(fn);
      }
      /**
       * Called upon transport open.
       *
       * @private
       */

    }, {
      key: "onopen",
      value: function onopen() {
        // clear old subs
        this.cleanup(); // mark as open

        this._readyState = "open";
        this.emitReserved("open"); // add new subs

        var socket = this.engine;
        this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      /**
       * Called upon a ping.
       *
       * @private
       */

    }, {
      key: "onping",
      value: function onping() {
        this.emitReserved("ping");
      }
      /**
       * Called with data.
       *
       * @private
       */

    }, {
      key: "ondata",
      value: function ondata(data) {
        this.decoder.add(data);
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */

    }, {
      key: "ondecoded",
      value: function ondecoded(packet) {
        this.emitReserved("packet", packet);
      }
      /**
       * Called upon socket error.
       *
       * @private
       */

    }, {
      key: "onerror",
      value: function onerror(err) {
        this.emitReserved("error", err);
      }
      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @public
       */

    }, {
      key: "socket",
      value: function socket(nsp, opts) {
        var socket = this.nsps[nsp];

        if (!socket) {
          socket = new Socket(this, nsp, opts);
          this.nsps[nsp] = socket;
        }

        return socket;
      }
      /**
       * Called upon a socket close.
       *
       * @param socket
       * @private
       */

    }, {
      key: "_destroy",
      value: function _destroy(socket) {
        var nsps = Object.keys(this.nsps);

        for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
          var nsp = _nsps[_i];
          var _socket = this.nsps[nsp];

          if (_socket.active) {
            return;
          }
        }

        this._close();
      }
      /**
       * Writes a packet.
       *
       * @param packet
       * @private
       */

    }, {
      key: "_packet",
      value: function _packet(packet) {
        var encodedPackets = this.encoder.encode(packet);

        for (var i = 0; i < encodedPackets.length; i++) {
          this.engine.write(encodedPackets[i], packet.options);
        }
      }
      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @private
       */

    }, {
      key: "cleanup",
      value: function cleanup() {
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs.length = 0;
        this.decoder.destroy();
      }
      /**
       * Close the current socket.
       *
       * @private
       */

    }, {
      key: "_close",
      value: function _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine) this.engine.close();
      }
      /**
       * Alias for close()
       *
       * @private
       */

    }, {
      key: "disconnect",
      value: function disconnect() {
        return this._close();
      }
      /**
       * Called upon engine close.
       *
       * @private
       */

    }, {
      key: "onclose",
      value: function onclose(reason, description) {
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);

        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      /**
       * Attempt a reconnection.
       *
       * @private
       */

    }, {
      key: "reconnect",
      value: function reconnect() {
        var _this3 = this;

        if (this._reconnecting || this.skipReconnect) return this;
        var self = this;

        if (this.backoff.attempts >= this._reconnectionAttempts) {
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          var delay = this.backoff.duration();
          this._reconnecting = true;
          var timer = this.setTimeoutFn(function () {
            if (self.skipReconnect) return;

            _this3.emitReserved("reconnect_attempt", self.backoff.attempts); // check again for the case socket closed in above events


            if (self.skipReconnect) return;
            self.open(function (err) {
              if (err) {
                self._reconnecting = false;
                self.reconnect();

                _this3.emitReserved("reconnect_error", err);
              } else {
                self.onreconnect();
              }
            });
          }, delay);

          if (this.opts.autoUnref) {
            timer.unref();
          }

          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
      }
      /**
       * Called upon successful reconnect.
       *
       * @private
       */

    }, {
      key: "onreconnect",
      value: function onreconnect() {
        var attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    }]);

    return Manager;
  }(Emitter);

  /**
   * Managers cache.
   */

  var cache = {};

  function lookup(uri, opts) {
    if (_typeof$1(uri) === "object") {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    var parsed = url(uri, opts.path || "/socket.io");
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] && path in cache[id]["nsps"];
    var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    var io;

    if (newConnection) {
      io = new Manager(source, opts);
    } else {
      if (!cache[id]) {
        cache[id] = new Manager(source, opts);
      }

      io = cache[id];
    }

    if (parsed.query && !opts.query) {
      opts.query = parsed.queryKey;
    }

    return io.socket(parsed.path, opts);
  } // so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
  // namespace (e.g. `io.connect(...)`), for backward compatibility


  Object.assign(lookup, {
    Manager: Manager,
    Socket: Socket,
    io: lookup,
    connect: lookup
  });

  let canvas$1;
  let ctx;
  class Canvas {
    constructor(width, height) {
      canvas$1 = document.createElement("canvas");
      canvas$1.classList.add("main-canvas");
      document.body.appendChild(canvas$1);
      ctx = canvas$1.getContext("2d");
      ctx.fillStyle = "#FFFFFF";

      this._grain = 0;
      this.setSize(width, height);
    }

    get width() {
      return canvas$1.width;
    }
    set width(v) {
      canvas$1.width = v;
    }
    get height() {
      return canvas$1.height;
    }
    set height(v) {
      canvas$1.height = v;
    }
    get element() {
      return canvas$1;
    }
    get context() {
      return ctx;
    }
    get grain() {
      return this._grain;
    }
    set grain(v) {
      this._grain = v;
      this.clear();
    }

    setClearColor(c) {
      this.fillStyle = c;
      this.clear();
    }

    setSize(w, h) {
      canvas$1.width = w || window.innerWidth;
      canvas$1.height = h || window.innerHeight;
      this.clear();
    }

    clear() {
      const w = canvas$1.width;
      const h = canvas$1.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = this.fillStyle;
      ctx.fillRect(0, 0, w, h);
      if (this.grain > 0) {
        let id = this.imageData(0, 0, w, h);
        ctx.putImageData(this.noise(id, this.grain * 0xff, false), 0, 0);
      }
    }

    crop(imageOrCanvas, rect) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const x = ~~rect.x;
      const y = ~~rect.y;
      const w = ~~rect.width;
      const h = ~~rect.height;
      ctx.canvas.width = w;
      ctx.canvas.height = h;
      ctx.drawImage(imageOrCanvas, x, y, w, h, 0, 0, w, h);
      return canvas;
    }

    drawImageAt(img, x, y) {
      return ctx.drawImage(
        img,
        0,
        0,
        img.width,
        img.height,
        x,
        y,
        img.width,
        img.height
      );
    }

    imageData(x, y, w, h) {
      let idata = ctx.getImageData(x, y, w, h);
      return idata;
    }

    noise(imgData, amount, alpha = false) {
      let id = imgData.data.length;
      while (id >= 0) {
        var noise = ~~((Math.random() - 0.5) * amount);
        imgData.data[id] += noise;
        imgData.data[id + 1] += noise;
        imgData.data[id + 2] += noise;
        if (alpha) imgData.data[id + 3] += noise;
        id -= 4;
      }
      return imgData;
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var hammer = {exports: {}};

  (function (module) {
    (function (window, document, exportName, undefined$1) {

      var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
      var TEST_ELEMENT = document.createElement('div');
      var TYPE_FUNCTION = 'function';
      var round = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      /**
       * set a timeout with a given scope
       * @param {Function} fn
       * @param {Number} timeout
       * @param {Object} context
       * @returns {number}
       */

      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      /**
       * if the argument is an array, we want to execute the fn on each entry
       * if it aint an array we don't want to do a thing.
       * this is used by all the methods that accept a single and array argument.
       * @param {*|Array} arg
       * @param {String} fn
       * @param {Object} [context]
       * @returns {Boolean}
       */


      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }

        return false;
      }
      /**
       * walk objects and arrays
       * @param {Object} obj
       * @param {Function} iterator
       * @param {Object} context
       */


      function each(obj, iterator, context) {
        var i;

        if (!obj) {
          return;
        }

        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined$1) {
          i = 0;

          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      /**
       * wrap a method with a deprecation warning and stack trace
       * @param {Function} method
       * @param {String} name
       * @param {String} message
       * @returns {Function} A new function wrapping the supplied method.
       */


      function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function () {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
          var log = window.console && (window.console.warn || window.console.log);

          if (log) {
            log.call(window.console, deprecationMessage, stack);
          }

          return method.apply(this, arguments);
        };
      }
      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} target
       * @param {...Object} objects_to_assign
       * @returns {Object} target
       */


      var assign;

      if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
          if (target === undefined$1 || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);

          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];

            if (source !== undefined$1 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }

          return output;
        };
      } else {
        assign = Object.assign;
      }
      /**
       * extend object.
       * means that properties in dest will be overwritten by the ones in src.
       * @param {Object} dest
       * @param {Object} src
       * @param {Boolean} [merge=false]
       * @returns {Object} dest
       */


      var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;

        while (i < keys.length) {
          if (!merge || merge && dest[keys[i]] === undefined$1) {
            dest[keys[i]] = src[keys[i]];
          }

          i++;
        }

        return dest;
      }, 'extend', 'Use `assign`.');
      /**
       * merge the values from src in the dest.
       * means that properties that exist in dest will not be overwritten by src
       * @param {Object} dest
       * @param {Object} src
       * @returns {Object} dest
       */

      var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
      }, 'merge', 'Use `assign`.');
      /**
       * simple class inheritance
       * @param {Function} child
       * @param {Function} base
       * @param {Object} [properties]
       */

      function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
          assign(childP, properties);
        }
      }
      /**
       * simple function bind
       * @param {Function} fn
       * @param {Object} context
       * @returns {Function}
       */


      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      /**
       * let a boolean value also be a function that must return a boolean
       * this first item in args will be used as the context
       * @param {Boolean|Function} val
       * @param {Array} [args]
       * @returns {Boolean}
       */


      function boolOrFn(val, args) {
        if (_typeof$1(val) == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
        }

        return val;
      }
      /**
       * use the val2 when val1 is undefined
       * @param {*} val1
       * @param {*} val2
       * @returns {*}
       */


      function ifUndefined(val1, val2) {
        return val1 === undefined$1 ? val2 : val1;
      }
      /**
       * addEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */


      function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.addEventListener(type, handler, false);
        });
      }
      /**
       * removeEventListener with multiple events at once
       * @param {EventTarget} target
       * @param {String} types
       * @param {Function} handler
       */


      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
          target.removeEventListener(type, handler, false);
        });
      }
      /**
       * find if a node is in the given parent
       * @method hasParent
       * @param {HTMLElement} node
       * @param {HTMLElement} parent
       * @return {Boolean} found
       */


      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }

          node = node.parentNode;
        }

        return false;
      }
      /**
       * small indexOf wrapper
       * @param {String} str
       * @param {String} find
       * @returns {Boolean} found
       */


      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      /**
       * split string on whitespace
       * @param {String} str
       * @returns {Array} words
       */


      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      /**
       * find if a array contains the object using indexOf or a simple polyFill
       * @param {Array} src
       * @param {String} find
       * @param {String} [findByKey]
       * @return {Boolean|Number} false when not found, or the index
       */


      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;

          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }

            i++;
          }

          return -1;
        }
      }
      /**
       * convert array-like objects to real arrays
       * @param {Object} obj
       * @returns {Array}
       */


      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      /**
       * unique array with objects based on a key (like 'id') or just by the array's value
       * @param {Array} src [{id:1},{id:2},{id:1}]
       * @param {String} [key]
       * @param {Boolean} [sort=False]
       * @returns {Array} [{id:1},{id:2}]
       */


      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
          var val = key ? src[i][key] : src[i];

          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }

          values[i] = val;
          i++;
        }

        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }

        return results;
      }
      /**
       * get the prefixed property
       * @param {Object} obj
       * @param {String} property
       * @returns {String|Undefined} prefixed
       */


      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;

        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;

          if (prop in obj) {
            return prop;
          }

          i++;
        }

        return undefined$1;
      }
      /**
       * get a unique id
       * @returns {number} uniqueId
       */


      var _uniqueId = 1;

      function uniqueId() {
        return _uniqueId++;
      }
      /**
       * get the window object of an element
       * @param {HTMLElement} element
       * @returns {DocumentView|Window}
       */


      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
      }

      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = ('ontouchstart' in window);
      var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = 'touch';
      var INPUT_TYPE_PEN = 'pen';
      var INPUT_TYPE_MOUSE = 'mouse';
      var INPUT_TYPE_KINECT = 'kinect';
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ['x', 'y'];
      var PROPS_CLIENT_XY = ['clientX', 'clientY'];
      /**
       * create new input type manager
       * @param {Manager} manager
       * @param {Function} callback
       * @returns {Input}
       * @constructor
       */

      function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.

        this.domHandler = function (ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
          }
        };

        this.init();
      }

      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function handler() {},

        /**
         * bind the events
         */
        init: function init() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function destroy() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      /**
       * create new input type manager
       * called by the Manager constructor
       * @param {Hammer} manager
       * @returns {Input}
       */

      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }

        return new Type(manager, inputHandler);
      }
      /**
       * handle input events
       * @param {Manager} manager
       * @param {String} eventType
       * @param {Object} input
       */


      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
          manager.session = {};
        } // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'


        input.eventType = eventType; // compute scale, rotation etc

        computeInputData(manager, input); // emit secret event

        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      /**
       * extend the data with some usable properties like scale, rotate, velocity etc
       * @param {Object} manager
       * @param {Object} input
       */


      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length; // store the first input to calculate the distance and direction

        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        } // to compute scale and rotation we need to store the multiple touches


        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input); // find the correct target

        var target = manager.element;

        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }

        input.target = target;
      }

      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      /**
       * velocity is calculated every x ms
       * @param {Object} session
       * @param {Object} input
       */


      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      /**
       * create a simple clone from the input used for storage of firstInput and firstMultiple
       * @param {Object} input
       * @returns {Object} clonedInputData
       */


      function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;

        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
          };
          i++;
        }

        return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      /**
       * get the center of all the pointers
       * @param {Array} pointers
       * @return {Object} center contains `x` and `y` properties
       */


      function getCenter(pointers) {
        var pointersLength = pointers.length; // no need to loop when only one touch

        if (pointersLength === 1) {
          return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
          };
        }

        var x = 0,
            y = 0,
            i = 0;

        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }

        return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
        };
      }
      /**
       * calculate the velocity between two points. unit is in px per ms.
       * @param {Number} deltaTime
       * @param {Number} x
       * @param {Number} y
       * @return {Object} velocity `x` and `y`
       */


      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      /**
       * get the direction between two points
       * @param {Number} x
       * @param {Number} y
       * @return {Number} direction
       */


      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }

        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      /**
       * calculate the absolute distance between two points
       * @param {Object} p1 {x, y}
       * @param {Object} p2 {x, y}
       * @param {Array} [props] containing x and y keys
       * @return {Number} distance
       */


      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }

        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      /**
       * calculate the angle between two coordinates
       * @param {Object} p1
       * @param {Object} p2
       * @param {Array} [props] containing x and y keys
       * @return {Number} angle
       */


      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }

        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      /**
       * calculate the rotation degrees between two pointersets
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} rotation
       */


      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      /**
       * calculate the scale factor between two pointersets
       * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
       * @param {Array} start array of pointers
       * @param {Array} end array of pointers
       * @return {Number} scale
       */


      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }

      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = 'mousedown';
      var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
      /**
       * Mouse events input
       * @constructor
       * @extends Input
       */

      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
      }

      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          } // mouse must be down


          if (!this.pressed) {
            return;
          }

          if (eventType & INPUT_END) {
            this.pressed = false;
          }

          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      }; // in IE10 the pointer types is defined as an enum

      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

      };
      var POINTER_ELEMENT_EVENTS = 'pointerdown';
      var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

      if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
      }
      /**
       * Pointer events input
       * @constructor
       * @extends Input
       */


      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }

      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

          var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          } // it not found, so the pointer hasn't been down (so it's probably a hover)


          if (storeIndex < 0) {
            return;
          } // update the event in the store


          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
          });

          if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
      var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
      /**
       * Touch events input
       * @constructor
       * @extends Input
       */

      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }

      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

          if (type === INPUT_START) {
            this.started = true;
          }

          if (!this.started) {
            return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }

          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */

      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
      }

      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
      /**
       * Multi-user touch events input
       * @constructor
       * @extends Input
       */

      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }

      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);

          if (!touches) {
            return;
          }

          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      /**
       * @this {TouchInput}
       * @param {Object} ev
       * @param {Number} type flag
       * @returns {undefined|Array} [all, changed]
       */

      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target; // get target touches from touches

        targetTouches = allTouches.filter(function (touch) {
          return hasParent(touch.target, target);
        }); // collect touches

        if (type === INPUT_START) {
          i = 0;

          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        } // filter changed touches to only contain touches that exist in the collected target ids


        i = 0;

        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          } // cleanup removed touches


          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }

          i++;
        }

        if (!changedTargetTouches.length) {
          return;
        }

        return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
      }
      /**
       * Combined touch and mouse input
       *
       * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
       * This because touch devices also emit mouse events while doing a touch.
       *
       * @constructor
       * @extends Input
       */


      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;

      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }

      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
              isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }

          this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });

      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }

      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
          var lastTouch = {
            x: touch.clientX,
            y: touch.clientY
          };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;

          var removeLastTouch = function removeLastTouch() {
            var i = lts.indexOf(lastTouch);

            if (i > -1) {
              lts.splice(i, 1);
            }
          };

          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }

      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX,
            y = eventData.srcEvent.clientY;

        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x),
              dy = Math.abs(y - t.y);

          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }

        return false;
      }

      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1; // magical touchAction value

      var TOUCH_ACTION_COMPUTE = 'compute';
      var TOUCH_ACTION_AUTO = 'auto';
      var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

      var TOUCH_ACTION_NONE = 'none';
      var TOUCH_ACTION_PAN_X = 'pan-x';
      var TOUCH_ACTION_PAN_Y = 'pan-y';
      var TOUCH_ACTION_MAP = getTouchActionProps();
      /**
       * Touch Action
       * sets the touchAction property or uses the js alternative
       * @param {Manager} manager
       * @param {String} value
       * @constructor
       */

      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }

      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function set(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }

          this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function update() {
          this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function compute() {
          var actions = [];
          each(this.manager.recognizers, function (recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function preventDefaults(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection; // if the touch action did prevented once this session

          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
            //do not prevent defaults if this is a tap gesture
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }

          if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
          }

          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function preventSrc(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      /**
       * when the touchActions are collected they are not a valid value, so we need to clean things up. *
       * @param {String} actions
       * @returns {*}
       */

      function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning

        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        } // pan-x OR pan-y


        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        } // manipulation


        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
      }

      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }

        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
      }
      /**
       * Recognizer flow explained; *
       * All recognizers have the initial state of POSSIBLE when a input session starts.
       * The definition of a input session is from the first input until the last input, with all it's movement in it. *
       * Example session for mouse-input: mousedown -> mousemove -> mouseup
       *
       * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
       * which determines with state it should be.
       *
       * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
       * POSSIBLE to give it another change on the next cycle.
       *
       *               Possible
       *                  |
       *            +-----+---------------+
       *            |                     |
       *      +-----+-----+               |
       *      |           |               |
       *   Failed      Cancelled          |
       *                          +-------+------+
       *                          |              |
       *                      Recognized       Began
       *                                         |
       *                                      Changed
       *                                         |
       *                                  Ended/Recognized
       */


      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      /**
       * Recognizer
       * Every recognizer needs to extend from this class.
       * @constructor
       * @param {Object} options
       */

      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null; // default is enable true

        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }

      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function set(options) {
          assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

          this.manager && this.manager.touchAction.update();
          return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function recognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }

          return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function requireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }

          return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function dropRequireFailure(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);

          if (index > -1) {
            this.requireFail.splice(index, 1);
          }

          return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function hasRequireFailures() {
          return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function canRecognizeWith(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function emit(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
            self.manager.emit(event, input);
          } // 'panstart' and 'panmove'


          if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) {
            // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
          } // panend and pancancel


          if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
          }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function tryEmit(input) {
          if (this.canEmit()) {
            return this.emit(input);
          } // it's failing anyway


          this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function canEmit() {
          var i = 0;

          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }

            i++;
          }

          return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          } // reset when we've reached the end


          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
          // so trigger an event

          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function process(inputData) {},
        // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function getTouchAction() {},

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function reset() {}
      };
      /**
       * get a usable string, used as event postfix
       * @param {Const} state
       * @returns {String} state
       */

      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return 'cancel';
        } else if (state & STATE_ENDED) {
          return 'end';
        } else if (state & STATE_CHANGED) {
          return 'move';
        } else if (state & STATE_BEGAN) {
          return 'start';
        }

        return '';
      }
      /**
       * direction cons to string
       * @param {Const} direction
       * @returns {String}
       */


      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return 'down';
        } else if (direction == DIRECTION_UP) {
          return 'up';
        } else if (direction == DIRECTION_LEFT) {
          return 'left';
        } else if (direction == DIRECTION_RIGHT) {
          return 'right';
        }

        return '';
      }
      /**
       * get a recognizer by name if it is bound to a manager
       * @param {Recognizer|String} otherRecognizer
       * @param {Recognizer} recognizer
       * @returns {Recognizer}
       */


      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;

        if (manager) {
          return manager.get(otherRecognizer);
        }

        return otherRecognizer;
      }
      /**
       * This recognizer is just used as a base for the simple attribute recognizers.
       * @constructor
       * @extends Recognizer
       */


      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }

      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function attrTest(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function process(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }

            return state | STATE_CHANGED;
          }

          return STATE_FAILED;
        }
      });
      /**
       * Pan
       * Recognized when the pointer is down and moved in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */

      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }

      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function getTouchAction() {
          var direction = this.options.direction;
          var actions = [];

          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }

          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }

          return actions;
        },
        directionTest: function directionTest(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY; // lock to axis?

          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }

          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function attrTest(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function emit(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);

          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }

          this._super.emit.call(this, input);
        }
      });
      /**
       * Pinch
       * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
       * @constructor
       * @extends AttrRecognizer
       */

      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function emit(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
          }

          this._super.emit.call(this, input);
        }
      });
      /**
       * Press
       * Recognized when the pointer is down for x ms without any movement.
       * @constructor
       * @extends Recognizer
       */

      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }

      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: 'press',
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low

        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input; // we only allow little movement
          // and we've reached an end event, so a tap is possible

          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }

          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }

          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + 'up', input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      /**
       * Rotate
       * Recognized when two or more pointer are moving in a circular motion.
       * @constructor
       * @extends AttrRecognizer
       */

      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function attrTest(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      /**
       * Swipe
       * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
       * @constructor
       * @extends AttrRecognizer
       */

      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }

      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function getTouchAction() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function attrTest(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function emit(input) {
          var direction = directionStr(input.offsetDirection);

          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
        }
      });
      /**
       * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
       * between the given interval and position. The delay option can be used to recognize multi-taps without firing
       * a single tap.
       *
       * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
       * multi-taps being recognized.
       * @constructor
       * @extends Recognizer
       */

      function TapRecognizer() {
        Recognizer.apply(this, arguments); // previous time and center,
        // used for tap counting

        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }

      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position

        },
        getTouchAction: function getTouchAction() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function process(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();

          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          } // we only allow little movement
          // and we've reached an end event, so a tap is possible


          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }

            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }

            this._input = input; // if tap count matches we have recognized it,
            // else it has began recognizing...

            var tapCount = this.count % options.taps;

            if (tapCount === 0) {
              // no failing requirements, immediately trigger the tap event
              // or wait as long as the multitap interval to trigger
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function () {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }

          return STATE_FAILED;
        },
        failTimeout: function failTimeout() {
          this._timer = setTimeoutContext(function () {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function reset() {
          clearTimeout(this._timer);
        },
        emit: function emit() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      /**
       * Simple way to create a manager with a default set of recognizers.
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */

      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
      }
      /**
       * @const {string}
       */


      Hammer.VERSION = '2.0.7';
      /**
       * default settings
       * @namespace
       */

      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {
          enable: false
        }], [PinchRecognizer, {
          enable: false
        }, ['rotate']], [SwipeRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }], [PanRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }, ['swipe']], [TapRecognizer], [TapRecognizer, {
          event: 'doubletap',
          taps: 2
        }, ['tap']], [PressRecognizer]],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      /**
       * Manager
       * @param {HTMLElement} element
       * @param {Object} [options]
       * @constructor
       */

      function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function (item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }

      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function set(options) {
          assign(this.options, options); // Options that need a little more setup

          if (options.touchAction) {
            this.touchAction.update();
          }

          if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }

          return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function stop(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function recognize(inputData) {
          var session = this.session;

          if (session.stopped) {
            return;
          } // run the touch-action polyfill


          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`

          var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
          // or when we're in a new session

          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }

          var i = 0;

          while (i < recognizers.length) {
            recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.

            if (session.stopped !== FORCED_STOP && ( // 1
            !curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              // 3
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer


            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }

            i++;
          }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function get(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }

          var recognizers = this.recognizers;

          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }

          return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function add(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
          } // remove existing


          var existing = this.get(recognizer.options.event);

          if (existing) {
            this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function remove(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
          }

          recognizer = this.get(recognizer); // let's make sure this recognizer exists

          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }

          return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function on(events, handler) {
          if (events === undefined$1) {
            return;
          }

          if (handler === undefined$1) {
            return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function off(events, handler) {
          if (events === undefined$1) {
            return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function (event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function emit(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          } // no handlers, so skip it all


          var handlers = this.handlers[event] && this.handlers[event].slice();

          if (!handlers || !handlers.length) {
            return;
          }

          data.type = event;

          data.preventDefault = function () {
            data.srcEvent.preventDefault();
          };

          var i = 0;

          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function destroy() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      /**
       * add/remove the css properties as defined in manager.options.cssProps
       * @param {Manager} manager
       * @param {Boolean} add
       */

      function toggleCssProps(manager, add) {
        var element = manager.element;

        if (!element.style) {
          return;
        }

        var prop;
        each(manager.options.cssProps, function (value, name) {
          prop = prefixed(element.style, name);

          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
          }
        });

        if (!add) {
          manager.oldCssProps = {};
        }
      }
      /**
       * trigger dom event
       * @param {String} event
       * @param {Object} data
       */


      function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }

      assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
      }); // this prevents errors when Hammer is loaded in the presence of an AMD
      //  style loader but by script tag, not by the loader.

      var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

      freeGlobal.Hammer = Hammer;

      if (typeof undefined$1 === 'function' && undefined$1.amd) {
        undefined$1(function () {
          return Hammer;
        });
      } else if (module.exports) {
        module.exports = Hammer;
      } else {
        window[exportName] = Hammer;
      }
    })(window, document, 'Hammer');
  })(hammer);

  var Hammer = hammer.exports;

  // TODO:
  // free drawing on the image => isolate mask blobs => send in bacth to inpainting
  class DrawingPad {
    constructor(settings) {
      this.ctx = this.getContext(512, 512);
      this.canvas = this.ctx.canvas;
      this.hide();

      this.brush = settings;
      this.resetBrush();

      //listen to changes in the params
      settings.bindings.brush_size.on("change", this.resetBrush.bind(this));
      settings.bindings.softness.on("change", this.resetBrush.bind(this));

      let mc = new Hammer(this.canvas);
      mc.on("panstart pan panend", (e) => {
        this.update(e);
      });
      this._locked = false;
    }
    get locked() {
      return this._locked;
    }
    set locked(v) {
      this._locked = v;
    }

    clear() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    resize(w, h) {
      this.canvas.width = w;
      this.canvas.height = h;
    }

    show() {
      this.canvas.classList.remove("fade-out");
      this.canvas.classList.add("fade-in");
      this.locked = false;
    }

    hide() {
      this.canvas.classList.add("fade-out");
      this.canvas.classList.remove("fade-in");
      this.locked = true;
    }

    resetBrush() {
      let soft = this.brush.softness;
      let size = this.brush.brush_size;
      let r = size / 2;
      this.brush.pattern = this.ctx.createRadialGradient(r, r, 0, r, r, r);
      this.brush.pattern.addColorStop(0, `rgba(255,255,255,${soft})`);
      this.brush.pattern.addColorStop(1, `rgba(255,255,255,0)`);
    }

    update(e) {
      if (this.locked) return;

      let rect = this.canvas.getBoundingClientRect();
      let size = this.brush.brush_size;
      let x = ~~(e.center.x - size / 2) - rect.x;
      let y = ~~(e.center.y - size / 2) - rect.y;
      if (this.brush.pattern == undefined) {
        this.resetBrush();
      }
      this.ctx.fillStyle = this.brush.pattern;
      this.ctx.globalAlpha = this.brush.alpha;
      this.ctx.save();
      this.ctx.globalCompositeOperation = "lighten";
      this.ctx.translate(x, y);
      this.ctx.fillRect(0, 0, size, size);
      this.ctx.restore();
    }

    getContext(w, h) {
      const canvas = document.createElement("canvas");
      canvas.width = w || window.innerWidth;
      canvas.height = h || window.innerHeight;
      return canvas.getContext("2d", { willReadFrequently: true });
    }
  }

  const history$1 = [];
  let _canvas$1;

  class History {
    constructor(canvas, ui) {
      _canvas$1 = canvas;
      ui.on("undo", () => {
        this.popState();
      });
      ui.on("redo", () => {}); //TODO
    }

    pushState(imageOrCanvas, rect) {
      const x = ~~rect.x;
      const y = ~~rect.y;
      const w = ~~rect.width;
      const h = ~~rect.height;
      const state = { imageOrCanvas, rect: { x, y, w, h } };
      history$1.push(state);
      return state;
    }

    popState() {
      if (history$1.length <= 0) {
        _canvas$1.clear();
        return;
      }
      history$1.pop();
      if (history$1.length <= 0) return;

      _canvas$1.clear();
      for (let i = 0; i < history$1.length; i++) {
        const state = history$1[i];
        _canvas$1.drawImageAt(state.imageOrCanvas, state.rect.x, state.rect.y);
      }
    }
  }

  // list of prompts
  const prompts_list = [
    "an oil tanker drydock constructed in a field in the countryside by John Constable and Tyler Edlin, artstation",
    "ww1 warship in drydock near an European village countryside landscape by Casper David Friedrich, artstation",
    "cossacks marching near a warship in the countryside landscape by Tyler Edlin and Caspar David Friedrich, artstation",
    "a crashed warship, a fishing village on the river in a mountain landscape by Casper David Friedrich, warship on artstation, mountain landsape on artstation, village on artstation",
    "a flower field landscape, an abandoned building in a field, a mural of flowers on the side of an abandoned building, a rusty car, trending on artstation, cinematic lighting, vibrant",
    "a shipwreck on a sci-fi alien desert landscape, german romanticism, artstation, digital art, magical realism, moody palette, contrasting",
    "shipwreck on a twisted alien landscape, abandoned twisted alien landscape by Casper David Friedrich, whispy clouds, planets and stars in the sky, artstation",
    "a flower field landscape, an abandoned castle in a field, a mural of flowers on the side of an abandoned castle, petals flying in the breeze, butterflies, artstation, cinematic lighting, vibrant",
    "an abandoned skyscraper in a field of flowers, petals flying in the breeze, flowers made of metal shards, cinematic lighting, vibrant",
    "an abandoned skyscraper in a field in an autumn pastoral landscape, cinematic lighting, vibrant, surrealism, deviantart",
    "an abandoned boat in a frozen winter wonderland lake, snowflakes drifting in the breeze, impressionism, magical realism",
    "a sailboat docked at a boathouse, snowflakes drifting in the breeze, cinematic lighting, vibrant, winter wonderland",
    "an abandoned building in a field of flowers landscape by caspar david friedrich and RHADS, artstation, cinematic lighting",
    "an iridescent cottage on a crumbling cliffside by the sea, by Tyler Edlin and Andreas Rocha, deviantart, digital painting",
    "a surreal digital art illustraiton of an abandoned castle in a field of flowers landscape by Victo Ngai, flowers, butterflies",
    "a glowing obelisk on a mountain by Alejandro Burdisio and Tyler Edlin and RHADS, digital paintnig, award-winning",
    "ruins of an abandoned medieval city in wasteland landscape by Felix Kelly and Richard Anderson, oil on canvas, american romanticism",
    "an abandoned city in a tropical swamp landscape by Gediminas Pranckevicius and Jacek Yerka, murals of tropical flowers, artstation, vibrant, cinematic lighting",
    "an abandoned city in a lakes and field of flowers landscape, oil on canvas, award-winning, textured, moody palette, deviantart",
    "an abandoned building in a field of flowers by Jean Delville and Thomas Kinkade, a mural of flowers on an abandoned building, highly detailed matte painting, vibrant",
    "an abandoned cathedral in a field of flowers by Jean Delville and John Atkinson Grimshaw, highly detailed matte painting, german romanticism",
    "streets of the abandoned city overgrown with blooming vines by Jean Delville and John Atkinson Grimshaw and Gilbert Williams, concept art",
    "lightning storm over the grand canyon, dramatic scenery, cinematic lighting, graphic illustration, by Gilbert Williams and RHADS",
    "swirling green plasma, infinite celestial sea of darkness, deviantart, digital art, contrasting, simple subject",
    "swarm of green fireflies over a dark nightscape landscape by Gilbert Williams and Beeple, digital painting, award winning, artstation",
    "a dark wizard tower photographed by ansel adams and painted by RHADS, oil on canvas",
    "an aquarium in a dimly lit room, abandoned industrial room, low hanging flourescent light, digital painting, contest-winner",
    "an aquarium in a dimly lit abandoned industrial room, low hanging fluorescent light, artstation",
    "imposing glowing sci-fi neon obelisks on a snowy landscape, falling snow, oil on canvas, artstation",
    "60's mainframes in a dimly lit abandoned industrial room, low hanging fluorescent light, digital art, clean, dark, high-contrast, moody palette",
    "60's mainframes in a dimly lit abandoned industrial room, face renders on computer screens with face renders, low hanging fluorescent light, trending on artstation",
    "a cylinder aquarium in a dimly lit abandoned warehouse, low hanging fluorescent light, lab equipment, trending on artstation",
    "a tropical aquarium in a dimly lit abandoned atrium, skylights, trending on artstation, steampunk",
    "an aquarium in an atrium, a crowd gathers, skylights, trending on artstation, steampunk, victorian",
    "a panel aquarium in a dim abandoned warehouse, low hanging fluorescent light, artstation, digital art, 35mm photograph",
    "abandoned cyberpunk lab, an aquarium in a dimly lit cyberpunk lab, low hanging fluorescent light, by Syd Mead and James Turrell",
    "intricate crumbling ivy covered wall by claude monet, detailed impressionism painting, artstation",
    "a majestic dieselpunk battlemech standing near a russian orthodox church on a snowing landscape, by Gilbert Williams and Barclay Shaw, concept art",
    "an imposing dieselpunk mech in the autumn countryside by Ivan Aivazovsky and Greg Rutkowski, trending on artstation, cinematic lighting",
    "an imposing clockwork elephant mech on an arctic landscape by Ivan Aivazovsky and Greg Rutkowski, digital painting, highly detailed, award winning concept art",
    "a space marine bear by Ivan Aivazovsky and Greg Rutkowski, warhammer 40k",
    "a space marine bear by george stubbs and greg rutkowski, warhammer 40k, illustration",
    "post-industrial smokestacks on lava flows across the wasteland with belching smoke filling the sky, red lighting lacing the clouds, by Ivan Aivazovsky and Greg Rutkowski, artstation",
    "giant sinister twisted rose vines cover the wizard tower in the forest by tyler edlin and gilbert williams, highly detailed matte painting, surrealism ",
    "an imposing lighthouse in a nebula by tyler edlin and RHADS, artstation, oil on canvas, magical realism, science fiction concept art",
    "a beautiful painting of a circular portal opening to a flower ocean dimension embedded in an asteroid floating in a nebula by RHADS, trending on deviantart, vibrant",
    "a beautiful painting of a tree on an asteroid in a vast nebula by Albert Bierstadt and Tyler Edlin and RHADS",
    "a painting of an ancient magical mystical willow tree on an asteroid in a vast nebula by Tyler Edlin and RHADS and Gilbert Williams",
    "a stunning portrait of a woman pondering the wilderness by RHADS and Gilbert Williams, artstation, digital painting",
    "an abandoned building on an asteroid in a vast nebula by Tyler Edlin and John Harris and Hubert Robert, concept art, impressionism, watercolor",
    "a spanish galleon sailing on a vast and beautiful nebula by ivan aivazovsky and John Harris, celestial sea",
    "a beautiful painting of a sailboat sailing on a nebula by RHADS and Gilbert Williams, deviantart",
    "whales swimming through vast and beautiful clouds by RHADS and Ross Tran and Albert Bierdstat, artstation, god rays, surrealism",
    "inside an abandoned 1980's mall, retrowave, 35mm photograph, Memphis Design, HD photograph, octane soft render",
    "empty waiting room with yellow wallpaper, found photograph, by ansel adams, washed out color",
    "empty unsettling waiting room with yellow wallpaper, 3d room render, trending on artstation",
    "an imposing mech standing in a wheat field on an overcast summer day by john constable, artstation",
    "a beautiful painting of an abandoned rusty cyberpunk city, neon signs, in the style of syd mead and greg rutkowski, artstation",
    "an abandoned and decaying city screenprint by dan mumford, cuberpunk style, blinking neon signs, artstation",
    "a illustration of a diner on the street corner of a rusty cyberpunk city, neon signs, trending on artstation",
    "a diorama of colorful soil layers, waterfalls between layers over the wooden buildings between the layers, magic realism painting by Alexander Jansson and machinarium",
    "on the streets of the ancient city sinking into the briny deep by Tyler Edlin, artstation, vivid, vibrant",
    "Zoroastrian towers on a desert landscape by Andreas Rocha and Hubert Robert, digital art, magical realism, fantasy concept art",
    "portrait of the devine cybernetic angel by Peter Mohrbacher and Ross Tran, character design, octane soft render, cyberpunk",
    "empress of clockwork spacetime painted by Peter Mohrbacher and Ross Tran",
    "stunning beautiful portrait of clockwork singularity princess painted by Peter Mohrbacher and WLOP, rossdraws, digital painting",
    "portrait of a stunning beautiful explosion over the ocean by Peter Mohrbacher, character design, surrealism, vibrant palette",
    "a luminous orchid garden painted by Albert Bierstadt and Hubert Robert, oil on canvas, magical realism, luminous",
    "painting of a secret cottage in a luminous orchid garden by Albert Bierstadt and Jean Delville, artstation",
    "mystical painting of a cute dark orchid garden by Alexander Jansson",
    "stunning painting of a lone rusted imposing mech in a wheatfield by Simon Stlenhag and beeple, digital painting, soft render, moody palette",
    "an imposing mecha-samurai hybrid in a field of violet flowers by Gediminas Pranckevicius and beeple, dieselpunk aesthetic",
    "a landscape painting of retro diner outside los angeles by Peter Mohrbacher and Simon Stlenhag, retrowave noir",
    "a lighthouse on a cliffside overlooking the turbulent bay by Tyler Edlin and ivan aivazovsky",
    "cherry blossom tree next to a serene river by Ross Tran and Tyler Edlin, magical realism, impressionism, watercolor, award winnin",
    "a bioluminescent jellyfish over futuristic cityscape, deviantart, cinematic lighting, vibrant",
    "hyperrealism painting, underwater sea sponges, tending on deviantart, cinematic lighting, god rays, pastel palette, pastelwave",
    "impressionism painting by Bob Ross, volcano, lava, trees, boulders, obsidian, trending on artstation",
    "realism landscape oil painting, rusty dilapitated metal buildings, foggy ground, graffiti on buildings, vibrant",
    "magical realism painting of a lighting storm over the ocean by Ivan Aivazovsky dark night",
    "naturalism painting of vineyard, vibrant palette, bright sky, clouds",
    "landscape painting of a field of blue roses, a lone greenhouse in the field",
    "realism painting of a pack of wolves in a snowy field, snowing, twilight skies, aurora borealis, by Albert Bierstadt",
    "landscape painting of grassy field with many Pikachu by Albert Bierstadt, afternoon skies, vibrant, trees",
    "futuristic cyber city slums landscape by Liam Wong, highly detailed matte painting",
    "beautiful cyberpunk portrait by Liam Wong and Ross Tran, artstation, dark, contrasting, noir",
    "a ruined cathedral in a field of flowers by Dan Mumford, digital art, gothic art",
    "a ruined building on a field of flowers on a stormy day by Wayne Barlowe and Hans Bellmer, turbulent clouds, concept art, cinematic lighting",
    "a glass tower on a field of flowers landscape by Mike Winkelmann and Beeple, surrealism, futurism",
    "a singular glass tower in a field of flowers landscape by John Atkinson Grimshaw, highly detailed 3d matte painting",
    "massive subterranean galaxy in sprawling ancient ruins of atlantis, a dramatic matte painting by Tyler Edlin, trending on artstation, vivid and vibrant",
    "a stunning painting of a mystical glass tower in the town square by John Atkinson Grimshaw, highly detailed matte painting, nightscape",
    "an ominous painting of the Eiffel tower by Zdzisaw Beksiski",
    "a beautiful portrait of mecha statue of liberty by  James Jean and Ross Tran",
    "a magic realism painting by Gediminas Pranckevicius depicting an abandoned building in a field of flowers landscape, vibrant, cinematic lighting",
    "watercolour image of hooded figure standing in small boat collecting orbs of light from a river",
    "a majestic glass tower in a serene oceanic landscape illustrated by john atkinson grimshaw and thomas kinkade, digital art, magic realism",
    "portrait of a stunning woman in los angeles by Peter Mohrbacher and Ross Tran, retrowave noir",
    "sinister abandoned factory building in a desolate landscape by Laurie Lipton and Patrick Woodroffe, withered roses, dramatic scenery, synthwave",
    "a painting of a person standing in front of a house, a matte painting by chris cold, cgsociety, neo-romanticism, matte painting, atmospheric, volumetric lighting",
    "a beautiful portrait of a vine blossom fairy by Ross Tran and Leonardo da Vinci, rossdraws, highly detailed digital painting",
    "a contemporary mansion in a field of flowers landscape by Ross Tran and Caspar David Friedrich, oil on canvas, dramatic scenery, moody palette",
    "a beautiful portrait of a woman by Ross Tran and Leonardo da Vinci, rossdraws, artstation, piercing gaze",
    "robotic android on a balcony pondering the baroque city, artstation, oil and canvas, nightscape, at night",
    "portrait of a brooding magic investigator woman, by Tom Bagshaw and Sophie Anderson and Antoine Blanchard, moody palette, oil on canvas, neon light illumination, noir",
    "aesthetic masterpiece vaporwave woman portrait painting by Antoine Blanchard and Vincent Callebaut",
    "architectural sci-fi brutalist monument, nightscape, surrealism, oil on canvas, award winning, contest winner, by John Atkinson Grimshaw and Thomas Kinkade",
    "steampunk brutalist structural steampunk victorian monument in a field of flowers, deviantart, oil on canvas, moody palette, cinematic lighting",
    "a stunning painting of vintage truck parked on a mountain overlook, vaporwave palette, matte painting, moody palette, deviantart",
    "giant blooming flower on the alien planet topology, render, by Beeple and Gilbert Williams, magical realism, artstation",
    "warm cottage on a black sand beach, digital art, surrealism, dark ominous lonely, oil on canvas, textured painting, american romanticism",
    "cold concrete brutalist spomenik monument in the grand canyon, by john harris and tyler edlin and caspar david friedrich, graphic novel style",
    "portrait of mysterious handsome noir spacetime detective by Dante Gabriel Rossetti and Edward Moran and Charlie Bowater, magical realism, cgsociety, artstation",
    "a vast planetary sci-fi city by Ansel Adams and Bernardo Bellotto, oil on canvas, artstation, dramatic scenery, masterpiece, aesthetic",
    "a stunning profile portrait of art deco empress, by Evelyn De Morgan and Ross Tran, rossdraws, fresco, piercing gaze, black hair",
    "a portrait of a character in a scenic environment by John Atkinson Grimshaw by RHADS and Gilbert Williams, artstation",
    "movie still from a dark city noir thriller sci-fi movie by Monet, vibrant, impressionism, artstation, HBO, warner brothers",
    "portrait of aesthetic angelic vaporwave noir woman, by John Watkiss, by John Atkinson Grimshaw, soft lighting, deviantart, contrasting, dark, character concept illustration",
    "an aesthetic closeup portrait of a noir woman with red hair painted by John Atkinson Grimshaw and Antoine Blanchard, autumn palette, artstation",
    "a lonely ship adrift in the endless ocean of time, digital art, distant birds, moody palette",
    "descent into infinite madness, surrealism, oil on canvas, texture painting, statement piece, artstation, dark ominous scene, digital art",
    "clockwork wizard tower in the woods, artstation, highly detailed impressionism, cinematic lighting, watercolor, masterpiece, aesthetic",
    "cat sitting on the street, well composed cityscape painting, oil on canvas, watercolor, highly detailed impressionist painting",
    "synthwave 1980 sports car on an Arctic landscape, artstation, by Jordan Grimmer and RHADS and Gilbert Williams",
    "aesthetic iridescent crumbling cottage on a cliff by the sea, oil on canvas, artstation, soft render",
    "aesthetic warrior sorceress in scale armor portrait by Raymond Swanland, cyberpunk, sci-fi cybernetic implants",
    "Lilith, ada Lovelace portrait, Deadpool, gothic, artstation, oil on canvas",
    "aesthetic angelic redhead woman stone portrait by Anna Dittmann and Harumi Hironaka and Filip Hodas, flowers, magical, artsy, impressionism",
    "aesthetic stunning portrait of a woman on the roof watching the sunset by Daniel F. Gerhartz and Liam Wong, nocturne, impressionism, noir aesthetic",
    "stunning portrait of a man at a piano by Daniel F. Gerhartz and Liam Wong, nocturne, impressionism, noir aesthetic, neon lights, dark, contrast",
    "stunning portrait of a woman in an office by Daniel F. Gerhartz and Liam Wong, nocturne, impressionism, noir aesthetic",
    "stunning portrait of a woman walking on the magnificent mile by Wadim Kashin and Liam Wong and Antoine Blanchard, impressionism, concept art, aesthetic, masterpiece",
    "nocturne impressionist noir of a mysterious detective on the streets by Antoine Blanchard, cityscape, monochromatic, rain reflections, octane soft render, vintage detective",
    "planetary megacity sci-fi city by Hugh Ferriss, masterpiece, dystopian, architectural structural design, contrasting",
    "a stunning portrait of samurai woman by Evelyn De Morgan and Ross Tran, rossdraws, fresco",
    "stunning renaissance fresco portrait, masterpiece, artstation, by Sandro Botticelli, by Sofonisba Anguissola",
    "a portrait of kyrickyoung, oil on canvas, artstation, by J. C. Leyendecker and Edmund Blair Leighton and Charlie Bowater, octane render, soft lighting, contrasting",
    "stunning futuristic sci-fi woman character concept digital art by Leonardo da Vinci and WLOP, surrealism, character illustration, fresco cracked paint, highly detailed sci-fi illustration, soft render",
    "abandoned crumbling shopping mall overgrown by flowers and vines by Tyler Edlin and Jean Delville and John Aktinson Grimshaw and Hubert Robert, german romanticism style, oil on canvas, cinematic lighting, vibrant, hdr, concept art, rain reflections, juxtaposition",
    "the grand canyon by Tyler Edlin and Jean Delville and John Aktinson Grimshaw and Hubert Robert, german romanticism style, oil on canvas, cinematic lighting, vibrant, concept art, gothic, contrasting",
    "chicago magnificent mile overgrown by vines and flowers by Tyler Edlin and Jean Delville and John Aktinson Grimshaw and Hubert Robert, german romanticism style, oil on canvas, cinematic lighting, vibrant, concept art, gothic, contrasting, nightscape",
    "woman ponders the rocky mountains by Jordan Grimmer and RHADS and Gilbert William",
    "majestic frost covered Bison closeup by Jordan Grimmer and RHADS and Gilbert Williams and albert bierstadt, hdr, 4k, snow fog, octane, soft render",
    "Chicago by Jordan Grimmer and RHADS and Gilbert Williams",
    "the rocky mountains by Jordan Grimmer and RHADS",
    "the streets of an abandoned crumbling city overgrown by flowers and vines by Jean Delville and John Aktinson Grimshaw and Hubert Robert, german romanticism style, oil on canvas, cinematic lighting, vibrant, hdr, concept art",
    "atompunk wizard tower in a field of flowers landscape by John Harris and RHADS and Gilbert Williams, highly detailed matte painting, hdr, concept art",
    "astronaut standing in a scenic field of flowers at sunset, synthwave, octane, soft render, artstation",
  ];

  // prompts Provider
  let builtin_prompts;
  class PrompterExtraOrdinaire {
    constructor(keyword = "") {
      builtin_prompts = prompts_list.concat();
      if (keyword != "") this.filter(keyword);
    }

    reset() {
      builtin_prompts = prompts_list.concat();
    }

    // isolate a keyword
    filter(keyword = "portrait") {
      builtin_prompts = prompts_list.filter((s) => {
        return s.toLowerCase().lastIndexOf(keyword) != -1;
      });
    }

    // get a random entry
    random() {
      return builtin_prompts[~~(Math.random() * builtin_prompts.length)];
    }

    // randomize list
    randomize() {
      builtin_prompts.sort((a, b) => {
        return Math.random() > 0.5 ? -1 : 1;
      });
    }

    // get next entry
    next() {
      let p = builtin_prompts.shift();
      builtin_prompts.push(p);
      return p.trim();
    }
  }
  const Prompter = new PrompterExtraOrdinaire();

  var tweakpane = {exports: {}};

  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    })(commonjsGlobal, function (exports) {
      /***
       * A simple semantic versioning perser.
       */

      var Semver = /*#__PURE__*/function () {
        /**
         * @hidden
         */
        function Semver(text) {
          _classCallCheck(this, Semver);

          var _text$split = text.split('-'),
              _text$split2 = _slicedToArray(_text$split, 2),
              core = _text$split2[0],
              prerelease = _text$split2[1];

          var coreComps = core.split('.');
          this.major = parseInt(coreComps[0], 10);
          this.minor = parseInt(coreComps[1], 10);
          this.patch = parseInt(coreComps[2], 10);
          this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
        }

        _createClass(Semver, [{
          key: "toString",
          value: function toString() {
            var core = [this.major, this.minor, this.patch].join('.');
            return this.prerelease !== null ? [core, this.prerelease].join('-') : core;
          }
        }]);

        return Semver;
      }();

      var BladeApi = /*#__PURE__*/function () {
        function BladeApi(controller) {
          _classCallCheck(this, BladeApi);

          this.controller_ = controller;
        }

        _createClass(BladeApi, [{
          key: "element",
          get: function get() {
            return this.controller_.view.element;
          }
        }, {
          key: "disabled",
          get: function get() {
            return this.controller_.viewProps.get('disabled');
          },
          set: function set(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
          }
        }, {
          key: "hidden",
          get: function get() {
            return this.controller_.viewProps.get('hidden');
          },
          set: function set(hidden) {
            this.controller_.viewProps.set('hidden', hidden);
          }
        }, {
          key: "dispose",
          value: function dispose() {
            this.controller_.viewProps.set('disposed', true);
          }
        }]);

        return BladeApi;
      }();

      var TpEvent = /*#__PURE__*/_createClass(function TpEvent(target) {
        _classCallCheck(this, TpEvent);

        this.target = target;
      });

      var TpChangeEvent = /*#__PURE__*/function (_TpEvent) {
        _inherits(TpChangeEvent, _TpEvent);

        var _super = _createSuper(TpChangeEvent);

        function TpChangeEvent(target, value, presetKey, last) {
          var _this;

          _classCallCheck(this, TpChangeEvent);

          _this = _super.call(this, target);
          _this.value = value;
          _this.presetKey = presetKey;
          _this.last = last !== null && last !== void 0 ? last : true;
          return _this;
        }

        return _createClass(TpChangeEvent);
      }(TpEvent);

      var TpUpdateEvent = /*#__PURE__*/function (_TpEvent2) {
        _inherits(TpUpdateEvent, _TpEvent2);

        var _super2 = _createSuper(TpUpdateEvent);

        function TpUpdateEvent(target, value, presetKey) {
          var _this2;

          _classCallCheck(this, TpUpdateEvent);

          _this2 = _super2.call(this, target);
          _this2.value = value;
          _this2.presetKey = presetKey;
          return _this2;
        }

        return _createClass(TpUpdateEvent);
      }(TpEvent);

      var TpFoldEvent = /*#__PURE__*/function (_TpEvent3) {
        _inherits(TpFoldEvent, _TpEvent3);

        var _super3 = _createSuper(TpFoldEvent);

        function TpFoldEvent(target, expanded) {
          var _this3;

          _classCallCheck(this, TpFoldEvent);

          _this3 = _super3.call(this, target);
          _this3.expanded = expanded;
          return _this3;
        }

        return _createClass(TpFoldEvent);
      }(TpEvent);

      var TpTabSelectEvent = /*#__PURE__*/function (_TpEvent4) {
        _inherits(TpTabSelectEvent, _TpEvent4);

        var _super4 = _createSuper(TpTabSelectEvent);

        function TpTabSelectEvent(target, index) {
          var _this4;

          _classCallCheck(this, TpTabSelectEvent);

          _this4 = _super4.call(this, target);
          _this4.index = index;
          return _this4;
        }

        return _createClass(TpTabSelectEvent);
      }(TpEvent);

      function forceCast(v) {
        return v;
      }

      function isEmpty(value) {
        return value === null || value === undefined;
      }

      function deepEqualsArray(a1, a2) {
        if (a1.length !== a2.length) {
          return false;
        }

        for (var i = 0; i < a1.length; i++) {
          if (a1[i] !== a2[i]) {
            return false;
          }
        }

        return true;
      }

      var CREATE_MESSAGE_MAP = {
        alreadydisposed: function alreadydisposed() {
          return 'View has been already disposed';
        },
        invalidparams: function invalidparams(context) {
          return "Invalid parameters for '".concat(context.name, "'");
        },
        nomatchingcontroller: function nomatchingcontroller(context) {
          return "No matching controller for '".concat(context.key, "'");
        },
        nomatchingview: function nomatchingview(context) {
          return "No matching view for '".concat(JSON.stringify(context.params), "'");
        },
        notbindable: function notbindable() {
          return "Value is not bindable";
        },
        propertynotfound: function propertynotfound(context) {
          return "Property '".concat(context.name, "' not found");
        },
        shouldneverhappen: function shouldneverhappen() {
          return 'This error should never happen';
        }
      };

      var TpError = /*#__PURE__*/function () {
        function TpError(config) {
          _classCallCheck(this, TpError);

          var _a;

          this.message = (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== void 0 ? _a : 'Unexpected error';
          this.name = this.constructor.name;
          this.stack = new Error(this.message).stack;
          this.type = config.type;
        }

        _createClass(TpError, null, [{
          key: "alreadyDisposed",
          value: function alreadyDisposed() {
            return new TpError({
              type: 'alreadydisposed'
            });
          }
        }, {
          key: "notBindable",
          value: function notBindable() {
            return new TpError({
              type: 'notbindable'
            });
          }
        }, {
          key: "propertyNotFound",
          value: function propertyNotFound(name) {
            return new TpError({
              type: 'propertynotfound',
              context: {
                name: name
              }
            });
          }
        }, {
          key: "shouldNeverHappen",
          value: function shouldNeverHappen() {
            return new TpError({
              type: 'shouldneverhappen'
            });
          }
        }]);

        return TpError;
      }();

      var BindingTarget = /*#__PURE__*/function () {
        function BindingTarget(obj, key, opt_id) {
          _classCallCheck(this, BindingTarget);

          this.obj_ = obj;
          this.key_ = key;
          this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
        }

        _createClass(BindingTarget, [{
          key: "key",
          get: function get() {
            return this.key_;
          }
        }, {
          key: "presetKey",
          get: function get() {
            return this.presetKey_;
          }
        }, {
          key: "read",
          value: function read() {
            return this.obj_[this.key_];
          }
        }, {
          key: "write",
          value: function write(value) {
            this.obj_[this.key_] = value;
          }
        }, {
          key: "writeProperty",
          value: function writeProperty(name, value) {
            var valueObj = this.read();

            if (!BindingTarget.isBindable(valueObj)) {
              throw TpError.notBindable();
            }

            if (!(name in valueObj)) {
              throw TpError.propertyNotFound(name);
            }

            valueObj[name] = value;
          }
        }], [{
          key: "isBindable",
          value: function isBindable(obj) {
            if (obj === null) {
              return false;
            }

            if (_typeof$1(obj) !== 'object') {
              return false;
            }

            return true;
          }
        }]);

        return BindingTarget;
      }();

      var ButtonApi = /*#__PURE__*/function (_BladeApi) {
        _inherits(ButtonApi, _BladeApi);

        var _super5 = _createSuper(ButtonApi);

        function ButtonApi() {
          _classCallCheck(this, ButtonApi);

          return _super5.apply(this, arguments);
        }

        _createClass(ButtonApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "title",
          get: function get() {
            var _a;

            return (_a = this.controller_.valueController.props.get('title')) !== null && _a !== void 0 ? _a : '';
          },
          set: function set(title) {
            this.controller_.valueController.props.set('title', title);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var _this5 = this;

            var bh = handler.bind(this);
            var emitter = this.controller_.valueController.emitter;
            emitter.on(eventName, function () {
              bh(new TpEvent(_this5));
            });
            return this;
          }
        }]);

        return ButtonApi;
      }(BladeApi);

      var Emitter = /*#__PURE__*/function () {
        function Emitter() {
          _classCallCheck(this, Emitter);

          this.observers_ = {};
        }

        _createClass(Emitter, [{
          key: "on",
          value: function on(eventName, handler) {
            var observers = this.observers_[eventName];

            if (!observers) {
              observers = this.observers_[eventName] = [];
            }

            observers.push({
              handler: handler
            });
            return this;
          }
        }, {
          key: "off",
          value: function off(eventName, handler) {
            var observers = this.observers_[eventName];

            if (observers) {
              this.observers_[eventName] = observers.filter(function (observer) {
                return observer.handler !== handler;
              });
            }

            return this;
          }
        }, {
          key: "emit",
          value: function emit(eventName, event) {
            var observers = this.observers_[eventName];

            if (!observers) {
              return;
            }

            observers.forEach(function (observer) {
              observer.handler(event);
            });
          }
        }]);

        return Emitter;
      }();

      var PREFIX = 'tp';

      function ClassName(viewName) {
        var fn = function fn(opt_elementName, opt_modifier) {
          return [PREFIX, '-', viewName, 'v', opt_elementName ? "_".concat(opt_elementName) : '', opt_modifier ? "-".concat(opt_modifier) : ''].join('');
        };

        return fn;
      }

      function compose(h1, h2) {
        return function (input) {
          return h2(h1(input));
        };
      }

      function extractValue(ev) {
        return ev.rawValue;
      }

      function bindValue(value, applyValue) {
        value.emitter.on('change', compose(extractValue, applyValue));
        applyValue(value.rawValue);
      }

      function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
      }

      function applyClass(elem, className, active) {
        if (active) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      }

      function valueToClassName(elem, className) {
        return function (value) {
          applyClass(elem, className, value);
        };
      }

      function bindValueToTextContent(value, elem) {
        bindValue(value, function (text) {
          elem.textContent = text !== null && text !== void 0 ? text : '';
        });
      }

      var className$q = ClassName('btn');

      var ButtonView = /*#__PURE__*/_createClass(function ButtonView(doc, config) {
        _classCallCheck(this, ButtonView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$q());
        config.viewProps.bindClassModifiers(this.element);
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(className$q('b'));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var titleElem = doc.createElement('div');
        titleElem.classList.add(className$q('t'));
        bindValueToTextContent(config.props.value('title'), titleElem);
        this.buttonElement.appendChild(titleElem);
      });

      var ButtonController = /*#__PURE__*/function () {
        function ButtonController(doc, config) {
          _classCallCheck(this, ButtonController);

          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new ButtonView(doc, {
            props: this.props,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener('click', this.onClick_);
        }

        _createClass(ButtonController, [{
          key: "onClick_",
          value: function onClick_() {
            this.emitter.emit('click', {
              sender: this
            });
          }
        }]);

        return ButtonController;
      }();

      var BoundValue = /*#__PURE__*/function () {
        function BoundValue(initialValue, config) {
          _classCallCheck(this, BoundValue);

          var _a;

          this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
          this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : function (v1, v2) {
            return v1 === v2;
          };
          this.emitter = new Emitter();
          this.rawValue_ = initialValue;
        }

        _createClass(BoundValue, [{
          key: "constraint",
          get: function get() {
            return this.constraint_;
          }
        }, {
          key: "rawValue",
          get: function get() {
            return this.rawValue_;
          },
          set: function set(rawValue) {
            this.setRawValue(rawValue, {
              forceEmit: false,
              last: true
            });
          }
        }, {
          key: "setRawValue",
          value: function setRawValue(rawValue, options) {
            var opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };
            var constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
            var changed = !this.equals_(this.rawValue_, constrainedValue);

            if (!changed && !opts.forceEmit) {
              return;
            }

            this.emitter.emit('beforechange', {
              sender: this
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit('change', {
              options: opts,
              rawValue: constrainedValue,
              sender: this
            });
          }
        }]);

        return BoundValue;
      }();

      var PrimitiveValue = /*#__PURE__*/function () {
        function PrimitiveValue(initialValue) {
          _classCallCheck(this, PrimitiveValue);

          this.emitter = new Emitter();
          this.value_ = initialValue;
        }

        _createClass(PrimitiveValue, [{
          key: "rawValue",
          get: function get() {
            return this.value_;
          },
          set: function set(value) {
            this.setRawValue(value, {
              forceEmit: false,
              last: true
            });
          }
        }, {
          key: "setRawValue",
          value: function setRawValue(value, options) {
            var opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };

            if (this.value_ === value && !opts.forceEmit) {
              return;
            }

            this.emitter.emit('beforechange', {
              sender: this
            });
            this.value_ = value;
            this.emitter.emit('change', {
              options: opts,
              rawValue: this.value_,
              sender: this
            });
          }
        }]);

        return PrimitiveValue;
      }();

      function createValue(initialValue, config) {
        var constraint = config === null || config === void 0 ? void 0 : config.constraint;
        var equals = config === null || config === void 0 ? void 0 : config.equals;

        if (!constraint && !equals) {
          return new PrimitiveValue(initialValue);
        }

        return new BoundValue(initialValue, config);
      }

      var ValueMap = /*#__PURE__*/function () {
        function ValueMap(valueMap) {
          var _this6 = this;

          _classCallCheck(this, ValueMap);

          this.emitter = new Emitter();
          this.valMap_ = valueMap;

          var _loop = function _loop(key) {
            var v = _this6.valMap_[key];
            v.emitter.on('change', function () {
              _this6.emitter.emit('change', {
                key: key,
                sender: _this6
              });
            });
          };

          for (var key in this.valMap_) {
            _loop(key);
          }
        }

        _createClass(ValueMap, [{
          key: "get",
          value: function get(key) {
            return this.valMap_[key].rawValue;
          }
        }, {
          key: "set",
          value: function set(key, value) {
            this.valMap_[key].rawValue = value;
          }
        }, {
          key: "value",
          value: function value(key) {
            return this.valMap_[key];
          }
        }], [{
          key: "createCore",
          value: function createCore(initialValue) {
            var keys = Object.keys(initialValue);
            return keys.reduce(function (o, key) {
              return Object.assign(o, _defineProperty({}, key, createValue(initialValue[key])));
            }, {});
          }
        }, {
          key: "fromObject",
          value: function fromObject(initialValue) {
            var core = this.createCore(initialValue);
            return new ValueMap(core);
          }
        }]);

        return ValueMap;
      }();

      function parseObject(value, keyToParserMap) {
        var keys = Object.keys(keyToParserMap);
        var result = keys.reduce(function (tmp, key) {
          if (tmp === undefined) {
            return undefined;
          }

          var parser = keyToParserMap[key];
          var result = parser(value[key]);
          return result.succeeded ? Object.assign(Object.assign({}, tmp), _defineProperty({}, key, result.value)) : undefined;
        }, {});
        return forceCast(result);
      }

      function parseArray(value, parseItem) {
        return value.reduce(function (tmp, item) {
          if (tmp === undefined) {
            return undefined;
          }

          var result = parseItem(item);

          if (!result.succeeded || result.value === undefined) {
            return undefined;
          }

          return [].concat(_toConsumableArray(tmp), [result.value]);
        }, []);
      }

      function isObject(value) {
        if (value === null) {
          return false;
        }

        return _typeof$1(value) === 'object';
      }

      function createParamsParserBuilder(parse) {
        return function (optional) {
          return function (v) {
            if (!optional && v === undefined) {
              return {
                succeeded: false,
                value: undefined
              };
            }

            if (optional && v === undefined) {
              return {
                succeeded: true,
                value: undefined
              };
            }

            var result = parse(v);
            return result !== undefined ? {
              succeeded: true,
              value: result
            } : {
              succeeded: false,
              value: undefined
            };
          };
        };
      }

      function createParamsParserBuilders(optional) {
        return {
          custom: function custom(parse) {
            return createParamsParserBuilder(parse)(optional);
          },
          "boolean": createParamsParserBuilder(function (v) {
            return typeof v === 'boolean' ? v : undefined;
          })(optional),
          number: createParamsParserBuilder(function (v) {
            return typeof v === 'number' ? v : undefined;
          })(optional),
          string: createParamsParserBuilder(function (v) {
            return typeof v === 'string' ? v : undefined;
          })(optional),
          "function": createParamsParserBuilder(function (v) {
            return typeof v === 'function' ? v : undefined;
          })(optional),
          constant: function constant(value) {
            return createParamsParserBuilder(function (v) {
              return v === value ? value : undefined;
            })(optional);
          },
          raw: createParamsParserBuilder(function (v) {
            return v;
          })(optional),
          object: function object(keyToParserMap) {
            return createParamsParserBuilder(function (v) {
              if (!isObject(v)) {
                return undefined;
              }

              return parseObject(v, keyToParserMap);
            })(optional);
          },
          array: function array(itemParser) {
            return createParamsParserBuilder(function (v) {
              if (!Array.isArray(v)) {
                return undefined;
              }

              return parseArray(v, itemParser);
            })(optional);
          }
        };
      }

      var ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };

      function parseParams(value, keyToParserMap) {
        var result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
      }

      function disposeElement(elem) {
        if (elem && elem.parentElement) {
          elem.parentElement.removeChild(elem);
        }

        return null;
      }

      function getAllBladePositions() {
        return ['veryfirst', 'first', 'last', 'verylast'];
      }

      var className$p = ClassName('');
      var POS_TO_CLASS_NAME_MAP = {
        veryfirst: 'vfst',
        first: 'fst',
        last: 'lst',
        verylast: 'vlst'
      };

      var BladeController = /*#__PURE__*/function () {
        function BladeController(config) {
          var _this7 = this;

          _classCallCheck(this, BladeController);

          this.parent_ = null;
          this.blade = config.blade;
          this.view = config.view;
          this.viewProps = config.viewProps;
          var elem = this.view.element;
          this.blade.value('positions').emitter.on('change', function () {
            getAllBladePositions().forEach(function (pos) {
              elem.classList.remove(className$p(undefined, POS_TO_CLASS_NAME_MAP[pos]));
            });

            _this7.blade.get('positions').forEach(function (pos) {
              elem.classList.add(className$p(undefined, POS_TO_CLASS_NAME_MAP[pos]));
            });
          });
          this.viewProps.handleDispose(function () {
            disposeElement(elem);
          });
        }

        _createClass(BladeController, [{
          key: "parent",
          get: function get() {
            return this.parent_;
          }
        }]);

        return BladeController;
      }();

      var SVG_NS = 'http://www.w3.org/2000/svg';

      function forceReflow(element) {
        element.offsetHeight;
      }

      function disableTransitionTemporarily(element, callback) {
        var t = element.style.transition;
        element.style.transition = 'none';
        callback();
        element.style.transition = t;
      }

      function supportsTouch(doc) {
        return doc.ontouchstart !== undefined;
      }

      function getGlobalObject() {
        return new Function('return this')();
      }

      function getWindowDocument() {
        var globalObj = forceCast(getGlobalObject());
        return globalObj.document;
      }

      function getCanvasContext(canvasElement) {
        var win = canvasElement.ownerDocument.defaultView;

        if (!win) {
          return null;
        }

        var isBrowser = ('document' in win);
        return isBrowser ? canvasElement.getContext('2d') : null;
      }

      var ICON_ID_TO_INNER_HTML_MAP = {
        check: '<path d="M2 8l4 4l8 -8"/>',
        dropdown: '<path d="M5 7h6l-3 3 z"/>',
        p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
      };

      function createSvgIconElement(document, iconId) {
        var elem = document.createElementNS(SVG_NS, 'svg');
        elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
        return elem;
      }

      function insertElementAt(parentElement, element, index) {
        parentElement.insertBefore(element, parentElement.children[index]);
      }

      function removeElement(element) {
        if (element.parentElement) {
          element.parentElement.removeChild(element);
        }
      }

      function removeChildElements(element) {
        while (element.children.length > 0) {
          element.removeChild(element.children[0]);
        }
      }

      function removeChildNodes(element) {
        while (element.childNodes.length > 0) {
          element.removeChild(element.childNodes[0]);
        }
      }

      function findNextTarget(ev) {
        if (ev.relatedTarget) {
          return forceCast(ev.relatedTarget);
        }

        if ('explicitOriginalTarget' in ev) {
          return ev.explicitOriginalTarget;
        }

        return null;
      }

      var className$o = ClassName('lbl');

      function createLabelNode(doc, label) {
        var frag = doc.createDocumentFragment();
        var lineNodes = label.split('\n').map(function (line) {
          return doc.createTextNode(line);
        });
        lineNodes.forEach(function (lineNode, index) {
          if (index > 0) {
            frag.appendChild(doc.createElement('br'));
          }

          frag.appendChild(lineNode);
        });
        return frag;
      }

      var LabelView = /*#__PURE__*/_createClass(function LabelView(doc, config) {
        var _this8 = this;

        _classCallCheck(this, LabelView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$o());
        config.viewProps.bindClassModifiers(this.element);
        var labelElem = doc.createElement('div');
        labelElem.classList.add(className$o('l'));
        bindValueMap(config.props, 'label', function (value) {
          if (isEmpty(value)) {
            _this8.element.classList.add(className$o(undefined, 'nol'));
          } else {
            _this8.element.classList.remove(className$o(undefined, 'nol'));

            removeChildNodes(labelElem);
            labelElem.appendChild(createLabelNode(doc, value));
          }
        });
        this.element.appendChild(labelElem);
        this.labelElement = labelElem;
        var valueElem = doc.createElement('div');
        valueElem.classList.add(className$o('v'));
        this.element.appendChild(valueElem);
        this.valueElement = valueElem;
      });

      var LabelController = /*#__PURE__*/function (_BladeController) {
        _inherits(LabelController, _BladeController);

        var _super6 = _createSuper(LabelController);

        function LabelController(doc, config) {
          var _this9;

          _classCallCheck(this, LabelController);

          var viewProps = config.valueController.viewProps;
          _this9 = _super6.call(this, Object.assign(Object.assign({}, config), {
            view: new LabelView(doc, {
              props: config.props,
              viewProps: viewProps
            }),
            viewProps: viewProps
          }));
          _this9.props = config.props;
          _this9.valueController = config.valueController;

          _this9.view.valueElement.appendChild(_this9.valueController.view.element);

          return _this9;
        }

        return _createClass(LabelController);
      }(BladeController);

      var ButtonBladePlugin = {
        id: 'button',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant('button'),
            label: p.optional.string
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new ButtonController(args.document, {
              props: ValueMap.fromObject({
                title: args.params.title
              }),
              viewProps: args.viewProps
            })
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }

          if (!(args.controller.valueController instanceof ButtonController)) {
            return null;
          }

          return new ButtonApi(args.controller);
        }
      };

      var ValueBladeController = /*#__PURE__*/function (_BladeController2) {
        _inherits(ValueBladeController, _BladeController2);

        var _super7 = _createSuper(ValueBladeController);

        function ValueBladeController(config) {
          var _this10;

          _classCallCheck(this, ValueBladeController);

          _this10 = _super7.call(this, config);
          _this10.value = config.value;
          return _this10;
        }

        return _createClass(ValueBladeController);
      }(BladeController);

      function createBlade() {
        return new ValueMap({
          positions: createValue([], {
            equals: deepEqualsArray
          })
        });
      }

      var Foldable = /*#__PURE__*/function (_ValueMap) {
        _inherits(Foldable, _ValueMap);

        var _super8 = _createSuper(Foldable);

        function Foldable(valueMap) {
          _classCallCheck(this, Foldable);

          return _super8.call(this, valueMap);
        }

        _createClass(Foldable, [{
          key: "styleExpanded",
          get: function get() {
            var _a;

            return (_a = this.get('temporaryExpanded')) !== null && _a !== void 0 ? _a : this.get('expanded');
          }
        }, {
          key: "styleHeight",
          get: function get() {
            if (!this.styleExpanded) {
              return '0';
            }

            var exHeight = this.get('expandedHeight');

            if (this.get('shouldFixHeight') && !isEmpty(exHeight)) {
              return "".concat(exHeight, "px");
            }

            return 'auto';
          }
        }, {
          key: "bindExpandedClass",
          value: function bindExpandedClass(elem, expandedClassName) {
            var _this11 = this;

            var onExpand = function onExpand() {
              var expanded = _this11.styleExpanded;

              if (expanded) {
                elem.classList.add(expandedClassName);
              } else {
                elem.classList.remove(expandedClassName);
              }
            };

            bindValueMap(this, 'expanded', onExpand);
            bindValueMap(this, 'temporaryExpanded', onExpand);
          }
        }, {
          key: "cleanUpTransition",
          value: function cleanUpTransition() {
            this.set('shouldFixHeight', false);
            this.set('expandedHeight', null);
            this.set('completed', true);
          }
        }], [{
          key: "create",
          value: function create(expanded) {
            var coreObj = {
              completed: true,
              expanded: expanded,
              expandedHeight: null,
              shouldFixHeight: false,
              temporaryExpanded: null
            };
            var core = ValueMap.createCore(coreObj);
            return new Foldable(core);
          }
        }]);

        return Foldable;
      }(ValueMap);

      function computeExpandedFolderHeight(folder, containerElement) {
        var height = 0;
        disableTransitionTemporarily(containerElement, function () {
          folder.set('expandedHeight', null);
          folder.set('temporaryExpanded', true);
          forceReflow(containerElement);
          height = containerElement.clientHeight;
          folder.set('temporaryExpanded', null);
          forceReflow(containerElement);
        });
        return height;
      }

      function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
      }

      function bindFoldable(foldable, elem) {
        foldable.value('expanded').emitter.on('beforechange', function () {
          foldable.set('completed', false);

          if (isEmpty(foldable.get('expandedHeight'))) {
            foldable.set('expandedHeight', computeExpandedFolderHeight(foldable, elem));
          }

          foldable.set('shouldFixHeight', true);
          forceReflow(elem);
        });
        foldable.emitter.on('change', function () {
          applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener('transitionend', function (ev) {
          if (ev.propertyName !== 'height') {
            return;
          }

          foldable.cleanUpTransition();
        });
      }

      var RackLikeApi = /*#__PURE__*/function (_BladeApi2) {
        _inherits(RackLikeApi, _BladeApi2);

        var _super9 = _createSuper(RackLikeApi);

        function RackLikeApi(controller, rackApi) {
          var _this12;

          _classCallCheck(this, RackLikeApi);

          _this12 = _super9.call(this, controller);
          _this12.rackApi_ = rackApi;
          return _this12;
        }

        return _createClass(RackLikeApi);
      }(BladeApi);

      function addButtonAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), {
          view: 'button'
        }));
      }

      function addFolderAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), {
          view: 'folder'
        }));
      }

      function addSeparatorAsBlade(api, opt_params) {
        var params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
        return api.addBlade(Object.assign(Object.assign({}, params), {
          view: 'separator'
        }));
      }

      function addTabAsBlade(api, params) {
        return api.addBlade(Object.assign(Object.assign({}, params), {
          view: 'tab'
        }));
      }

      var NestedOrderedSet = /*#__PURE__*/function () {
        function NestedOrderedSet(extract) {
          _classCallCheck(this, NestedOrderedSet);

          this.emitter = new Emitter();
          this.items_ = [];
          this.cache_ = new Set();
          this.onSubListAdd_ = this.onSubListAdd_.bind(this);
          this.onSubListRemove_ = this.onSubListRemove_.bind(this);
          this.extract_ = extract;
        }

        _createClass(NestedOrderedSet, [{
          key: "items",
          get: function get() {
            return this.items_;
          }
        }, {
          key: "allItems",
          value: function allItems() {
            return Array.from(this.cache_);
          }
        }, {
          key: "find",
          value: function find(callback) {
            var _iterator = _createForOfIteratorHelper(this.allItems()),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var item = _step.value;

                if (callback(item)) {
                  return item;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            return null;
          }
        }, {
          key: "includes",
          value: function includes(item) {
            return this.cache_.has(item);
          }
        }, {
          key: "add",
          value: function add(item, opt_index) {
            var _this13 = this;

            if (this.includes(item)) {
              throw TpError.shouldNeverHappen();
            }

            var index = opt_index !== undefined ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            this.cache_.add(item);
            var subList = this.extract_(item);

            if (subList) {
              subList.emitter.on('add', this.onSubListAdd_);
              subList.emitter.on('remove', this.onSubListRemove_);
              subList.allItems().forEach(function (item) {
                _this13.cache_.add(item);
              });
            }

            this.emitter.emit('add', {
              index: index,
              item: item,
              root: this,
              target: this
            });
          }
        }, {
          key: "remove",
          value: function remove(item) {
            var index = this.items_.indexOf(item);

            if (index < 0) {
              return;
            }

            this.items_.splice(index, 1);
            this.cache_["delete"](item);
            var subList = this.extract_(item);

            if (subList) {
              subList.emitter.off('add', this.onSubListAdd_);
              subList.emitter.off('remove', this.onSubListRemove_);
            }

            this.emitter.emit('remove', {
              index: index,
              item: item,
              root: this,
              target: this
            });
          }
        }, {
          key: "onSubListAdd_",
          value: function onSubListAdd_(ev) {
            this.cache_.add(ev.item);
            this.emitter.emit('add', {
              index: ev.index,
              item: ev.item,
              root: this,
              target: ev.target
            });
          }
        }, {
          key: "onSubListRemove_",
          value: function onSubListRemove_(ev) {
            this.cache_["delete"](ev.item);
            this.emitter.emit('remove', {
              index: ev.index,
              item: ev.item,
              root: this,
              target: ev.target
            });
          }
        }]);

        return NestedOrderedSet;
      }();

      var InputBindingApi = /*#__PURE__*/function (_BladeApi3) {
        _inherits(InputBindingApi, _BladeApi3);

        var _super10 = _createSuper(InputBindingApi);

        function InputBindingApi(controller) {
          var _this14;

          _classCallCheck(this, InputBindingApi);

          _this14 = _super10.call(this, controller);
          _this14.onBindingChange_ = _this14.onBindingChange_.bind(_assertThisInitialized(_this14));
          _this14.emitter_ = new Emitter();

          _this14.controller_.binding.emitter.on('change', _this14.onBindingChange_);

          return _this14;
        }

        _createClass(InputBindingApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.controller_.binding.read();
          }
        }, {
          key: "onBindingChange_",
          value: function onBindingChange_(ev) {
            var value = ev.sender.target.read();
            this.emitter_.emit('change', {
              event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
            });
          }
        }]);

        return InputBindingApi;
      }(BladeApi);

      var InputBindingController = /*#__PURE__*/function (_LabelController) {
        _inherits(InputBindingController, _LabelController);

        var _super11 = _createSuper(InputBindingController);

        function InputBindingController(doc, config) {
          var _this15;

          _classCallCheck(this, InputBindingController);

          _this15 = _super11.call(this, doc, config);
          _this15.binding = config.binding;
          return _this15;
        }

        return _createClass(InputBindingController);
      }(LabelController);

      var MonitorBindingApi = /*#__PURE__*/function (_BladeApi4) {
        _inherits(MonitorBindingApi, _BladeApi4);

        var _super12 = _createSuper(MonitorBindingApi);

        function MonitorBindingApi(controller) {
          var _this16;

          _classCallCheck(this, MonitorBindingApi);

          _this16 = _super12.call(this, controller);
          _this16.onBindingUpdate_ = _this16.onBindingUpdate_.bind(_assertThisInitialized(_this16));
          _this16.emitter_ = new Emitter();

          _this16.controller_.binding.emitter.on('update', _this16.onBindingUpdate_);

          return _this16;
        }

        _createClass(MonitorBindingApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.controller_.binding.read();
          }
        }, {
          key: "onBindingUpdate_",
          value: function onBindingUpdate_(ev) {
            var value = ev.sender.target.read();
            this.emitter_.emit('update', {
              event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
            });
          }
        }]);

        return MonitorBindingApi;
      }(BladeApi);

      var MonitorBindingController = /*#__PURE__*/function (_LabelController2) {
        _inherits(MonitorBindingController, _LabelController2);

        var _super13 = _createSuper(MonitorBindingController);

        function MonitorBindingController(doc, config) {
          var _this17;

          _classCallCheck(this, MonitorBindingController);

          _this17 = _super13.call(this, doc, config);
          _this17.binding = config.binding;

          _this17.viewProps.bindDisabled(_this17.binding.ticker);

          _this17.viewProps.handleDispose(function () {
            _this17.binding.dispose();
          });

          return _this17;
        }

        return _createClass(MonitorBindingController);
      }(LabelController);

      function findSubBladeApiSet(api) {
        if (api instanceof RackApi) {
          return api['apiSet_'];
        }

        if (api instanceof RackLikeApi) {
          return api['rackApi_']['apiSet_'];
        }

        return null;
      }

      function getApiByController(apiSet, controller) {
        var api = apiSet.find(function (api) {
          return api.controller_ === controller;
        });

        if (!api) {
          throw TpError.shouldNeverHappen();
        }

        return api;
      }

      function createBindingTarget(obj, key, opt_id) {
        if (!BindingTarget.isBindable(obj)) {
          throw TpError.notBindable();
        }

        return new BindingTarget(obj, key, opt_id);
      }

      var RackApi = /*#__PURE__*/function (_BladeApi5) {
        _inherits(RackApi, _BladeApi5);

        var _super14 = _createSuper(RackApi);

        function RackApi(controller, pool) {
          var _this18;

          _classCallCheck(this, RackApi);

          _this18 = _super14.call(this, controller);
          _this18.onRackAdd_ = _this18.onRackAdd_.bind(_assertThisInitialized(_this18));
          _this18.onRackRemove_ = _this18.onRackRemove_.bind(_assertThisInitialized(_this18));
          _this18.onRackInputChange_ = _this18.onRackInputChange_.bind(_assertThisInitialized(_this18));
          _this18.onRackMonitorUpdate_ = _this18.onRackMonitorUpdate_.bind(_assertThisInitialized(_this18));
          _this18.emitter_ = new Emitter();
          _this18.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
          _this18.pool_ = pool;
          var rack = _this18.controller_.rack;
          rack.emitter.on('add', _this18.onRackAdd_);
          rack.emitter.on('remove', _this18.onRackRemove_);
          rack.emitter.on('inputchange', _this18.onRackInputChange_);
          rack.emitter.on('monitorupdate', _this18.onRackMonitorUpdate_);
          rack.children.forEach(function (bc) {
            _this18.setUpApi_(bc);
          });
          return _this18;
        }

        _createClass(RackApi, [{
          key: "children",
          get: function get() {
            var _this19 = this;

            return this.controller_.rack.children.map(function (bc) {
              return getApiByController(_this19.apiSet_, bc);
            });
          }
        }, {
          key: "addInput",
          value: function addInput(object, key, opt_params) {
            var params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            var doc = this.controller_.view.element.ownerDocument;
            var bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
            var api = new InputBindingApi(bc);
            return this.add(api, params.index);
          }
        }, {
          key: "addMonitor",
          value: function addMonitor(object, key, opt_params) {
            var params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
            var doc = this.controller_.view.element.ownerDocument;
            var bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
            var api = new MonitorBindingApi(bc);
            return forceCast(this.add(api, params.index));
          }
        }, {
          key: "addFolder",
          value: function addFolder(params) {
            return addFolderAsBlade(this, params);
          }
        }, {
          key: "addButton",
          value: function addButton(params) {
            return addButtonAsBlade(this, params);
          }
        }, {
          key: "addSeparator",
          value: function addSeparator(opt_params) {
            return addSeparatorAsBlade(this, opt_params);
          }
        }, {
          key: "addTab",
          value: function addTab(params) {
            return addTabAsBlade(this, params);
          }
        }, {
          key: "add",
          value: function add(api, opt_index) {
            this.controller_.rack.add(api.controller_, opt_index);
            var gapi = this.apiSet_.find(function (a) {
              return a.controller_ === api.controller_;
            });

            if (gapi) {
              this.apiSet_.remove(gapi);
            }

            this.apiSet_.add(api);
            return api;
          }
        }, {
          key: "remove",
          value: function remove(api) {
            this.controller_.rack.remove(api.controller_);
          }
        }, {
          key: "addBlade",
          value: function addBlade(params) {
            var doc = this.controller_.view.element.ownerDocument;
            var bc = this.pool_.createBlade(doc, params);
            var api = this.pool_.createBladeApi(bc);
            return this.add(api, params.index);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }, {
          key: "setUpApi_",
          value: function setUpApi_(bc) {
            var api = this.apiSet_.find(function (api) {
              return api.controller_ === bc;
            });

            if (!api) {
              this.apiSet_.add(this.pool_.createBladeApi(bc));
            }
          }
        }, {
          key: "onRackAdd_",
          value: function onRackAdd_(ev) {
            this.setUpApi_(ev.bladeController);
          }
        }, {
          key: "onRackRemove_",
          value: function onRackRemove_(ev) {
            if (ev.isRoot) {
              var api = getApiByController(this.apiSet_, ev.bladeController);
              this.apiSet_.remove(api);
            }
          }
        }, {
          key: "onRackInputChange_",
          value: function onRackInputChange_(ev) {
            var bc = ev.bladeController;

            if (bc instanceof InputBindingController) {
              var api = getApiByController(this.apiSet_, bc);
              var binding = bc.binding;
              this.emitter_.emit('change', {
                event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
              });
            } else if (bc instanceof ValueBladeController) {
              var _api = getApiByController(this.apiSet_, bc);

              this.emitter_.emit('change', {
                event: new TpChangeEvent(_api, bc.value.rawValue, undefined, ev.options.last)
              });
            }
          }
        }, {
          key: "onRackMonitorUpdate_",
          value: function onRackMonitorUpdate_(ev) {
            if (!(ev.bladeController instanceof MonitorBindingController)) {
              throw TpError.shouldNeverHappen();
            }

            var api = getApiByController(this.apiSet_, ev.bladeController);
            var binding = ev.bladeController.binding;
            this.emitter_.emit('update', {
              event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
            });
          }
        }]);

        return RackApi;
      }(BladeApi);

      var FolderApi = /*#__PURE__*/function (_RackLikeApi) {
        _inherits(FolderApi, _RackLikeApi);

        var _super15 = _createSuper(FolderApi);

        function FolderApi(controller, pool) {
          var _this20;

          _classCallCheck(this, FolderApi);

          _this20 = _super15.call(this, controller, new RackApi(controller.rackController, pool));
          _this20.emitter_ = new Emitter();

          _this20.controller_.foldable.value('expanded').emitter.on('change', function (ev) {
            _this20.emitter_.emit('fold', {
              event: new TpFoldEvent(_assertThisInitialized(_this20), ev.sender.rawValue)
            });
          });

          _this20.rackApi_.on('change', function (ev) {
            _this20.emitter_.emit('change', {
              event: ev
            });
          });

          _this20.rackApi_.on('update', function (ev) {
            _this20.emitter_.emit('update', {
              event: ev
            });
          });

          return _this20;
        }

        _createClass(FolderApi, [{
          key: "expanded",
          get: function get() {
            return this.controller_.foldable.get('expanded');
          },
          set: function set(expanded) {
            this.controller_.foldable.set('expanded', expanded);
          }
        }, {
          key: "title",
          get: function get() {
            return this.controller_.props.get('title');
          },
          set: function set(title) {
            this.controller_.props.set('title', title);
          }
        }, {
          key: "children",
          get: function get() {
            return this.rackApi_.children;
          }
        }, {
          key: "addInput",
          value: function addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
          }
        }, {
          key: "addMonitor",
          value: function addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
          }
        }, {
          key: "addFolder",
          value: function addFolder(params) {
            return this.rackApi_.addFolder(params);
          }
        }, {
          key: "addButton",
          value: function addButton(params) {
            return this.rackApi_.addButton(params);
          }
        }, {
          key: "addSeparator",
          value: function addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
          }
        }, {
          key: "addTab",
          value: function addTab(params) {
            return this.rackApi_.addTab(params);
          }
        }, {
          key: "add",
          value: function add(api, opt_index) {
            return this.rackApi_.add(api, opt_index);
          }
        }, {
          key: "remove",
          value: function remove(api) {
            this.rackApi_.remove(api);
          }
        }, {
          key: "addBlade",
          value: function addBlade(params) {
            return this.rackApi_.addBlade(params);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }]);

        return FolderApi;
      }(RackLikeApi);

      var RackLikeController = /*#__PURE__*/function (_BladeController3) {
        _inherits(RackLikeController, _BladeController3);

        var _super16 = _createSuper(RackLikeController);

        function RackLikeController(config) {
          var _this21;

          _classCallCheck(this, RackLikeController);

          _this21 = _super16.call(this, {
            blade: config.blade,
            view: config.view,
            viewProps: config.rackController.viewProps
          });
          _this21.rackController = config.rackController;
          return _this21;
        }

        return _createClass(RackLikeController);
      }(BladeController);

      var PlainView = /*#__PURE__*/_createClass(function PlainView(doc, config) {
        _classCallCheck(this, PlainView);

        var className = ClassName(config.viewName);
        this.element = doc.createElement('div');
        this.element.classList.add(className());
        config.viewProps.bindClassModifiers(this.element);
      });

      function findInputBindingController(bcs, b) {
        for (var i = 0; i < bcs.length; i++) {
          var bc = bcs[i];

          if (bc instanceof InputBindingController && bc.binding === b) {
            return bc;
          }
        }

        return null;
      }

      function findMonitorBindingController(bcs, b) {
        for (var i = 0; i < bcs.length; i++) {
          var bc = bcs[i];

          if (bc instanceof MonitorBindingController && bc.binding === b) {
            return bc;
          }
        }

        return null;
      }

      function findValueBladeController(bcs, v) {
        for (var i = 0; i < bcs.length; i++) {
          var bc = bcs[i];

          if (bc instanceof ValueBladeController && bc.value === v) {
            return bc;
          }
        }

        return null;
      }

      function findSubRack(bc) {
        if (bc instanceof RackController) {
          return bc.rack;
        }

        if (bc instanceof RackLikeController) {
          return bc.rackController.rack;
        }

        return null;
      }

      function findSubBladeControllerSet(bc) {
        var rack = findSubRack(bc);
        return rack ? rack['bcSet_'] : null;
      }

      var BladeRack = /*#__PURE__*/function () {
        function BladeRack(blade) {
          _classCallCheck(this, BladeRack);

          var _a;

          this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
          this.onSetAdd_ = this.onSetAdd_.bind(this);
          this.onSetRemove_ = this.onSetRemove_.bind(this);
          this.onChildDispose_ = this.onChildDispose_.bind(this);
          this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
          this.onChildInputChange_ = this.onChildInputChange_.bind(this);
          this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
          this.onChildValueChange_ = this.onChildValueChange_.bind(this);
          this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
          this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
          this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
          this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
          this.emitter = new Emitter();
          this.blade_ = blade !== null && blade !== void 0 ? blade : null;
          (_a = this.blade_) === null || _a === void 0 ? void 0 : _a.value('positions').emitter.on('change', this.onBladePositionsChange_);
          this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
          this.bcSet_.emitter.on('add', this.onSetAdd_);
          this.bcSet_.emitter.on('remove', this.onSetRemove_);
        }

        _createClass(BladeRack, [{
          key: "children",
          get: function get() {
            return this.bcSet_.items;
          }
        }, {
          key: "add",
          value: function add(bc, opt_index) {
            if (bc.parent) {
              bc.parent.remove(bc);
            }

            bc['parent_'] = this;
            this.bcSet_.add(bc, opt_index);
          }
        }, {
          key: "remove",
          value: function remove(bc) {
            bc['parent_'] = null;
            this.bcSet_.remove(bc);
          }
        }, {
          key: "find",
          value: function find(controllerClass) {
            return forceCast(this.bcSet_.allItems().filter(function (bc) {
              return bc instanceof controllerClass;
            }));
          }
        }, {
          key: "onSetAdd_",
          value: function onSetAdd_(ev) {
            this.updatePositions_();
            var isRoot = ev.target === ev.root;
            this.emitter.emit('add', {
              bladeController: ev.item,
              index: ev.index,
              isRoot: isRoot,
              sender: this
            });

            if (!isRoot) {
              return;
            }

            var bc = ev.item;
            bc.viewProps.emitter.on('change', this.onChildViewPropsChange_);
            bc.blade.value('positions').emitter.on('change', this.onChildPositionsChange_);
            bc.viewProps.handleDispose(this.onChildDispose_);

            if (bc instanceof InputBindingController) {
              bc.binding.emitter.on('change', this.onChildInputChange_);
            } else if (bc instanceof MonitorBindingController) {
              bc.binding.emitter.on('update', this.onChildMonitorUpdate_);
            } else if (bc instanceof ValueBladeController) {
              bc.value.emitter.on('change', this.onChildValueChange_);
            } else {
              var rack = findSubRack(bc);

              if (rack) {
                var emitter = rack.emitter;
                emitter.on('layout', this.onDescendantLayout_);
                emitter.on('inputchange', this.onDescendantInputChange_);
                emitter.on('monitorupdate', this.onDescendantMonitorUpdate_);
              }
            }
          }
        }, {
          key: "onSetRemove_",
          value: function onSetRemove_(ev) {
            this.updatePositions_();
            var isRoot = ev.target === ev.root;
            this.emitter.emit('remove', {
              bladeController: ev.item,
              isRoot: isRoot,
              sender: this
            });

            if (!isRoot) {
              return;
            }

            var bc = ev.item;

            if (bc instanceof InputBindingController) {
              bc.binding.emitter.off('change', this.onChildInputChange_);
            } else if (bc instanceof MonitorBindingController) {
              bc.binding.emitter.off('update', this.onChildMonitorUpdate_);
            } else if (bc instanceof ValueBladeController) {
              bc.value.emitter.off('change', this.onChildValueChange_);
            } else {
              var rack = findSubRack(bc);

              if (rack) {
                var emitter = rack.emitter;
                emitter.off('layout', this.onDescendantLayout_);
                emitter.off('inputchange', this.onDescendantInputChange_);
                emitter.off('monitorupdate', this.onDescendantMonitorUpdate_);
              }
            }
          }
        }, {
          key: "updatePositions_",
          value: function updatePositions_() {
            var _this22 = this;

            var visibleItems = this.bcSet_.items.filter(function (bc) {
              return !bc.viewProps.get('hidden');
            });
            var firstVisibleItem = visibleItems[0];
            var lastVisibleItem = visibleItems[visibleItems.length - 1];
            this.bcSet_.items.forEach(function (bc) {
              var ps = [];

              if (bc === firstVisibleItem) {
                ps.push('first');

                if (!_this22.blade_ || _this22.blade_.get('positions').includes('veryfirst')) {
                  ps.push('veryfirst');
                }
              }

              if (bc === lastVisibleItem) {
                ps.push('last');

                if (!_this22.blade_ || _this22.blade_.get('positions').includes('verylast')) {
                  ps.push('verylast');
                }
              }

              bc.blade.set('positions', ps);
            });
          }
        }, {
          key: "onChildPositionsChange_",
          value: function onChildPositionsChange_() {
            this.updatePositions_();
            this.emitter.emit('layout', {
              sender: this
            });
          }
        }, {
          key: "onChildViewPropsChange_",
          value: function onChildViewPropsChange_(_ev) {
            this.updatePositions_();
            this.emitter.emit('layout', {
              sender: this
            });
          }
        }, {
          key: "onChildDispose_",
          value: function onChildDispose_() {
            var _this23 = this;

            var disposedUcs = this.bcSet_.items.filter(function (bc) {
              return bc.viewProps.get('disposed');
            });
            disposedUcs.forEach(function (bc) {
              _this23.bcSet_.remove(bc);
            });
          }
        }, {
          key: "onChildInputChange_",
          value: function onChildInputChange_(ev) {
            var bc = findInputBindingController(this.find(InputBindingController), ev.sender);

            if (!bc) {
              throw TpError.shouldNeverHappen();
            }

            this.emitter.emit('inputchange', {
              bladeController: bc,
              options: ev.options,
              sender: this
            });
          }
        }, {
          key: "onChildMonitorUpdate_",
          value: function onChildMonitorUpdate_(ev) {
            var bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);

            if (!bc) {
              throw TpError.shouldNeverHappen();
            }

            this.emitter.emit('monitorupdate', {
              bladeController: bc,
              sender: this
            });
          }
        }, {
          key: "onChildValueChange_",
          value: function onChildValueChange_(ev) {
            var bc = findValueBladeController(this.find(ValueBladeController), ev.sender);

            if (!bc) {
              throw TpError.shouldNeverHappen();
            }

            this.emitter.emit('inputchange', {
              bladeController: bc,
              options: ev.options,
              sender: this
            });
          }
        }, {
          key: "onDescendantLayout_",
          value: function onDescendantLayout_(_) {
            this.updatePositions_();
            this.emitter.emit('layout', {
              sender: this
            });
          }
        }, {
          key: "onDescendantInputChange_",
          value: function onDescendantInputChange_(ev) {
            this.emitter.emit('inputchange', {
              bladeController: ev.bladeController,
              options: ev.options,
              sender: this
            });
          }
        }, {
          key: "onDescendantMonitorUpdate_",
          value: function onDescendantMonitorUpdate_(ev) {
            this.emitter.emit('monitorupdate', {
              bladeController: ev.bladeController,
              sender: this
            });
          }
        }, {
          key: "onBladePositionsChange_",
          value: function onBladePositionsChange_() {
            this.updatePositions_();
          }
        }]);

        return BladeRack;
      }();

      var RackController = /*#__PURE__*/function (_BladeController4) {
        _inherits(RackController, _BladeController4);

        var _super17 = _createSuper(RackController);

        function RackController(doc, config) {
          var _this24;

          _classCallCheck(this, RackController);

          _this24 = _super17.call(this, Object.assign(Object.assign({}, config), {
            view: new PlainView(doc, {
              viewName: 'brk',
              viewProps: config.viewProps
            })
          }));
          _this24.onRackAdd_ = _this24.onRackAdd_.bind(_assertThisInitialized(_this24));
          _this24.onRackRemove_ = _this24.onRackRemove_.bind(_assertThisInitialized(_this24));
          var rack = new BladeRack(config.root ? undefined : config.blade);
          rack.emitter.on('add', _this24.onRackAdd_);
          rack.emitter.on('remove', _this24.onRackRemove_);
          _this24.rack = rack;

          _this24.viewProps.handleDispose(function () {
            for (var i = _this24.rack.children.length - 1; i >= 0; i--) {
              var bc = _this24.rack.children[i];
              bc.viewProps.set('disposed', true);
            }
          });

          return _this24;
        }

        _createClass(RackController, [{
          key: "onRackAdd_",
          value: function onRackAdd_(ev) {
            if (!ev.isRoot) {
              return;
            }

            insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
          }
        }, {
          key: "onRackRemove_",
          value: function onRackRemove_(ev) {
            if (!ev.isRoot) {
              return;
            }

            removeElement(ev.bladeController.view.element);
          }
        }]);

        return RackController;
      }(BladeController);

      var bladeContainerClassName = ClassName('cnt');

      var FolderView = /*#__PURE__*/_createClass(function FolderView(doc, config) {
        var _this25 = this;

        _classCallCheck(this, FolderView);

        var _a;

        this.className_ = ClassName((_a = config.viewName) !== null && _a !== void 0 ? _a : 'fld');
        this.element = doc.createElement('div');
        this.element.classList.add(this.className_(), bladeContainerClassName());
        config.viewProps.bindClassModifiers(this.element);
        this.foldable_ = config.foldable;
        this.foldable_.bindExpandedClass(this.element, this.className_(undefined, 'expanded'));
        bindValueMap(this.foldable_, 'completed', valueToClassName(this.element, this.className_(undefined, 'cpl')));
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(this.className_('b'));
        bindValueMap(config.props, 'title', function (title) {
          if (isEmpty(title)) {
            _this25.element.classList.add(_this25.className_(undefined, 'not'));
          } else {
            _this25.element.classList.remove(_this25.className_(undefined, 'not'));
          }
        });
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var titleElem = doc.createElement('div');
        titleElem.classList.add(this.className_('t'));
        bindValueToTextContent(config.props.value('title'), titleElem);
        this.buttonElement.appendChild(titleElem);
        this.titleElement = titleElem;
        var markElem = doc.createElement('div');
        markElem.classList.add(this.className_('m'));
        this.buttonElement.appendChild(markElem);
        var containerElem = config.containerElement;
        containerElem.classList.add(this.className_('c'));
        this.element.appendChild(containerElem);
        this.containerElement = containerElem;
      });

      var FolderController = /*#__PURE__*/function (_RackLikeController) {
        _inherits(FolderController, _RackLikeController);

        var _super18 = _createSuper(FolderController);

        function FolderController(doc, config) {
          var _this26;

          _classCallCheck(this, FolderController);

          var _a;

          var foldable = Foldable.create((_a = config.expanded) !== null && _a !== void 0 ? _a : true);
          var rc = new RackController(doc, {
            blade: config.blade,
            root: config.root,
            viewProps: config.viewProps
          });
          _this26 = _super18.call(this, Object.assign(Object.assign({}, config), {
            rackController: rc,
            view: new FolderView(doc, {
              containerElement: rc.view.element,
              foldable: foldable,
              props: config.props,
              viewName: config.root ? 'rot' : undefined,
              viewProps: config.viewProps
            })
          }));
          _this26.onTitleClick_ = _this26.onTitleClick_.bind(_assertThisInitialized(_this26));
          _this26.props = config.props;
          _this26.foldable = foldable;
          bindFoldable(_this26.foldable, _this26.view.containerElement);

          _this26.rackController.rack.emitter.on('add', function () {
            _this26.foldable.cleanUpTransition();
          });

          _this26.rackController.rack.emitter.on('remove', function () {
            _this26.foldable.cleanUpTransition();
          });

          _this26.view.buttonElement.addEventListener('click', _this26.onTitleClick_);

          return _this26;
        }

        _createClass(FolderController, [{
          key: "document",
          get: function get() {
            return this.view.element.ownerDocument;
          }
        }, {
          key: "onTitleClick_",
          value: function onTitleClick_() {
            this.foldable.set('expanded', !this.foldable.get('expanded'));
          }
        }]);

        return FolderController;
      }(RackLikeController);

      var FolderBladePlugin = {
        id: 'folder',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            title: p.required.string,
            view: p.required.constant('folder'),
            expanded: p.optional["boolean"]
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          return new FolderController(args.document, {
            blade: args.blade,
            expanded: args.params.expanded,
            props: ValueMap.fromObject({
              title: args.params.title
            }),
            viewProps: args.viewProps
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof FolderController)) {
            return null;
          }

          return new FolderApi(args.controller, args.pool);
        }
      };

      var LabeledValueController = /*#__PURE__*/function (_ValueBladeController) {
        _inherits(LabeledValueController, _ValueBladeController);

        var _super19 = _createSuper(LabeledValueController);

        function LabeledValueController(doc, config) {
          var _this27;

          _classCallCheck(this, LabeledValueController);

          var viewProps = config.valueController.viewProps;
          _this27 = _super19.call(this, Object.assign(Object.assign({}, config), {
            value: config.valueController.value,
            view: new LabelView(doc, {
              props: config.props,
              viewProps: viewProps
            }),
            viewProps: viewProps
          }));
          _this27.props = config.props;
          _this27.valueController = config.valueController;

          _this27.view.valueElement.appendChild(_this27.valueController.view.element);

          return _this27;
        }

        return _createClass(LabeledValueController);
      }(ValueBladeController);

      var SeparatorApi = /*#__PURE__*/function (_BladeApi6) {
        _inherits(SeparatorApi, _BladeApi6);

        var _super20 = _createSuper(SeparatorApi);

        function SeparatorApi() {
          _classCallCheck(this, SeparatorApi);

          return _super20.apply(this, arguments);
        }

        return _createClass(SeparatorApi);
      }(BladeApi);

      var className$n = ClassName('spr');

      var SeparatorView = /*#__PURE__*/_createClass(function SeparatorView(doc, config) {
        _classCallCheck(this, SeparatorView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$n());
        config.viewProps.bindClassModifiers(this.element);
        var hrElem = doc.createElement('hr');
        hrElem.classList.add(className$n('r'));
        this.element.appendChild(hrElem);
      });

      var SeparatorController = /*#__PURE__*/function (_BladeController5) {
        _inherits(SeparatorController, _BladeController5);

        var _super21 = _createSuper(SeparatorController);

        function SeparatorController(doc, config) {
          _classCallCheck(this, SeparatorController);

          return _super21.call(this, Object.assign(Object.assign({}, config), {
            view: new SeparatorView(doc, {
              viewProps: config.viewProps
            })
          }));
        }

        return _createClass(SeparatorController);
      }(BladeController);

      var SeparatorBladePlugin = {
        id: 'separator',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            view: p.required.constant('separator')
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          return new SeparatorController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof SeparatorController)) {
            return null;
          }

          return new SeparatorApi(args.controller);
        }
      };
      var className$m = ClassName('');

      function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$m(undefined, modifier));
      }

      var ViewProps = /*#__PURE__*/function (_ValueMap2) {
        _inherits(ViewProps, _ValueMap2);

        var _super22 = _createSuper(ViewProps);

        function ViewProps(valueMap) {
          _classCallCheck(this, ViewProps);

          return _super22.call(this, valueMap);
        }

        _createClass(ViewProps, [{
          key: "bindClassModifiers",
          value: function bindClassModifiers(elem) {
            bindValueMap(this, 'disabled', valueToModifier(elem, 'disabled'));
            bindValueMap(this, 'hidden', valueToModifier(elem, 'hidden'));
          }
        }, {
          key: "bindDisabled",
          value: function bindDisabled(target) {
            bindValueMap(this, 'disabled', function (disabled) {
              target.disabled = disabled;
            });
          }
        }, {
          key: "bindTabIndex",
          value: function bindTabIndex(elem) {
            bindValueMap(this, 'disabled', function (disabled) {
              elem.tabIndex = disabled ? -1 : 0;
            });
          }
        }, {
          key: "handleDispose",
          value: function handleDispose(callback) {
            this.value('disposed').emitter.on('change', function (disposed) {
              if (disposed) {
                callback();
              }
            });
          }
        }], [{
          key: "create",
          value: function create(opt_initialValue) {
            var _a, _b;

            var initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            var coreObj = {
              disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
              disposed: false,
              hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false
            };
            var core = ValueMap.createCore(coreObj);
            return new ViewProps(core);
          }
        }]);

        return ViewProps;
      }(ValueMap);

      var className$l = ClassName('tbi');

      var TabItemView = /*#__PURE__*/_createClass(function TabItemView(doc, config) {
        var _this28 = this;

        _classCallCheck(this, TabItemView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$l());
        config.viewProps.bindClassModifiers(this.element);
        bindValueMap(config.props, 'selected', function (selected) {
          if (selected) {
            _this28.element.classList.add(className$l(undefined, 'sel'));
          } else {
            _this28.element.classList.remove(className$l(undefined, 'sel'));
          }
        });
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(className$l('b'));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var titleElem = doc.createElement('div');
        titleElem.classList.add(className$l('t'));
        bindValueToTextContent(config.props.value('title'), titleElem);
        this.buttonElement.appendChild(titleElem);
        this.titleElement = titleElem;
      });

      var TabItemController = /*#__PURE__*/function () {
        function TabItemController(doc, config) {
          _classCallCheck(this, TabItemController);

          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new TabItemView(doc, {
            props: config.props,
            viewProps: config.viewProps
          });
          this.view.buttonElement.addEventListener('click', this.onClick_);
        }

        _createClass(TabItemController, [{
          key: "onClick_",
          value: function onClick_() {
            this.emitter.emit('click', {
              sender: this
            });
          }
        }]);

        return TabItemController;
      }();

      var TabPageController = /*#__PURE__*/function () {
        function TabPageController(doc, config) {
          var _this29 = this;

          _classCallCheck(this, TabPageController);

          this.onItemClick_ = this.onItemClick_.bind(this);
          this.ic_ = new TabItemController(doc, {
            props: config.itemProps,
            viewProps: ViewProps.create()
          });
          this.ic_.emitter.on('click', this.onItemClick_);
          this.cc_ = new RackController(doc, {
            blade: createBlade(),
            viewProps: ViewProps.create()
          });
          this.props = config.props;
          bindValueMap(this.props, 'selected', function (selected) {
            _this29.itemController.props.set('selected', selected);

            _this29.contentController.viewProps.set('hidden', !selected);
          });
        }

        _createClass(TabPageController, [{
          key: "itemController",
          get: function get() {
            return this.ic_;
          }
        }, {
          key: "contentController",
          get: function get() {
            return this.cc_;
          }
        }, {
          key: "onItemClick_",
          value: function onItemClick_() {
            this.props.set('selected', true);
          }
        }]);

        return TabPageController;
      }();

      var TabPageApi = /*#__PURE__*/function () {
        function TabPageApi(controller, contentRackApi) {
          _classCallCheck(this, TabPageApi);

          this.controller_ = controller;
          this.rackApi_ = contentRackApi;
        }

        _createClass(TabPageApi, [{
          key: "title",
          get: function get() {
            var _a;

            return (_a = this.controller_.itemController.props.get('title')) !== null && _a !== void 0 ? _a : '';
          },
          set: function set(title) {
            this.controller_.itemController.props.set('title', title);
          }
        }, {
          key: "selected",
          get: function get() {
            return this.controller_.props.get('selected');
          },
          set: function set(selected) {
            this.controller_.props.set('selected', selected);
          }
        }, {
          key: "children",
          get: function get() {
            return this.rackApi_.children;
          }
        }, {
          key: "addButton",
          value: function addButton(params) {
            return this.rackApi_.addButton(params);
          }
        }, {
          key: "addFolder",
          value: function addFolder(params) {
            return this.rackApi_.addFolder(params);
          }
        }, {
          key: "addSeparator",
          value: function addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
          }
        }, {
          key: "addTab",
          value: function addTab(params) {
            return this.rackApi_.addTab(params);
          }
        }, {
          key: "add",
          value: function add(api, opt_index) {
            this.rackApi_.add(api, opt_index);
          }
        }, {
          key: "remove",
          value: function remove(api) {
            this.rackApi_.remove(api);
          }
        }, {
          key: "addInput",
          value: function addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
          }
        }, {
          key: "addMonitor",
          value: function addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
          }
        }, {
          key: "addBlade",
          value: function addBlade(params) {
            return this.rackApi_.addBlade(params);
          }
        }]);

        return TabPageApi;
      }();

      var TabApi = /*#__PURE__*/function (_RackLikeApi2) {
        _inherits(TabApi, _RackLikeApi2);

        var _super23 = _createSuper(TabApi);

        function TabApi(controller, pool) {
          var _this30;

          _classCallCheck(this, TabApi);

          _this30 = _super23.call(this, controller, new RackApi(controller.rackController, pool));
          _this30.onPageAdd_ = _this30.onPageAdd_.bind(_assertThisInitialized(_this30));
          _this30.onPageRemove_ = _this30.onPageRemove_.bind(_assertThisInitialized(_this30));
          _this30.onSelect_ = _this30.onSelect_.bind(_assertThisInitialized(_this30));
          _this30.emitter_ = new Emitter();
          _this30.pageApiMap_ = new Map();

          _this30.rackApi_.on('change', function (ev) {
            _this30.emitter_.emit('change', {
              event: ev
            });
          });

          _this30.rackApi_.on('update', function (ev) {
            _this30.emitter_.emit('update', {
              event: ev
            });
          });

          _this30.controller_.tab.selectedIndex.emitter.on('change', _this30.onSelect_);

          _this30.controller_.pageSet.emitter.on('add', _this30.onPageAdd_);

          _this30.controller_.pageSet.emitter.on('remove', _this30.onPageRemove_);

          _this30.controller_.pageSet.items.forEach(function (pc) {
            _this30.setUpPageApi_(pc);
          });

          return _this30;
        }

        _createClass(TabApi, [{
          key: "pages",
          get: function get() {
            var _this31 = this;

            return this.controller_.pageSet.items.map(function (pc) {
              var api = _this31.pageApiMap_.get(pc);

              if (!api) {
                throw TpError.shouldNeverHappen();
              }

              return api;
            });
          }
        }, {
          key: "addPage",
          value: function addPage(params) {
            var doc = this.controller_.view.element.ownerDocument;
            var pc = new TabPageController(doc, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: params.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            this.controller_.add(pc, params.index);
            var api = this.pageApiMap_.get(pc);

            if (!api) {
              throw TpError.shouldNeverHappen();
            }

            return api;
          }
        }, {
          key: "removePage",
          value: function removePage(index) {
            this.controller_.remove(index);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }, {
          key: "setUpPageApi_",
          value: function setUpPageApi_(pc) {
            var rackApi = this.rackApi_['apiSet_'].find(function (api) {
              return api.controller_ === pc.contentController;
            });

            if (!rackApi) {
              throw TpError.shouldNeverHappen();
            }

            var api = new TabPageApi(pc, rackApi);
            this.pageApiMap_.set(pc, api);
          }
        }, {
          key: "onPageAdd_",
          value: function onPageAdd_(ev) {
            this.setUpPageApi_(ev.item);
          }
        }, {
          key: "onPageRemove_",
          value: function onPageRemove_(ev) {
            var api = this.pageApiMap_.get(ev.item);

            if (!api) {
              throw TpError.shouldNeverHappen();
            }

            this.pageApiMap_["delete"](ev.item);
          }
        }, {
          key: "onSelect_",
          value: function onSelect_(ev) {
            this.emitter_.emit('select', {
              event: new TpTabSelectEvent(this, ev.rawValue)
            });
          }
        }]);

        return TabApi;
      }(RackLikeApi);

      var INDEX_NOT_SELECTED = -1;

      var Tab = /*#__PURE__*/function () {
        function Tab() {
          _classCallCheck(this, Tab);

          this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
          this.empty = createValue(true);
          this.selectedIndex = createValue(INDEX_NOT_SELECTED);
          this.items_ = [];
        }

        _createClass(Tab, [{
          key: "add",
          value: function add(item, opt_index) {
            var index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            item.emitter.on('change', this.onItemSelectedChange_);
            this.keepSelection_();
          }
        }, {
          key: "remove",
          value: function remove(item) {
            var index = this.items_.indexOf(item);

            if (index < 0) {
              return;
            }

            this.items_.splice(index, 1);
            item.emitter.off('change', this.onItemSelectedChange_);
            this.keepSelection_();
          }
        }, {
          key: "keepSelection_",
          value: function keepSelection_() {
            if (this.items_.length === 0) {
              this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
              this.empty.rawValue = true;
              return;
            }

            var firstSelIndex = this.items_.findIndex(function (s) {
              return s.rawValue;
            });

            if (firstSelIndex < 0) {
              this.items_.forEach(function (s, i) {
                s.rawValue = i === 0;
              });
              this.selectedIndex.rawValue = 0;
            } else {
              this.items_.forEach(function (s, i) {
                s.rawValue = i === firstSelIndex;
              });
              this.selectedIndex.rawValue = firstSelIndex;
            }

            this.empty.rawValue = false;
          }
        }, {
          key: "onItemSelectedChange_",
          value: function onItemSelectedChange_(ev) {
            if (ev.rawValue) {
              var index = this.items_.findIndex(function (s) {
                return s === ev.sender;
              });
              this.items_.forEach(function (s, i) {
                s.rawValue = i === index;
              });
              this.selectedIndex.rawValue = index;
            } else {
              this.keepSelection_();
            }
          }
        }]);

        return Tab;
      }();

      var className$k = ClassName('tab');

      var TabView = /*#__PURE__*/_createClass(function TabView(doc, config) {
        _classCallCheck(this, TabView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$k(), bladeContainerClassName());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.empty, valueToClassName(this.element, className$k(undefined, 'nop')));
        var itemsElem = doc.createElement('div');
        itemsElem.classList.add(className$k('i'));
        this.element.appendChild(itemsElem);
        this.itemsElement = itemsElem;
        var contentsElem = config.contentsElement;
        contentsElem.classList.add(className$k('c'));
        this.element.appendChild(contentsElem);
        this.contentsElement = contentsElem;
      });

      var TabController = /*#__PURE__*/function (_RackLikeController2) {
        _inherits(TabController, _RackLikeController2);

        var _super24 = _createSuper(TabController);

        function TabController(doc, config) {
          var _this32;

          _classCallCheck(this, TabController);

          var cr = new RackController(doc, {
            blade: config.blade,
            viewProps: config.viewProps
          });
          var tab = new Tab();
          _this32 = _super24.call(this, {
            blade: config.blade,
            rackController: cr,
            view: new TabView(doc, {
              contentsElement: cr.view.element,
              empty: tab.empty,
              viewProps: config.viewProps
            })
          });
          _this32.onPageAdd_ = _this32.onPageAdd_.bind(_assertThisInitialized(_this32));
          _this32.onPageRemove_ = _this32.onPageRemove_.bind(_assertThisInitialized(_this32));
          _this32.pageSet_ = new NestedOrderedSet(function () {
            return null;
          });

          _this32.pageSet_.emitter.on('add', _this32.onPageAdd_);

          _this32.pageSet_.emitter.on('remove', _this32.onPageRemove_);

          _this32.tab = tab;
          return _this32;
        }

        _createClass(TabController, [{
          key: "pageSet",
          get: function get() {
            return this.pageSet_;
          }
        }, {
          key: "add",
          value: function add(pc, opt_index) {
            this.pageSet_.add(pc, opt_index);
          }
        }, {
          key: "remove",
          value: function remove(index) {
            this.pageSet_.remove(this.pageSet_.items[index]);
          }
        }, {
          key: "onPageAdd_",
          value: function onPageAdd_(ev) {
            var pc = ev.item;
            insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
            this.rackController.rack.add(pc.contentController, ev.index);
            this.tab.add(pc.props.value('selected'));
          }
        }, {
          key: "onPageRemove_",
          value: function onPageRemove_(ev) {
            var pc = ev.item;
            removeElement(pc.itemController.view.element);
            this.rackController.rack.remove(pc.contentController);
            this.tab.remove(pc.props.value('selected'));
          }
        }]);

        return TabController;
      }(RackLikeController);

      var TabBladePlugin = {
        id: 'tab',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            pages: p.required.array(p.required.object({
              title: p.required.string
            })),
            view: p.required.constant('tab')
          });

          if (!result || result.pages.length === 0) {
            return null;
          }

          return {
            params: result
          };
        },
        controller: function controller(args) {
          var c = new TabController(args.document, {
            blade: args.blade,
            viewProps: args.viewProps
          });
          args.params.pages.forEach(function (p) {
            var pc = new TabPageController(args.document, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: p.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            c.add(pc);
          });
          return c;
        },
        api: function api(args) {
          if (!(args.controller instanceof TabController)) {
            return null;
          }

          return new TabApi(args.controller, args.pool);
        }
      };

      function createBladeController(plugin, args) {
        var ac = plugin.accept(args.params);

        if (!ac) {
          return null;
        }

        var disabled = ParamsParsers.optional["boolean"](args.params['disabled']).value;
        var hidden = ParamsParsers.optional["boolean"](args.params['hidden']).value;
        return plugin.controller({
          blade: createBlade(),
          document: args.document,
          params: forceCast(Object.assign(Object.assign({}, ac.params), {
            disabled: disabled,
            hidden: hidden
          })),
          viewProps: ViewProps.create({
            disabled: disabled,
            hidden: hidden
          })
        });
      }

      var ManualTicker = /*#__PURE__*/function () {
        function ManualTicker() {
          _classCallCheck(this, ManualTicker);

          this.disabled = false;
          this.emitter = new Emitter();
        }

        _createClass(ManualTicker, [{
          key: "dispose",
          value: function dispose() {}
        }, {
          key: "tick",
          value: function tick() {
            if (this.disabled) {
              return;
            }

            this.emitter.emit('tick', {
              sender: this
            });
          }
        }]);

        return ManualTicker;
      }();

      var IntervalTicker = /*#__PURE__*/function () {
        function IntervalTicker(doc, interval) {
          _classCallCheck(this, IntervalTicker);

          this.disabled_ = false;
          this.timerId_ = null;
          this.onTick_ = this.onTick_.bind(this);
          this.doc_ = doc;
          this.emitter = new Emitter();
          this.interval_ = interval;
          this.setTimer_();
        }

        _createClass(IntervalTicker, [{
          key: "disabled",
          get: function get() {
            return this.disabled_;
          },
          set: function set(inactive) {
            this.disabled_ = inactive;

            if (this.disabled_) {
              this.clearTimer_();
            } else {
              this.setTimer_();
            }
          }
        }, {
          key: "dispose",
          value: function dispose() {
            this.clearTimer_();
          }
        }, {
          key: "clearTimer_",
          value: function clearTimer_() {
            if (this.timerId_ === null) {
              return;
            }

            var win = this.doc_.defaultView;

            if (win) {
              win.clearInterval(this.timerId_);
            }

            this.timerId_ = null;
          }
        }, {
          key: "setTimer_",
          value: function setTimer_() {
            this.clearTimer_();

            if (this.interval_ <= 0) {
              return;
            }

            var win = this.doc_.defaultView;

            if (win) {
              this.timerId_ = win.setInterval(this.onTick_, this.interval_);
            }
          }
        }, {
          key: "onTick_",
          value: function onTick_() {
            if (this.disabled_) {
              return;
            }

            this.emitter.emit('tick', {
              sender: this
            });
          }
        }]);

        return IntervalTicker;
      }();

      var CompositeConstraint = /*#__PURE__*/function () {
        function CompositeConstraint(constraints) {
          _classCallCheck(this, CompositeConstraint);

          this.constraints = constraints;
        }

        _createClass(CompositeConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            return this.constraints.reduce(function (result, c) {
              return c.constrain(result);
            }, value);
          }
        }]);

        return CompositeConstraint;
      }();

      function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
          return c;
        }

        if (c instanceof CompositeConstraint) {
          var result = c.constraints.reduce(function (tmpResult, sc) {
            if (tmpResult) {
              return tmpResult;
            }

            return sc instanceof constraintClass ? sc : null;
          }, null);

          if (result) {
            return result;
          }
        }

        return null;
      }

      var ListConstraint = /*#__PURE__*/function () {
        function ListConstraint(options) {
          _classCallCheck(this, ListConstraint);

          this.options = options;
        }

        _createClass(ListConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var opts = this.options;

            if (opts.length === 0) {
              return value;
            }

            var matched = opts.filter(function (item) {
              return item.value === value;
            }).length > 0;
            return matched ? value : opts[0].value;
          }
        }]);

        return ListConstraint;
      }();

      var RangeConstraint = /*#__PURE__*/function () {
        function RangeConstraint(config) {
          _classCallCheck(this, RangeConstraint);

          this.maxValue = config.max;
          this.minValue = config.min;
        }

        _createClass(RangeConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var result = value;

            if (!isEmpty(this.minValue)) {
              result = Math.max(result, this.minValue);
            }

            if (!isEmpty(this.maxValue)) {
              result = Math.min(result, this.maxValue);
            }

            return result;
          }
        }]);

        return RangeConstraint;
      }();

      var StepConstraint = /*#__PURE__*/function () {
        function StepConstraint(step) {
          var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _classCallCheck(this, StepConstraint);

          this.step = step;
          this.origin = origin;
        }

        _createClass(StepConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var o = this.origin % this.step;
            var r = Math.round((value - o) / this.step);
            return o + r * this.step;
          }
        }]);

        return StepConstraint;
      }();

      var className$j = ClassName('lst');

      var ListView = /*#__PURE__*/function () {
        function ListView(doc, config) {
          _classCallCheck(this, ListView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.props_ = config.props;
          this.element = doc.createElement('div');
          this.element.classList.add(className$j());
          config.viewProps.bindClassModifiers(this.element);
          var selectElem = doc.createElement('select');
          selectElem.classList.add(className$j('s'));
          bindValueMap(this.props_, 'options', function (opts) {
            removeChildElements(selectElem);
            opts.forEach(function (item, index) {
              var optionElem = doc.createElement('option');
              optionElem.dataset.index = String(index);
              optionElem.textContent = item.text;
              optionElem.value = String(item.value);
              selectElem.appendChild(optionElem);
            });
          });
          config.viewProps.bindDisabled(selectElem);
          this.element.appendChild(selectElem);
          this.selectElement = selectElem;
          var markElem = doc.createElement('div');
          markElem.classList.add(className$j('m'));
          markElem.appendChild(createSvgIconElement(doc, 'dropdown'));
          this.element.appendChild(markElem);
          config.value.emitter.on('change', this.onValueChange_);
          this.value_ = config.value;
          this.update_();
        }

        _createClass(ListView, [{
          key: "update_",
          value: function update_() {
            this.selectElement.value = String(this.value_.rawValue);
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return ListView;
      }();

      var ListController = /*#__PURE__*/function () {
        function ListController(doc, config) {
          _classCallCheck(this, ListController);

          this.onSelectChange_ = this.onSelectChange_.bind(this);
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new ListView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.selectElement.addEventListener('change', this.onSelectChange_);
        }

        _createClass(ListController, [{
          key: "onSelectChange_",
          value: function onSelectChange_(e) {
            var selectElem = forceCast(e.currentTarget);
            var optElem = selectElem.selectedOptions.item(0);

            if (!optElem) {
              return;
            }

            var itemIndex = Number(optElem.dataset.index);
            this.value.rawValue = this.props.get('options')[itemIndex].value;
          }
        }]);

        return ListController;
      }();

      var className$i = ClassName('pop');

      var PopupView = /*#__PURE__*/_createClass(function PopupView(doc, config) {
        _classCallCheck(this, PopupView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$i());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.shows, valueToClassName(this.element, className$i(undefined, 'v')));
      });

      var PopupController = /*#__PURE__*/_createClass(function PopupController(doc, config) {
        _classCallCheck(this, PopupController);

        this.shows = createValue(false);
        this.viewProps = config.viewProps;
        this.view = new PopupView(doc, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      });

      var className$h = ClassName('txt');

      var TextView = /*#__PURE__*/function () {
        function TextView(doc, config) {
          _classCallCheck(this, TextView);

          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className$h());
          config.viewProps.bindClassModifiers(this.element);
          this.props_ = config.props;
          this.props_.emitter.on('change', this.onChange_);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$h('i'));
          inputElem.type = 'text';
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on('change', this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }

        _createClass(TextView, [{
          key: "refresh",
          value: function refresh() {
            var formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value_.rawValue);
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.refresh();
          }
        }]);

        return TextView;
      }();

      var TextController = /*#__PURE__*/function () {
        function TextController(doc, config) {
          _classCallCheck(this, TextController);

          this.onInputChange_ = this.onInputChange_.bind(this);
          this.parser_ = config.parser;
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new TextView(doc, {
            props: config.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener('change', this.onInputChange_);
        }

        _createClass(TextController, [{
          key: "onInputChange_",
          value: function onInputChange_(e) {
            var inputElem = forceCast(e.currentTarget);
            var value = inputElem.value;
            var parsedValue = this.parser_(value);

            if (!isEmpty(parsedValue)) {
              this.value.rawValue = parsedValue;
            }

            this.view.refresh();
          }
        }]);

        return TextController;
      }();

      function boolToString(value) {
        return String(value);
      }

      function boolFromUnknown(value) {
        if (value === 'false') {
          return false;
        }

        return !!value;
      }

      function BooleanFormatter(value) {
        return boolToString(value);
      }

      var NumberLiteralNode = /*#__PURE__*/function () {
        function NumberLiteralNode(text) {
          _classCallCheck(this, NumberLiteralNode);

          this.text = text;
        }

        _createClass(NumberLiteralNode, [{
          key: "evaluate",
          value: function evaluate() {
            return Number(this.text);
          }
        }, {
          key: "toString",
          value: function toString() {
            return this.text;
          }
        }]);

        return NumberLiteralNode;
      }();

      var BINARY_OPERATION_MAP = {
        '**': function _(v1, v2) {
          return Math.pow(v1, v2);
        },
        '*': function _(v1, v2) {
          return v1 * v2;
        },
        '/': function _(v1, v2) {
          return v1 / v2;
        },
        '%': function _(v1, v2) {
          return v1 % v2;
        },
        '+': function _(v1, v2) {
          return v1 + v2;
        },
        '-': function _(v1, v2) {
          return v1 - v2;
        },
        '<<': function _(v1, v2) {
          return v1 << v2;
        },
        '>>': function _(v1, v2) {
          return v1 >> v2;
        },
        '>>>': function _(v1, v2) {
          return v1 >>> v2;
        },
        '&': function _(v1, v2) {
          return v1 & v2;
        },
        '^': function _(v1, v2) {
          return v1 ^ v2;
        },
        '|': function _(v1, v2) {
          return v1 | v2;
        }
      };

      var BinaryOperationNode = /*#__PURE__*/function () {
        function BinaryOperationNode(operator, left, right) {
          _classCallCheck(this, BinaryOperationNode);

          this.left = left;
          this.operator = operator;
          this.right = right;
        }

        _createClass(BinaryOperationNode, [{
          key: "evaluate",
          value: function evaluate() {
            var op = BINARY_OPERATION_MAP[this.operator];

            if (!op) {
              throw new Error("unexpected binary operator: '".concat(this.operator));
            }

            return op(this.left.evaluate(), this.right.evaluate());
          }
        }, {
          key: "toString",
          value: function toString() {
            return ['b(', this.left.toString(), this.operator, this.right.toString(), ')'].join(' ');
          }
        }]);

        return BinaryOperationNode;
      }();

      var UNARY_OPERATION_MAP = {
        '+': function _(v) {
          return v;
        },
        '-': function _(v) {
          return -v;
        },
        '~': function _(v) {
          return ~v;
        }
      };

      var UnaryOperationNode = /*#__PURE__*/function () {
        function UnaryOperationNode(operator, expr) {
          _classCallCheck(this, UnaryOperationNode);

          this.operator = operator;
          this.expression = expr;
        }

        _createClass(UnaryOperationNode, [{
          key: "evaluate",
          value: function evaluate() {
            var op = UNARY_OPERATION_MAP[this.operator];

            if (!op) {
              throw new Error("unexpected unary operator: '".concat(this.operator));
            }

            return op(this.expression.evaluate());
          }
        }, {
          key: "toString",
          value: function toString() {
            return ['u(', this.operator, this.expression.toString(), ')'].join(' ');
          }
        }]);

        return UnaryOperationNode;
      }();

      function combineReader(parsers) {
        return function (text, cursor) {
          for (var i = 0; i < parsers.length; i++) {
            var result = parsers[i](text, cursor);

            if (result !== '') {
              return result;
            }
          }

          return '';
        };
      }

      function readWhitespace(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^\s+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readNonZeroDigit(text, cursor) {
        var ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : '';
      }

      function readDecimalDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-9]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readSignedInteger(text, cursor) {
        var ds = readDecimalDigits(text, cursor);

        if (ds !== '') {
          return ds;
        }

        var sign = text.substr(cursor, 1);
        cursor += 1;

        if (sign !== '-' && sign !== '+') {
          return '';
        }

        var sds = readDecimalDigits(text, cursor);

        if (sds === '') {
          return '';
        }

        return sign + sds;
      }

      function readExponentPart(text, cursor) {
        var e = text.substr(cursor, 1);
        cursor += 1;

        if (e.toLowerCase() !== 'e') {
          return '';
        }

        var si = readSignedInteger(text, cursor);

        if (si === '') {
          return '';
        }

        return e + si;
      }

      function readDecimalIntegerLiteral(text, cursor) {
        var ch = text.substr(cursor, 1);

        if (ch === '0') {
          return ch;
        }

        var nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;

        if (nzd === '') {
          return '';
        }

        return nzd + readDecimalDigits(text, cursor);
      }

      function readDecimalLiteral1(text, cursor) {
        var dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;

        if (dil === '') {
          return '';
        }

        var dot = text.substr(cursor, 1);
        cursor += dot.length;

        if (dot !== '.') {
          return '';
        }

        var dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
      }

      function readDecimalLiteral2(text, cursor) {
        var dot = text.substr(cursor, 1);
        cursor += dot.length;

        if (dot !== '.') {
          return '';
        }

        var dds = readDecimalDigits(text, cursor);
        cursor += dds.length;

        if (dds === '') {
          return '';
        }

        return dot + dds + readExponentPart(text, cursor);
      }

      function readDecimalLiteral3(text, cursor) {
        var dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;

        if (dil === '') {
          return '';
        }

        return dil + readExponentPart(text, cursor);
      }

      var readDecimalLiteral = combineReader([readDecimalLiteral1, readDecimalLiteral2, readDecimalLiteral3]);

      function parseBinaryDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[01]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readBinaryIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0b') {
          return '';
        }

        var bds = parseBinaryDigits(text, cursor);

        if (bds === '') {
          return '';
        }

        return prefix + bds;
      }

      function readOctalDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-7]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readOctalIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0o') {
          return '';
        }

        var ods = readOctalDigits(text, cursor);

        if (ods === '') {
          return '';
        }

        return prefix + ods;
      }

      function readHexDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readHexIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0x') {
          return '';
        }

        var hds = readHexDigits(text, cursor);

        if (hds === '') {
          return '';
        }

        return prefix + hds;
      }

      var readNonDecimalIntegerLiteral = combineReader([readBinaryIntegerLiteral, readOctalIntegerLiteral, readHexIntegerLiteral]);
      var readNumericLiteral = combineReader([readNonDecimalIntegerLiteral, readDecimalLiteral]);

      function parseLiteral(text, cursor) {
        var num = readNumericLiteral(text, cursor);
        cursor += num.length;

        if (num === '') {
          return null;
        }

        return {
          evaluable: new NumberLiteralNode(num),
          cursor: cursor
        };
      }

      function parseParenthesizedExpression(text, cursor) {
        var op = text.substr(cursor, 1);
        cursor += op.length;

        if (op !== '(') {
          return null;
        }

        var expr = parseExpression(text, cursor);

        if (!expr) {
          return null;
        }

        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        var cl = text.substr(cursor, 1);
        cursor += cl.length;

        if (cl !== ')') {
          return null;
        }

        return {
          evaluable: expr.evaluable,
          cursor: cursor
        };
      }

      function parsePrimaryExpression(text, cursor) {
        var _a;

        return (_a = parseLiteral(text, cursor)) !== null && _a !== void 0 ? _a : parseParenthesizedExpression(text, cursor);
      }

      function parseUnaryExpression(text, cursor) {
        var expr = parsePrimaryExpression(text, cursor);

        if (expr) {
          return expr;
        }

        var op = text.substr(cursor, 1);
        cursor += op.length;

        if (op !== '+' && op !== '-' && op !== '~') {
          return null;
        }

        var num = parseUnaryExpression(text, cursor);

        if (!num) {
          return null;
        }

        cursor = num.cursor;
        return {
          cursor: cursor,
          evaluable: new UnaryOperationNode(op, num.evaluable)
        };
      }

      function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        var op = ops.filter(function (op) {
          return text.startsWith(op, cursor);
        })[0];

        if (!op) {
          return null;
        }

        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
          cursor: cursor,
          operator: op
        };
      }

      function createBinaryOperationExpressionParser(exprParser, ops) {
        return function (text, cursor) {
          var firstExpr = exprParser(text, cursor);

          if (!firstExpr) {
            return null;
          }

          cursor = firstExpr.cursor;
          var expr = firstExpr.evaluable;

          for (;;) {
            var op = readBinaryOperator(ops, text, cursor);

            if (!op) {
              break;
            }

            cursor = op.cursor;
            var nextExpr = exprParser(text, cursor);

            if (!nextExpr) {
              return null;
            }

            cursor = nextExpr.cursor;
            expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
          }

          return expr ? {
            cursor: cursor,
            evaluable: expr
          } : null;
        };
      }

      var parseBinaryOperationExpression = [['**'], ['*', '/', '%'], ['+', '-'], ['<<', '>>>', '>>'], ['&'], ['^'], ['|']].reduce(function (parser, ops) {
        return createBinaryOperationExpressionParser(parser, ops);
      }, parseUnaryExpression);

      function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
      }

      function parseEcmaNumberExpression(text) {
        var expr = parseExpression(text, 0);

        if (!expr) {
          return null;
        }

        var cursor = expr.cursor + readWhitespace(text, expr.cursor).length;

        if (cursor !== text.length) {
          return null;
        }

        return expr.evaluable;
      }

      function parseNumber(text) {
        var _a;

        var r = parseEcmaNumberExpression(text);
        return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
      }

      function numberFromUnknown(value) {
        if (typeof value === 'number') {
          return value;
        }

        if (typeof value === 'string') {
          var pv = parseNumber(value);

          if (!isEmpty(pv)) {
            return pv;
          }
        }

        return 0;
      }

      function numberToString(value) {
        return String(value);
      }

      function createNumberFormatter(digits) {
        return function (value) {
          return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
      }

      var innerFormatter = createNumberFormatter(0);

      function formatPercentage(value) {
        return innerFormatter(value) + '%';
      }

      function stringFromUnknown(value) {
        return String(value);
      }

      function formatString(value) {
        return value;
      }

      function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
          buffer.push(undefined);
        }
      }

      function initializeBuffer(bufferSize) {
        var buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
      }

      function createTrimmedBuffer(buffer) {
        var index = buffer.indexOf(undefined);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
      }

      function createPushedBuffer(buffer, newValue) {
        var newBuffer = [].concat(_toConsumableArray(createTrimmedBuffer(buffer)), [newValue]);

        if (newBuffer.length > buffer.length) {
          newBuffer.splice(0, newBuffer.length - buffer.length);
        } else {
          fillBuffer(newBuffer, buffer.length);
        }

        return newBuffer;
      }

      function connectValues(_ref) {
        var primary = _ref.primary,
            secondary = _ref.secondary,
            forward = _ref.forward,
            backward = _ref.backward;
        var changing = false;

        function preventFeedback(callback) {
          if (changing) {
            return;
          }

          changing = true;
          callback();
          changing = false;
        }

        primary.emitter.on('change', function (ev) {
          preventFeedback(function () {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        secondary.emitter.on('change', function (ev) {
          preventFeedback(function () {
            primary.setRawValue(backward(primary, secondary), ev.options);
          });
          preventFeedback(function () {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        preventFeedback(function () {
          secondary.setRawValue(forward(primary, secondary), {
            forceEmit: false,
            last: true
          });
        });
      }

      function getStepForKey(baseStep, keys) {
        var step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);

        if (keys.upKey) {
          return +step;
        } else if (keys.downKey) {
          return -step;
        }

        return 0;
      }

      function getVerticalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === 'ArrowDown',
          shiftKey: ev.shiftKey,
          upKey: ev.key === 'ArrowUp'
        };
      }

      function getHorizontalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === 'ArrowLeft',
          shiftKey: ev.shiftKey,
          upKey: ev.key === 'ArrowRight'
        };
      }

      function isVerticalArrowKey(key) {
        return key === 'ArrowUp' || key === 'ArrowDown';
      }

      function isArrowKey(key) {
        return isVerticalArrowKey(key) || key === 'ArrowLeft' || key === 'ArrowRight';
      }

      function computeOffset$1(ev, elem) {
        var _a, _b;

        var win = elem.ownerDocument.defaultView;
        var rect = elem.getBoundingClientRect();
        return {
          x: ev.pageX - (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) + rect.left),
          y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) + rect.top)
        };
      }

      var PointerHandler = /*#__PURE__*/function () {
        function PointerHandler(element) {
          _classCallCheck(this, PointerHandler);

          this.lastTouch_ = null;
          this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
          this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
          this.onMouseDown_ = this.onMouseDown_.bind(this);
          this.onTouchEnd_ = this.onTouchEnd_.bind(this);
          this.onTouchMove_ = this.onTouchMove_.bind(this);
          this.onTouchStart_ = this.onTouchStart_.bind(this);
          this.elem_ = element;
          this.emitter = new Emitter();
          element.addEventListener('touchstart', this.onTouchStart_, {
            passive: false
          });
          element.addEventListener('touchmove', this.onTouchMove_, {
            passive: true
          });
          element.addEventListener('touchend', this.onTouchEnd_);
          element.addEventListener('mousedown', this.onMouseDown_);
        }

        _createClass(PointerHandler, [{
          key: "computePosition_",
          value: function computePosition_(offset) {
            var rect = this.elem_.getBoundingClientRect();
            return {
              bounds: {
                width: rect.width,
                height: rect.height
              },
              point: offset ? {
                x: offset.x,
                y: offset.y
              } : null
            };
          }
        }, {
          key: "onMouseDown_",
          value: function onMouseDown_(ev) {
            var _a;

            ev.preventDefault();
            (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
            var doc = this.elem_.ownerDocument;
            doc.addEventListener('mousemove', this.onDocumentMouseMove_);
            doc.addEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('down', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onDocumentMouseMove_",
          value: function onDocumentMouseMove_(ev) {
            this.emitter.emit('move', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onDocumentMouseUp_",
          value: function onDocumentMouseUp_(ev) {
            var doc = this.elem_.ownerDocument;
            doc.removeEventListener('mousemove', this.onDocumentMouseMove_);
            doc.removeEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('up', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onTouchStart_",
          value: function onTouchStart_(ev) {
            ev.preventDefault();
            var touch = ev.targetTouches.item(0);
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('down', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
        }, {
          key: "onTouchMove_",
          value: function onTouchMove_(ev) {
            var touch = ev.targetTouches.item(0);
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('move', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
        }, {
          key: "onTouchEnd_",
          value: function onTouchEnd_(ev) {
            var _a;

            var touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('up', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }]);

        return PointerHandler;
      }();

      function mapRange(value, start1, end1, start2, end2) {
        var p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
      }

      function getDecimalDigits(value) {
        var text = String(value.toFixed(10));
        var frac = text.split('.')[1];
        return frac.replace(/0+$/, '').length;
      }

      function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function loopRange(value, max) {
        return (value % max + max) % max;
      }

      var className$g = ClassName('txt');

      var NumberTextView = /*#__PURE__*/function () {
        function NumberTextView(doc, config) {
          _classCallCheck(this, NumberTextView);

          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on('change', this.onChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$g(), className$g(undefined, 'num'));

          if (config.arrayPosition) {
            this.element.classList.add(className$g(undefined, config.arrayPosition));
          }

          config.viewProps.bindClassModifiers(this.element);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$g('i'));
          inputElem.type = 'text';
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          this.onDraggingChange_ = this.onDraggingChange_.bind(this);
          this.dragging_ = config.dragging;
          this.dragging_.emitter.on('change', this.onDraggingChange_);
          this.element.classList.add(className$g());
          this.inputElement.classList.add(className$g('i'));
          var knobElem = doc.createElement('div');
          knobElem.classList.add(className$g('k'));
          this.element.appendChild(knobElem);
          this.knobElement = knobElem;
          var guideElem = doc.createElementNS(SVG_NS, 'svg');
          guideElem.classList.add(className$g('g'));
          this.knobElement.appendChild(guideElem);
          var bodyElem = doc.createElementNS(SVG_NS, 'path');
          bodyElem.classList.add(className$g('gb'));
          guideElem.appendChild(bodyElem);
          this.guideBodyElem_ = bodyElem;
          var headElem = doc.createElementNS(SVG_NS, 'path');
          headElem.classList.add(className$g('gh'));
          guideElem.appendChild(headElem);
          this.guideHeadElem_ = headElem;
          var tooltipElem = doc.createElement('div');
          tooltipElem.classList.add(ClassName('tt')());
          this.knobElement.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on('change', this.onChange_);
          this.value = config.value;
          this.refresh();
        }

        _createClass(NumberTextView, [{
          key: "onDraggingChange_",
          value: function onDraggingChange_(ev) {
            if (ev.rawValue === null) {
              this.element.classList.remove(className$g(undefined, 'drg'));
              return;
            }

            this.element.classList.add(className$g(undefined, 'drg'));
            var x = ev.rawValue / this.props_.get('draggingScale');
            var aox = x + (x > 0 ? -1 : x < 0 ? +1 : 0);
            var adx = constrainRange(-aox, -4, +4);
            this.guideHeadElem_.setAttributeNS(null, 'd', ["M ".concat(aox + adx, ",0 L").concat(aox, ",4 L").concat(aox + adx, ",8"), "M ".concat(x, ",-1 L").concat(x, ",9")].join(' '));
            this.guideBodyElem_.setAttributeNS(null, 'd', "M 0,4 L".concat(x, ",4"));
            var formatter = this.props_.get('formatter');
            this.tooltipElem_.textContent = formatter(this.value.rawValue);
            this.tooltipElem_.style.left = "".concat(x, "px");
          }
        }, {
          key: "refresh",
          value: function refresh() {
            var formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value.rawValue);
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.refresh();
          }
        }]);

        return NumberTextView;
      }();

      var NumberTextController = /*#__PURE__*/function () {
        function NumberTextController(doc, config) {
          _classCallCheck(this, NumberTextController);

          var _a;

          this.originRawValue_ = 0;
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
          this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.parser_ = config.parser;
          this.props = config.props;
          this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.dragging_ = createValue(null);
          this.view = new NumberTextView(doc, {
            arrayPosition: config.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener('change', this.onInputChange_);
          this.view.inputElement.addEventListener('keydown', this.onInputKeyDown_);
          this.view.inputElement.addEventListener('keyup', this.onInputKeyUp_);
          var ph = new PointerHandler(this.view.knobElement);
          ph.emitter.on('down', this.onPointerDown_);
          ph.emitter.on('move', this.onPointerMove_);
          ph.emitter.on('up', this.onPointerUp_);
        }

        _createClass(NumberTextController, [{
          key: "constrainValue_",
          value: function constrainValue_(value) {
            var _a, _b;

            var min = (_a = this.sliderProps_) === null || _a === void 0 ? void 0 : _a.get('minValue');
            var max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get('maxValue');
            var v = value;

            if (min !== undefined) {
              v = Math.max(v, min);
            }

            if (max !== undefined) {
              v = Math.min(v, max);
            }

            return v;
          }
        }, {
          key: "onInputChange_",
          value: function onInputChange_(e) {
            var inputElem = forceCast(e.currentTarget);
            var value = inputElem.value;
            var parsedValue = this.parser_(value);

            if (!isEmpty(parsedValue)) {
              this.value.rawValue = this.constrainValue_(parsedValue);
            }

            this.view.refresh();
          }
        }, {
          key: "onInputKeyDown_",
          value: function onInputKeyDown_(ev) {
            var step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onInputKeyUp_",
          value: function onInputKeyUp_(ev) {
            var step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_() {
            this.originRawValue_ = this.value.rawValue;
            this.dragging_.rawValue = 0;
          }
        }, {
          key: "computeDraggingValue_",
          value: function computeDraggingValue_(data) {
            if (!data.point) {
              return null;
            }

            var dx = data.point.x - data.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + dx * this.props.get('draggingScale'));
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            var v = this.computeDraggingValue_(ev.data);

            if (v === null) {
              return;
            }

            this.value.setRawValue(v, {
              forceEmit: false,
              last: false
            });
            this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            var v = this.computeDraggingValue_(ev.data);

            if (v === null) {
              return;
            }

            this.value.setRawValue(v, {
              forceEmit: true,
              last: true
            });
            this.dragging_.rawValue = null;
          }
        }]);

        return NumberTextController;
      }();

      var className$f = ClassName('sld');

      var SliderView = /*#__PURE__*/function () {
        function SliderView(doc, config) {
          _classCallCheck(this, SliderView);

          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on('change', this.onChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$f());
          config.viewProps.bindClassModifiers(this.element);
          var trackElem = doc.createElement('div');
          trackElem.classList.add(className$f('t'));
          config.viewProps.bindTabIndex(trackElem);
          this.element.appendChild(trackElem);
          this.trackElement = trackElem;
          var knobElem = doc.createElement('div');
          knobElem.classList.add(className$f('k'));
          this.trackElement.appendChild(knobElem);
          this.knobElement = knobElem;
          config.value.emitter.on('change', this.onChange_);
          this.value = config.value;
          this.update_();
        }

        _createClass(SliderView, [{
          key: "update_",
          value: function update_() {
            var p = constrainRange(mapRange(this.value.rawValue, this.props_.get('minValue'), this.props_.get('maxValue'), 0, 100), 0, 100);
            this.knobElement.style.width = "".concat(p, "%");
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.update_();
          }
        }]);

        return SliderView;
      }();

      var SliderController = /*#__PURE__*/function () {
        function SliderController(doc, config) {
          _classCallCheck(this, SliderController);

          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.props = config.props;
          this.view = new SliderView(doc, {
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.trackElement);
          this.ptHandler_.emitter.on('down', this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on('move', this.onPointerDownOrMove_);
          this.ptHandler_.emitter.on('up', this.onPointerUp_);
          this.view.trackElement.addEventListener('keydown', this.onKeyDown_);
          this.view.trackElement.addEventListener('keyup', this.onKeyUp_);
        }

        _createClass(SliderController, [{
          key: "handlePointerEvent_",
          value: function handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }

            this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get('minValue'), this.props.get('maxValue')), opts);
          }
        }, {
          key: "onPointerDownOrMove_",
          value: function onPointerDownOrMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onKeyDown_",
          value: function onKeyDown_(ev) {
            var step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue + step, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onKeyUp_",
          value: function onKeyUp_(ev) {
            var step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return SliderController;
      }();

      var className$e = ClassName('sldtxt');

      var SliderTextView = /*#__PURE__*/_createClass(function SliderTextView(doc, config) {
        _classCallCheck(this, SliderTextView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$e());
        var sliderElem = doc.createElement('div');
        sliderElem.classList.add(className$e('s'));
        this.sliderView_ = config.sliderView;
        sliderElem.appendChild(this.sliderView_.element);
        this.element.appendChild(sliderElem);
        var textElem = doc.createElement('div');
        textElem.classList.add(className$e('t'));
        this.textView_ = config.textView;
        textElem.appendChild(this.textView_.element);
        this.element.appendChild(textElem);
      });

      var SliderTextController = /*#__PURE__*/function () {
        function SliderTextController(doc, config) {
          _classCallCheck(this, SliderTextController);

          this.value = config.value;
          this.viewProps = config.viewProps;
          this.sliderC_ = new SliderController(doc, {
            baseStep: config.baseStep,
            props: config.sliderProps,
            value: config.value,
            viewProps: this.viewProps
          });
          this.textC_ = new NumberTextController(doc, {
            baseStep: config.baseStep,
            parser: config.parser,
            props: config.textProps,
            sliderProps: config.sliderProps,
            value: config.value,
            viewProps: config.viewProps
          });
          this.view = new SliderTextView(doc, {
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
          });
        }

        _createClass(SliderTextController, [{
          key: "sliderController",
          get: function get() {
            return this.sliderC_;
          }
        }, {
          key: "textController",
          get: function get() {
            return this.textC_;
          }
        }]);

        return SliderTextController;
      }();

      function writePrimitive(target, value) {
        target.write(value);
      }

      function parseListOptions(value) {
        var p = ParamsParsers;

        if (Array.isArray(value)) {
          return p.required.array(p.required.object({
            text: p.required.string,
            value: p.required.raw
          }))(value).value;
        }

        if (_typeof$1(value) === 'object') {
          return p.required.raw(value).value;
        }

        return undefined;
      }

      function parsePickerLayout(value) {
        if (value === 'inline' || value === 'popup') {
          return value;
        }

        return undefined;
      }

      function parsePointDimensionParams(value) {
        var p = ParamsParsers;
        return p.required.object({
          max: p.optional.number,
          min: p.optional.number,
          step: p.optional.number
        })(value).value;
      }

      function normalizeListOptions(options) {
        if (Array.isArray(options)) {
          return options;
        }

        var items = [];
        Object.keys(options).forEach(function (text) {
          items.push({
            text: text,
            value: options[text]
          });
        });
        return items;
      }

      function createListConstraint(options) {
        return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
      }

      function findListItems(constraint) {
        var c = constraint ? findConstraint(constraint, ListConstraint) : null;

        if (!c) {
          return null;
        }

        return c.options;
      }

      function findStep(constraint) {
        var c = constraint ? findConstraint(constraint, StepConstraint) : null;

        if (!c) {
          return null;
        }

        return c.step;
      }

      function getSuitableDecimalDigits(constraint, rawValue) {
        var sc = constraint && findConstraint(constraint, StepConstraint);

        if (sc) {
          return getDecimalDigits(sc.step);
        }

        return Math.max(getDecimalDigits(rawValue), 2);
      }

      function getBaseStep(constraint) {
        var step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
      }

      function getSuitableDraggingScale(constraint, rawValue) {
        var _a;

        var sc = constraint && findConstraint(constraint, StepConstraint);
        var base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
      }

      var className$d = ClassName('ckb');

      var CheckboxView = /*#__PURE__*/function () {
        function CheckboxView(doc, config) {
          _classCallCheck(this, CheckboxView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className$d());
          config.viewProps.bindClassModifiers(this.element);
          var labelElem = doc.createElement('label');
          labelElem.classList.add(className$d('l'));
          this.element.appendChild(labelElem);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$d('i'));
          inputElem.type = 'checkbox';
          labelElem.appendChild(inputElem);
          this.inputElement = inputElem;
          config.viewProps.bindDisabled(this.inputElement);
          var wrapperElem = doc.createElement('div');
          wrapperElem.classList.add(className$d('w'));
          labelElem.appendChild(wrapperElem);
          var markElem = createSvgIconElement(doc, 'check');
          wrapperElem.appendChild(markElem);
          config.value.emitter.on('change', this.onValueChange_);
          this.value = config.value;
          this.update_();
        }

        _createClass(CheckboxView, [{
          key: "update_",
          value: function update_() {
            this.inputElement.checked = this.value.rawValue;
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return CheckboxView;
      }();

      var CheckboxController = /*#__PURE__*/function () {
        function CheckboxController(doc, config) {
          _classCallCheck(this, CheckboxController);

          this.onInputChange_ = this.onInputChange_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new CheckboxView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener('change', this.onInputChange_);
        }

        _createClass(CheckboxController, [{
          key: "onInputChange_",
          value: function onInputChange_(e) {
            var inputElem = forceCast(e.currentTarget);
            this.value.rawValue = inputElem.checked;
          }
        }]);

        return CheckboxController;
      }();

      function createConstraint$6(params) {
        var constraints = [];
        var lc = createListConstraint(params.options);

        if (lc) {
          constraints.push(lc);
        }

        return new CompositeConstraint(constraints);
      }

      var BooleanInputPlugin = {
        id: 'input-bool',
        type: 'input',
        accept: function accept(value, params) {
          if (typeof value !== 'boolean') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return boolFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint$6(args.params);
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        },
        controller: function controller(args) {
          var _a;

          var doc = args.document;
          var value = args.value;
          var c = args.constraint;

          if (c && findConstraint(c, ListConstraint)) {
            return new ListController(doc, {
              props: ValueMap.fromObject({
                options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
              }),
              value: value,
              viewProps: args.viewProps
            });
          }

          return new CheckboxController(doc, {
            value: value,
            viewProps: args.viewProps
          });
        }
      };
      var className$c = ClassName('col');

      var ColorView = /*#__PURE__*/_createClass(function ColorView(doc, config) {
        _classCallCheck(this, ColorView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$c());
        config.foldable.bindExpandedClass(this.element, className$c(undefined, 'expanded'));
        bindValueMap(config.foldable, 'completed', valueToClassName(this.element, className$c(undefined, 'cpl')));
        var headElem = doc.createElement('div');
        headElem.classList.add(className$c('h'));
        this.element.appendChild(headElem);
        var swatchElem = doc.createElement('div');
        swatchElem.classList.add(className$c('s'));
        headElem.appendChild(swatchElem);
        this.swatchElement = swatchElem;
        var textElem = doc.createElement('div');
        textElem.classList.add(className$c('t'));
        headElem.appendChild(textElem);
        this.textElement = textElem;

        if (config.pickerLayout === 'inline') {
          var pickerElem = doc.createElement('div');
          pickerElem.classList.add(className$c('p'));
          this.element.appendChild(pickerElem);
          this.pickerElement = pickerElem;
        } else {
          this.pickerElement = null;
        }
      });

      function rgbToHslInt(r, g, b) {
        var rp = constrainRange(r / 255, 0, 1);
        var gp = constrainRange(g / 255, 0, 1);
        var bp = constrainRange(b / 255, 0, 1);
        var cmax = Math.max(rp, gp, bp);
        var cmin = Math.min(rp, gp, bp);
        var c = cmax - cmin;
        var h = 0;
        var s = 0;
        var l = (cmin + cmax) / 2;

        if (c !== 0) {
          s = c / (1 - Math.abs(cmax + cmin - 1));

          if (rp === cmax) {
            h = (gp - bp) / c;
          } else if (gp === cmax) {
            h = 2 + (bp - rp) / c;
          } else {
            h = 4 + (rp - gp) / c;
          }

          h = h / 6 + (h < 0 ? 1 : 0);
        }

        return [h * 360, s * 100, l * 100];
      }

      function hslToRgbInt(h, s, l) {
        var hp = (h % 360 + 360) % 360;
        var sp = constrainRange(s / 100, 0, 1);
        var lp = constrainRange(l / 100, 0, 1);
        var c = (1 - Math.abs(2 * lp - 1)) * sp;
        var x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        var m = lp - c / 2;
        var rp, gp, bp;

        if (hp >= 0 && hp < 60) {
          rp = c;
          gp = x;
          bp = 0;
        } else if (hp >= 60 && hp < 120) {
          rp = x;
          gp = c;
          bp = 0;
        } else if (hp >= 120 && hp < 180) {
          rp = 0;
          gp = c;
          bp = x;
        } else if (hp >= 180 && hp < 240) {
          rp = 0;
          gp = x;
          bp = c;
        } else if (hp >= 240 && hp < 300) {
          rp = x;
          gp = 0;
          bp = c;
        } else {
          rp = c;
          gp = 0;
          bp = x;
        }

        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
      }

      function rgbToHsvInt(r, g, b) {
        var rp = constrainRange(r / 255, 0, 1);
        var gp = constrainRange(g / 255, 0, 1);
        var bp = constrainRange(b / 255, 0, 1);
        var cmax = Math.max(rp, gp, bp);
        var cmin = Math.min(rp, gp, bp);
        var d = cmax - cmin;
        var h;

        if (d === 0) {
          h = 0;
        } else if (cmax === rp) {
          h = 60 * (((gp - bp) / d % 6 + 6) % 6);
        } else if (cmax === gp) {
          h = 60 * ((bp - rp) / d + 2);
        } else {
          h = 60 * ((rp - gp) / d + 4);
        }

        var s = cmax === 0 ? 0 : d / cmax;
        var v = cmax;
        return [h, s * 100, v * 100];
      }

      function hsvToRgbInt(h, s, v) {
        var hp = loopRange(h, 360);
        var sp = constrainRange(s / 100, 0, 1);
        var vp = constrainRange(v / 100, 0, 1);
        var c = vp * sp;
        var x = c * (1 - Math.abs(hp / 60 % 2 - 1));
        var m = vp - c;
        var rp, gp, bp;

        if (hp >= 0 && hp < 60) {
          rp = c;
          gp = x;
          bp = 0;
        } else if (hp >= 60 && hp < 120) {
          rp = x;
          gp = c;
          bp = 0;
        } else if (hp >= 120 && hp < 180) {
          rp = 0;
          gp = c;
          bp = x;
        } else if (hp >= 180 && hp < 240) {
          rp = 0;
          gp = x;
          bp = c;
        } else if (hp >= 240 && hp < 300) {
          rp = x;
          gp = 0;
          bp = c;
        } else {
          rp = c;
          gp = 0;
          bp = x;
        }

        return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
      }

      function hslToHsvInt(h, s, l) {
        var sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
        return [h, sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0, l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)];
      }

      function hsvToHslInt(h, s, v) {
        var sd = 100 - Math.abs(v * (200 - s) / 100 - 100);
        return [h, sd !== 0 ? s * v / sd : 0, v * (200 - s) / (2 * 100)];
      }

      function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
      }

      function appendAlphaComponent(comps, alpha) {
        return [comps[0], comps[1], comps[2], alpha];
      }

      var MODE_CONVERTER_MAP = {
        hsl: {
          hsl: function hsl(h, s, l) {
            return [h, s, l];
          },
          hsv: hslToHsvInt,
          rgb: hslToRgbInt
        },
        hsv: {
          hsl: hsvToHslInt,
          hsv: function hsv(h, s, v) {
            return [h, s, v];
          },
          rgb: hsvToRgbInt
        },
        rgb: {
          hsl: rgbToHslInt,
          hsv: rgbToHsvInt,
          rgb: function rgb(r, g, b) {
            return [r, g, b];
          }
        }
      };

      function getColorMaxComponents(mode, type) {
        return [type === 'float' ? 1 : mode === 'rgb' ? 255 : 360, type === 'float' ? 1 : mode === 'rgb' ? 255 : 100, type === 'float' ? 1 : mode === 'rgb' ? 255 : 100];
      }

      function constrainColorComponents(components, mode, type) {
        var _a;

        var ms = getColorMaxComponents(mode, type);
        return [mode === 'rgb' ? constrainRange(components[0], 0, ms[0]) : loopRange(components[0], ms[0]), constrainRange(components[1], 0, ms[1]), constrainRange(components[2], 0, ms[2]), constrainRange((_a = components[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)];
      }

      function convertColorType(comps, mode, from, to) {
        var fms = getColorMaxComponents(mode, from);
        var tms = getColorMaxComponents(mode, to);
        return comps.map(function (c, index) {
          return c / fms[index] * tms[index];
        });
      }

      function convertColor(components, from, to) {
        var _MODE_CONVERTER_MAP$f;

        var intComps = convertColorType(components, from.mode, from.type, 'int');

        var result = (_MODE_CONVERTER_MAP$f = MODE_CONVERTER_MAP[from.mode])[to.mode].apply(_MODE_CONVERTER_MAP$f, _toConsumableArray(intComps));

        return convertColorType(result, to.mode, 'int', to.type);
      }

      function isRgbColorComponent(obj, key) {
        if (_typeof$1(obj) !== 'object' || isEmpty(obj)) {
          return false;
        }

        return key in obj && typeof obj[key] === 'number';
      }

      var Color = /*#__PURE__*/function () {
        function Color(comps, mode) {
          var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'int';

          _classCallCheck(this, Color);

          this.mode = mode;
          this.type = type;
          this.comps_ = constrainColorComponents(comps, mode, type);
        }

        _createClass(Color, [{
          key: "getComponents",
          value: function getComponents(opt_mode) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'int';
            return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), {
              mode: this.mode,
              type: this.type
            }, {
              mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
              type: type
            }), this.comps_[3]);
          }
        }, {
          key: "toRgbaObject",
          value: function toRgbaObject() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'int';
            var rgbComps = this.getComponents('rgb', type);
            return {
              r: rgbComps[0],
              g: rgbComps[1],
              b: rgbComps[2],
              a: rgbComps[3]
            };
          }
        }], [{
          key: "black",
          value: function black() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'int';
            return new Color([0, 0, 0], 'rgb', type);
          }
        }, {
          key: "fromObject",
          value: function fromObject(obj) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'int';
            var comps = 'a' in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
            return new Color(comps, 'rgb', type);
          }
        }, {
          key: "toRgbaObject",
          value: function toRgbaObject(color) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'int';
            return color.toRgbaObject(type);
          }
        }, {
          key: "isRgbColorObject",
          value: function isRgbColorObject(obj) {
            return isRgbColorComponent(obj, 'r') && isRgbColorComponent(obj, 'g') && isRgbColorComponent(obj, 'b');
          }
        }, {
          key: "isRgbaColorObject",
          value: function isRgbaColorObject(obj) {
            return this.isRgbColorObject(obj) && isRgbColorComponent(obj, 'a');
          }
        }, {
          key: "isColorObject",
          value: function isColorObject(obj) {
            return this.isRgbColorObject(obj);
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            if (v1.mode !== v2.mode) {
              return false;
            }

            var comps1 = v1.comps_;
            var comps2 = v2.comps_;

            for (var i = 0; i < comps1.length; i++) {
              if (comps1[i] !== comps2[i]) {
                return false;
              }
            }

            return true;
          }
        }]);

        return Color;
      }();

      var className$b = ClassName('colp');

      var ColorPickerView = /*#__PURE__*/function () {
        function ColorPickerView(doc, config) {
          _classCallCheck(this, ColorPickerView);

          this.alphaViews_ = null;
          this.element = doc.createElement('div');
          this.element.classList.add(className$b());
          var hsvElem = doc.createElement('div');
          hsvElem.classList.add(className$b('hsv'));
          var svElem = doc.createElement('div');
          svElem.classList.add(className$b('sv'));
          this.svPaletteView_ = config.svPaletteView;
          svElem.appendChild(this.svPaletteView_.element);
          hsvElem.appendChild(svElem);
          var hElem = doc.createElement('div');
          hElem.classList.add(className$b('h'));
          this.hPaletteView_ = config.hPaletteView;
          hElem.appendChild(this.hPaletteView_.element);
          hsvElem.appendChild(hElem);
          this.element.appendChild(hsvElem);
          var rgbElem = doc.createElement('div');
          rgbElem.classList.add(className$b('rgb'));
          this.textView_ = config.textView;
          rgbElem.appendChild(this.textView_.element);
          this.element.appendChild(rgbElem);

          if (config.alphaViews) {
            this.alphaViews_ = {
              palette: config.alphaViews.palette,
              text: config.alphaViews.text
            };
            var aElem = doc.createElement('div');
            aElem.classList.add(className$b('a'));
            var apElem = doc.createElement('div');
            apElem.classList.add(className$b('ap'));
            apElem.appendChild(this.alphaViews_.palette.element);
            aElem.appendChild(apElem);
            var atElem = doc.createElement('div');
            atElem.classList.add(className$b('at'));
            atElem.appendChild(this.alphaViews_.text.element);
            aElem.appendChild(atElem);
            this.element.appendChild(aElem);
          }
        }

        _createClass(ColorPickerView, [{
          key: "allFocusableElements",
          get: function get() {
            var elems = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement].concat(_toConsumableArray(this.textView_.textViews.map(function (v) {
              return v.inputElement;
            })));

            if (this.alphaViews_) {
              elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
            }

            return elems;
          }
        }]);

        return ColorPickerView;
      }();

      function parseColorType(value) {
        return value === 'int' ? 'int' : value === 'float' ? 'float' : undefined;
      }

      function parseColorInputParams(params) {
        var p = ParamsParsers;
        return parseParams(params, {
          alpha: p.optional["boolean"],
          color: p.optional.object({
            alpha: p.optional["boolean"],
            type: p.optional.custom(parseColorType)
          }),
          expanded: p.optional["boolean"],
          picker: p.optional.custom(parsePickerLayout)
        });
      }

      function getBaseStepForColor(forAlpha) {
        return forAlpha ? 0.1 : 1;
      }

      function extractColorType(params) {
        var _a;

        return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
      }

      function equalsStringColorFormat(f1, f2) {
        return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;
      }

      function parseCssNumberOrPercentage(text, maxValue) {
        var m = text.match(/^(.+)%$/);

        if (!m) {
          return Math.min(parseFloat(text), maxValue);
        }

        return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
      }

      var ANGLE_TO_DEG_MAP = {
        deg: function deg(angle) {
          return angle;
        },
        grad: function grad(angle) {
          return angle * 360 / 400;
        },
        rad: function rad(angle) {
          return angle * 360 / (2 * Math.PI);
        },
        turn: function turn(angle) {
          return angle * 360;
        }
      };

      function parseCssNumberOrAngle(text) {
        var m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);

        if (!m) {
          return parseFloat(text);
        }

        var angle = parseFloat(m[1]);
        var unit = m[2];
        return ANGLE_TO_DEG_MAP[unit](angle);
      }

      function parseFunctionalRgbColorComponents(text) {
        var m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);

        if (!m) {
          return null;
        }

        var comps = [parseCssNumberOrPercentage(m[1], 255), parseCssNumberOrPercentage(m[2], 255), parseCssNumberOrPercentage(m[3], 255)];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }

        return comps;
      }

      function createFunctionalRgbColorParser(type) {
        return function (text) {
          var comps = parseFunctionalRgbColorComponents(text);
          return comps ? new Color(comps, 'rgb', type) : null;
        };
      }

      function parseFunctionalRgbaColorComponents(text) {
        var m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);

        if (!m) {
          return null;
        }

        var comps = [parseCssNumberOrPercentage(m[1], 255), parseCssNumberOrPercentage(m[2], 255), parseCssNumberOrPercentage(m[3], 255), parseCssNumberOrPercentage(m[4], 1)];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }

        return comps;
      }

      function createFunctionalRgbaColorParser(type) {
        return function (text) {
          var comps = parseFunctionalRgbaColorComponents(text);
          return comps ? new Color(comps, 'rgb', type) : null;
        };
      }

      function parseHslColorComponents(text) {
        var m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);

        if (!m) {
          return null;
        }

        var comps = [parseCssNumberOrAngle(m[1]), parseCssNumberOrPercentage(m[2], 100), parseCssNumberOrPercentage(m[3], 100)];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }

        return comps;
      }

      function createHslColorParser(type) {
        return function (text) {
          var comps = parseHslColorComponents(text);
          return comps ? new Color(comps, 'hsl', type) : null;
        };
      }

      function parseHslaColorComponents(text) {
        var m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);

        if (!m) {
          return null;
        }

        var comps = [parseCssNumberOrAngle(m[1]), parseCssNumberOrPercentage(m[2], 100), parseCssNumberOrPercentage(m[3], 100), parseCssNumberOrPercentage(m[4], 1)];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }

        return comps;
      }

      function createHslaColorParser(type) {
        return function (text) {
          var comps = parseHslaColorComponents(text);
          return comps ? new Color(comps, 'hsl', type) : null;
        };
      }

      function parseHexRgbColorComponents(text) {
        var mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);

        if (mRgb) {
          return [parseInt(mRgb[1] + mRgb[1], 16), parseInt(mRgb[2] + mRgb[2], 16), parseInt(mRgb[3] + mRgb[3], 16)];
        }

        var mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);

        if (mRrggbb) {
          return [parseInt(mRrggbb[1], 16), parseInt(mRrggbb[2], 16), parseInt(mRrggbb[3], 16)];
        }

        return null;
      }

      function parseHexRgbColor(text) {
        var comps = parseHexRgbColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
      }

      function parseHexRgbaColorComponents(text) {
        var mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);

        if (mRgb) {
          return [parseInt(mRgb[1] + mRgb[1], 16), parseInt(mRgb[2] + mRgb[2], 16), parseInt(mRgb[3] + mRgb[3], 16), mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)];
        }

        var mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);

        if (mRrggbb) {
          return [parseInt(mRrggbb[1], 16), parseInt(mRrggbb[2], 16), parseInt(mRrggbb[3], 16), mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)];
        }

        return null;
      }

      function parseHexRgbaColor(text) {
        var comps = parseHexRgbaColorComponents(text);
        return comps ? new Color(comps, 'rgb', 'int') : null;
      }

      function parseObjectRgbColorComponents(text) {
        var m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);

        if (!m) {
          return null;
        }

        var comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
          return null;
        }

        return comps;
      }

      function createObjectRgbColorParser(type) {
        return function (text) {
          var comps = parseObjectRgbColorComponents(text);
          return comps ? new Color(comps, 'rgb', type) : null;
        };
      }

      function parseObjectRgbaColorComponents(text) {
        var m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);

        if (!m) {
          return null;
        }

        var comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4])];

        if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
          return null;
        }

        return comps;
      }

      function createObjectRgbaColorParser(type) {
        return function (text) {
          var comps = parseObjectRgbaColorComponents(text);
          return comps ? new Color(comps, 'rgb', type) : null;
        };
      }

      var PARSER_AND_RESULT = [{
        parser: parseHexRgbColorComponents,
        result: {
          alpha: false,
          mode: 'rgb',
          notation: 'hex'
        }
      }, {
        parser: parseHexRgbaColorComponents,
        result: {
          alpha: true,
          mode: 'rgb',
          notation: 'hex'
        }
      }, {
        parser: parseFunctionalRgbColorComponents,
        result: {
          alpha: false,
          mode: 'rgb',
          notation: 'func'
        }
      }, {
        parser: parseFunctionalRgbaColorComponents,
        result: {
          alpha: true,
          mode: 'rgb',
          notation: 'func'
        }
      }, {
        parser: parseHslColorComponents,
        result: {
          alpha: false,
          mode: 'hsl',
          notation: 'func'
        }
      }, {
        parser: parseHslaColorComponents,
        result: {
          alpha: true,
          mode: 'hsl',
          notation: 'func'
        }
      }, {
        parser: parseObjectRgbColorComponents,
        result: {
          alpha: false,
          mode: 'rgb',
          notation: 'object'
        }
      }, {
        parser: parseObjectRgbaColorComponents,
        result: {
          alpha: true,
          mode: 'rgb',
          notation: 'object'
        }
      }];

      function detectStringColor(text) {
        return PARSER_AND_RESULT.reduce(function (prev, _ref2) {
          var parser = _ref2.parser,
              detection = _ref2.result;

          if (prev) {
            return prev;
          }

          return parser(text) ? detection : null;
        }, null);
      }

      function detectStringColorFormat(text) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'int';
        var r = detectStringColor(text);

        if (!r) {
          return null;
        }

        if (r.notation === 'hex' && type !== 'float') {
          return Object.assign(Object.assign({}, r), {
            type: 'int'
          });
        }

        if (r.notation === 'func') {
          return Object.assign(Object.assign({}, r), {
            type: type
          });
        }

        return null;
      }

      var TYPE_TO_PARSERS = {
        "int": [parseHexRgbColor, parseHexRgbaColor, createFunctionalRgbColorParser('int'), createFunctionalRgbaColorParser('int'), createHslColorParser('int'), createHslaColorParser('int'), createObjectRgbColorParser('int'), createObjectRgbaColorParser('int')],
        "float": [createFunctionalRgbColorParser('float'), createFunctionalRgbaColorParser('float'), createHslColorParser('float'), createHslaColorParser('float'), createObjectRgbColorParser('float'), createObjectRgbaColorParser('float')]
      };

      function createColorStringBindingReader(type) {
        var parsers = TYPE_TO_PARSERS[type];
        return function (value) {
          if (typeof value !== 'string') {
            return Color.black(type);
          }

          var result = parsers.reduce(function (prev, parser) {
            if (prev) {
              return prev;
            }

            return parser(value);
          }, null);
          return result !== null && result !== void 0 ? result : Color.black(type);
        };
      }

      function createColorStringParser(type) {
        var parsers = TYPE_TO_PARSERS[type];
        return function (value) {
          return parsers.reduce(function (prev, parser) {
            if (prev) {
              return prev;
            }

            return parser(value);
          }, null);
        };
      }

      function zerofill(comp) {
        var hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? "0".concat(hex) : hex;
      }

      function colorToHexRgbString(value) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
        var hexes = removeAlphaComponent(value.getComponents('rgb')).map(zerofill).join('');
        return "".concat(prefix).concat(hexes);
      }

      function colorToHexRgbaString(value) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
        var rgbaComps = value.getComponents('rgb');
        var hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join('');
        return "".concat(prefix).concat(hexes);
      }

      function colorToFunctionalRgbString(value, opt_type) {
        var formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        var comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map(function (comp) {
          return formatter(comp);
        });
        return "rgb(".concat(comps.join(', '), ")");
      }

      function createFunctionalRgbColorFormatter(type) {
        return function (value) {
          return colorToFunctionalRgbString(value, type);
        };
      }

      function colorToFunctionalRgbaString(value, opt_type) {
        var aFormatter = createNumberFormatter(2);
        var rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        var comps = value.getComponents('rgb', opt_type).map(function (comp, index) {
          var formatter = index === 3 ? aFormatter : rgbFormatter;
          return formatter(comp);
        });
        return "rgba(".concat(comps.join(', '), ")");
      }

      function createFunctionalRgbaColorFormatter(type) {
        return function (value) {
          return colorToFunctionalRgbaString(value, type);
        };
      }

      function colorToFunctionalHslString(value) {
        var formatters = [createNumberFormatter(0), formatPercentage, formatPercentage];
        var comps = removeAlphaComponent(value.getComponents('hsl')).map(function (comp, index) {
          return formatters[index](comp);
        });
        return "hsl(".concat(comps.join(', '), ")");
      }

      function colorToFunctionalHslaString(value) {
        var formatters = [createNumberFormatter(0), formatPercentage, formatPercentage, createNumberFormatter(2)];
        var comps = value.getComponents('hsl').map(function (comp, index) {
          return formatters[index](comp);
        });
        return "hsla(".concat(comps.join(', '), ")");
      }

      function colorToObjectRgbString(value, type) {
        var formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        var names = ['r', 'g', 'b'];
        var comps = removeAlphaComponent(value.getComponents('rgb', type)).map(function (comp, index) {
          return "".concat(names[index], ": ").concat(formatter(comp));
        });
        return "{".concat(comps.join(', '), "}");
      }

      function createObjectRgbColorFormatter(type) {
        return function (value) {
          return colorToObjectRgbString(value, type);
        };
      }

      function colorToObjectRgbaString(value, type) {
        var aFormatter = createNumberFormatter(2);
        var rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        var names = ['r', 'g', 'b', 'a'];
        var comps = value.getComponents('rgb', type).map(function (comp, index) {
          var formatter = index === 3 ? aFormatter : rgbFormatter;
          return "".concat(names[index], ": ").concat(formatter(comp));
        });
        return "{".concat(comps.join(', '), "}");
      }

      function createObjectRgbaColorFormatter(type) {
        return function (value) {
          return colorToObjectRgbaString(value, type);
        };
      }

      var FORMAT_AND_STRINGIFIERS = [{
        format: {
          alpha: false,
          mode: 'rgb',
          notation: 'hex',
          type: 'int'
        },
        stringifier: colorToHexRgbString
      }, {
        format: {
          alpha: true,
          mode: 'rgb',
          notation: 'hex',
          type: 'int'
        },
        stringifier: colorToHexRgbaString
      }, {
        format: {
          alpha: false,
          mode: 'hsl',
          notation: 'func',
          type: 'int'
        },
        stringifier: colorToFunctionalHslString
      }, {
        format: {
          alpha: true,
          mode: 'hsl',
          notation: 'func',
          type: 'int'
        },
        stringifier: colorToFunctionalHslaString
      }].concat(_toConsumableArray(['int', 'float'].reduce(function (prev, type) {
        return [].concat(_toConsumableArray(prev), [{
          format: {
            alpha: false,
            mode: 'rgb',
            notation: 'func',
            type: type
          },
          stringifier: createFunctionalRgbColorFormatter(type)
        }, {
          format: {
            alpha: true,
            mode: 'rgb',
            notation: 'func',
            type: type
          },
          stringifier: createFunctionalRgbaColorFormatter(type)
        }, {
          format: {
            alpha: false,
            mode: 'rgb',
            notation: 'object',
            type: type
          },
          stringifier: createObjectRgbColorFormatter(type)
        }, {
          format: {
            alpha: true,
            mode: 'rgb',
            notation: 'object',
            type: type
          },
          stringifier: createObjectRgbaColorFormatter(type)
        }]);
      }, [])));

      function findColorStringifier(format) {
        return FORMAT_AND_STRINGIFIERS.reduce(function (prev, fas) {
          if (prev) {
            return prev;
          }

          return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
        }, null);
      }

      var className$a = ClassName('apl');

      var APaletteView = /*#__PURE__*/function () {
        function APaletteView(doc, config) {
          _classCallCheck(this, APaletteView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on('change', this.onValueChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$a());
          config.viewProps.bindTabIndex(this.element);
          var barElem = doc.createElement('div');
          barElem.classList.add(className$a('b'));
          this.element.appendChild(barElem);
          var colorElem = doc.createElement('div');
          colorElem.classList.add(className$a('c'));
          barElem.appendChild(colorElem);
          this.colorElem_ = colorElem;
          var markerElem = doc.createElement('div');
          markerElem.classList.add(className$a('m'));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          var previewElem = doc.createElement('div');
          previewElem.classList.add(className$a('p'));
          this.markerElem_.appendChild(previewElem);
          this.previewElem_ = previewElem;
          this.update_();
        }

        _createClass(APaletteView, [{
          key: "update_",
          value: function update_() {
            var c = this.value.rawValue;
            var rgbaComps = c.getComponents('rgb');
            var leftColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], 'rgb');
            var rightColor = new Color([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], 'rgb');
            var gradientComps = ['to right', colorToFunctionalRgbaString(leftColor), colorToFunctionalRgbaString(rightColor)];
            this.colorElem_.style.background = "linear-gradient(".concat(gradientComps.join(','), ")");
            this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
            var left = mapRange(rgbaComps[3], 0, 1, 0, 100);
            this.markerElem_.style.left = "".concat(left, "%");
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return APaletteView;
      }();

      var APaletteController = /*#__PURE__*/function () {
        function APaletteController(doc, config) {
          _classCallCheck(this, APaletteController);

          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new APaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on('down', this.onPointerDown_);
          this.ptHandler_.emitter.on('move', this.onPointerMove_);
          this.ptHandler_.emitter.on('up', this.onPointerUp_);
          this.view.element.addEventListener('keydown', this.onKeyDown_);
          this.view.element.addEventListener('keyup', this.onKeyUp_);
        }

        _createClass(APaletteController, [{
          key: "handlePointerEvent_",
          value: function handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }

            var alpha = d.point.x / d.bounds.width;
            var c = this.value.rawValue;

            var _c$getComponents = c.getComponents('hsv'),
                _c$getComponents2 = _slicedToArray(_c$getComponents, 3),
                h = _c$getComponents2[0],
                s = _c$getComponents2[1],
                v = _c$getComponents2[2];

            this.value.setRawValue(new Color([h, s, v, alpha], 'hsv'), opts);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onKeyDown_",
          value: function onKeyDown_(ev) {
            var step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            var c = this.value.rawValue;

            var _c$getComponents3 = c.getComponents('hsv'),
                _c$getComponents4 = _slicedToArray(_c$getComponents3, 4),
                h = _c$getComponents4[0],
                s = _c$getComponents4[1],
                v = _c$getComponents4[2],
                a = _c$getComponents4[3];

            this.value.setRawValue(new Color([h, s, v, a + step], 'hsv'), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onKeyUp_",
          value: function onKeyUp_(ev) {
            var step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return APaletteController;
      }();

      var className$9 = ClassName('coltxt');

      function createModeSelectElement(doc) {
        var selectElem = doc.createElement('select');
        var items = [{
          text: 'RGB',
          value: 'rgb'
        }, {
          text: 'HSL',
          value: 'hsl'
        }, {
          text: 'HSV',
          value: 'hsv'
        }];
        selectElem.appendChild(items.reduce(function (frag, item) {
          var optElem = doc.createElement('option');
          optElem.textContent = item.text;
          optElem.value = item.value;
          frag.appendChild(optElem);
          return frag;
        }, doc.createDocumentFragment()));
        return selectElem;
      }

      var ColorTextView = /*#__PURE__*/function () {
        function ColorTextView(doc, config) {
          var _this33 = this;

          _classCallCheck(this, ColorTextView);

          this.element = doc.createElement('div');
          this.element.classList.add(className$9());
          var modeElem = doc.createElement('div');
          modeElem.classList.add(className$9('m'));
          this.modeElem_ = createModeSelectElement(doc);
          this.modeElem_.classList.add(className$9('ms'));
          modeElem.appendChild(this.modeSelectElement);
          var modeMarkerElem = doc.createElement('div');
          modeMarkerElem.classList.add(className$9('mm'));
          modeMarkerElem.appendChild(createSvgIconElement(doc, 'dropdown'));
          modeElem.appendChild(modeMarkerElem);
          this.element.appendChild(modeElem);
          var textsElem = doc.createElement('div');
          textsElem.classList.add(className$9('w'));
          this.element.appendChild(textsElem);
          this.textsElem_ = textsElem;
          this.textViews_ = config.textViews;
          this.applyTextViews_();
          bindValue(config.colorMode, function (mode) {
            _this33.modeElem_.value = mode;
          });
        }

        _createClass(ColorTextView, [{
          key: "modeSelectElement",
          get: function get() {
            return this.modeElem_;
          }
        }, {
          key: "textViews",
          get: function get() {
            return this.textViews_;
          },
          set: function set(textViews) {
            this.textViews_ = textViews;
            this.applyTextViews_();
          }
        }, {
          key: "applyTextViews_",
          value: function applyTextViews_() {
            var _this34 = this;

            removeChildElements(this.textsElem_);
            var doc = this.element.ownerDocument;
            this.textViews_.forEach(function (v) {
              var compElem = doc.createElement('div');
              compElem.classList.add(className$9('c'));
              compElem.appendChild(v.element);

              _this34.textsElem_.appendChild(compElem);
            });
          }
        }]);

        return ColorTextView;
      }();

      function createFormatter$2(type) {
        return createNumberFormatter(type === 'float' ? 2 : 0);
      }

      function createConstraint$5(mode, type, index) {
        var max = getColorMaxComponents(mode, type)[index];
        return new RangeConstraint({
          min: 0,
          max: max
        });
      }

      function createComponentController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? 'fst' : index === 3 - 1 ? 'lst' : 'mid',
          baseStep: getBaseStepForColor(false),
          parser: config.parser,
          props: ValueMap.fromObject({
            draggingScale: config.colorType === 'float' ? 0.01 : 1,
            formatter: createFormatter$2(config.colorType)
          }),
          value: createValue(0, {
            constraint: createConstraint$5(config.colorMode, config.colorType, index)
          }),
          viewProps: config.viewProps
        });
      }

      var ColorTextController = /*#__PURE__*/function () {
        function ColorTextController(doc, config) {
          _classCallCheck(this, ColorTextController);

          this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
          this.colorType_ = config.colorType;
          this.parser_ = config.parser;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.colorMode = createValue(this.value.rawValue.mode);
          this.ccs_ = this.createComponentControllers_(doc);
          this.view = new ColorTextView(doc, {
            colorMode: this.colorMode,
            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
          });
          this.view.modeSelectElement.addEventListener('change', this.onModeSelectChange_);
        }

        _createClass(ColorTextController, [{
          key: "createComponentControllers_",
          value: function createComponentControllers_(doc) {
            var _this35 = this;

            var cc = {
              colorMode: this.colorMode.rawValue,
              colorType: this.colorType_,
              parser: this.parser_,
              viewProps: this.viewProps
            };
            var ccs = [createComponentController(doc, cc, 0), createComponentController(doc, cc, 1), createComponentController(doc, cc, 2)];
            ccs.forEach(function (cs, index) {
              connectValues({
                primary: _this35.value,
                secondary: cs.value,
                forward: function forward(p) {
                  return p.rawValue.getComponents(_this35.colorMode.rawValue, _this35.colorType_)[index];
                },
                backward: function backward(p, s) {
                  var pickedMode = _this35.colorMode.rawValue;
                  var comps = p.rawValue.getComponents(pickedMode, _this35.colorType_);
                  comps[index] = s.rawValue;
                  return new Color(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, _this35.colorType_);
                }
              });
            });
            return ccs;
          }
        }, {
          key: "onModeSelectChange_",
          value: function onModeSelectChange_(ev) {
            var selectElem = ev.currentTarget;
            this.colorMode.rawValue = selectElem.value;
            this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
            this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view];
          }
        }]);

        return ColorTextController;
      }();

      var className$8 = ClassName('hpl');

      var HPaletteView = /*#__PURE__*/function () {
        function HPaletteView(doc, config) {
          _classCallCheck(this, HPaletteView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on('change', this.onValueChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$8());
          config.viewProps.bindTabIndex(this.element);
          var colorElem = doc.createElement('div');
          colorElem.classList.add(className$8('c'));
          this.element.appendChild(colorElem);
          var markerElem = doc.createElement('div');
          markerElem.classList.add(className$8('m'));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }

        _createClass(HPaletteView, [{
          key: "update_",
          value: function update_() {
            var c = this.value.rawValue;

            var _c$getComponents5 = c.getComponents('hsv'),
                _c$getComponents6 = _slicedToArray(_c$getComponents5, 1),
                h = _c$getComponents6[0];

            this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color([h, 100, 100], 'hsv'));
            var left = mapRange(h, 0, 360, 0, 100);
            this.markerElem_.style.left = "".concat(left, "%");
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return HPaletteView;
      }();

      var HPaletteController = /*#__PURE__*/function () {
        function HPaletteController(doc, config) {
          _classCallCheck(this, HPaletteController);

          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new HPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on('down', this.onPointerDown_);
          this.ptHandler_.emitter.on('move', this.onPointerMove_);
          this.ptHandler_.emitter.on('up', this.onPointerUp_);
          this.view.element.addEventListener('keydown', this.onKeyDown_);
          this.view.element.addEventListener('keyup', this.onKeyUp_);
        }

        _createClass(HPaletteController, [{
          key: "handlePointerEvent_",
          value: function handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }

            var hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 359);
            var c = this.value.rawValue;

            var _c$getComponents7 = c.getComponents('hsv'),
                _c$getComponents8 = _slicedToArray(_c$getComponents7, 4),
                s = _c$getComponents8[1],
                v = _c$getComponents8[2],
                a = _c$getComponents8[3];

            this.value.setRawValue(new Color([hue, s, v, a], 'hsv'), opts);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onKeyDown_",
          value: function onKeyDown_(ev) {
            var step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            var c = this.value.rawValue;

            var _c$getComponents9 = c.getComponents('hsv'),
                _c$getComponents10 = _slicedToArray(_c$getComponents9, 4),
                h = _c$getComponents10[0],
                s = _c$getComponents10[1],
                v = _c$getComponents10[2],
                a = _c$getComponents10[3];

            this.value.setRawValue(new Color([h + step, s, v, a], 'hsv'), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onKeyUp_",
          value: function onKeyUp_(ev) {
            var step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return HPaletteController;
      }();

      var className$7 = ClassName('svp');
      var CANVAS_RESOL = 64;

      var SvPaletteView = /*#__PURE__*/function () {
        function SvPaletteView(doc, config) {
          _classCallCheck(this, SvPaletteView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.value = config.value;
          this.value.emitter.on('change', this.onValueChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$7());
          config.viewProps.bindTabIndex(this.element);
          var canvasElem = doc.createElement('canvas');
          canvasElem.height = CANVAS_RESOL;
          canvasElem.width = CANVAS_RESOL;
          canvasElem.classList.add(className$7('c'));
          this.element.appendChild(canvasElem);
          this.canvasElement = canvasElem;
          var markerElem = doc.createElement('div');
          markerElem.classList.add(className$7('m'));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.update_();
        }

        _createClass(SvPaletteView, [{
          key: "update_",
          value: function update_() {
            var ctx = getCanvasContext(this.canvasElement);

            if (!ctx) {
              return;
            }

            var c = this.value.rawValue;
            var hsvComps = c.getComponents('hsv');
            var width = this.canvasElement.width;
            var height = this.canvasElement.height;
            var imgData = ctx.getImageData(0, 0, width, height);
            var data = imgData.data;

            for (var iy = 0; iy < height; iy++) {
              for (var ix = 0; ix < width; ix++) {
                var s = mapRange(ix, 0, width, 0, 100);
                var v = mapRange(iy, 0, height, 100, 0);
                var rgbComps = hsvToRgbInt(hsvComps[0], s, v);
                var i = (iy * width + ix) * 4;
                data[i] = rgbComps[0];
                data[i + 1] = rgbComps[1];
                data[i + 2] = rgbComps[2];
                data[i + 3] = 255;
              }
            }

            ctx.putImageData(imgData, 0, 0);
            var left = mapRange(hsvComps[1], 0, 100, 0, 100);
            this.markerElem_.style.left = "".concat(left, "%");
            var top = mapRange(hsvComps[2], 0, 100, 100, 0);
            this.markerElem_.style.top = "".concat(top, "%");
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return SvPaletteView;
      }();

      var SvPaletteController = /*#__PURE__*/function () {
        function SvPaletteController(doc, config) {
          _classCallCheck(this, SvPaletteController);

          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new SvPaletteView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.element);
          this.ptHandler_.emitter.on('down', this.onPointerDown_);
          this.ptHandler_.emitter.on('move', this.onPointerMove_);
          this.ptHandler_.emitter.on('up', this.onPointerUp_);
          this.view.element.addEventListener('keydown', this.onKeyDown_);
          this.view.element.addEventListener('keyup', this.onKeyUp_);
        }

        _createClass(SvPaletteController, [{
          key: "handlePointerEvent_",
          value: function handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }

            var saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
            var value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);

            var _this$value$rawValue$ = this.value.rawValue.getComponents('hsv'),
                _this$value$rawValue$2 = _slicedToArray(_this$value$rawValue$, 4),
                h = _this$value$rawValue$2[0],
                a = _this$value$rawValue$2[3];

            this.value.setRawValue(new Color([h, saturation, value, a], 'hsv'), opts);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onKeyDown_",
          value: function onKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }

            var _this$value$rawValue$3 = this.value.rawValue.getComponents('hsv'),
                _this$value$rawValue$4 = _slicedToArray(_this$value$rawValue$3, 4),
                h = _this$value$rawValue$4[0],
                s = _this$value$rawValue$4[1],
                v = _this$value$rawValue$4[2],
                a = _this$value$rawValue$4[3];

            var baseStep = getBaseStepForColor(false);
            var ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            var dv = getStepForKey(baseStep, getVerticalStepKeys(ev));

            if (ds === 0 && dv === 0) {
              return;
            }

            this.value.setRawValue(new Color([h, s + ds, v + dv, a], 'hsv'), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onKeyUp_",
          value: function onKeyUp_(ev) {
            var baseStep = getBaseStepForColor(false);
            var ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            var dv = getStepForKey(baseStep, getVerticalStepKeys(ev));

            if (ds === 0 && dv === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return SvPaletteController;
      }();

      var ColorPickerController = /*#__PURE__*/function () {
        function ColorPickerController(doc, config) {
          _classCallCheck(this, ColorPickerController);

          this.value = config.value;
          this.viewProps = config.viewProps;
          this.hPaletteC_ = new HPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.svPaletteC_ = new SvPaletteController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.alphaIcs_ = config.supportsAlpha ? {
            palette: new APaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            }),
            text: new NumberTextController(doc, {
              parser: parseNumber,
              baseStep: 0.1,
              props: ValueMap.fromObject({
                draggingScale: 0.01,
                formatter: createNumberFormatter(2)
              }),
              value: createValue(0, {
                constraint: new RangeConstraint({
                  min: 0,
                  max: 1
                })
              }),
              viewProps: this.viewProps
            })
          } : null;

          if (this.alphaIcs_) {
            connectValues({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: function forward(p) {
                return p.rawValue.getComponents()[3];
              },
              backward: function backward(p, s) {
                var comps = p.rawValue.getComponents();
                comps[3] = s.rawValue;
                return new Color(comps, p.rawValue.mode);
              }
            });
          }

          this.textC_ = new ColorTextController(doc, {
            colorType: config.colorType,
            parser: parseNumber,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorPickerView(doc, {
            alphaViews: this.alphaIcs_ ? {
              palette: this.alphaIcs_.palette.view,
              text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: config.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textView: this.textC_.view
          });
        }

        _createClass(ColorPickerController, [{
          key: "textController",
          get: function get() {
            return this.textC_;
          }
        }]);

        return ColorPickerController;
      }();

      var className$6 = ClassName('colsw');

      var ColorSwatchView = /*#__PURE__*/function () {
        function ColorSwatchView(doc, config) {
          _classCallCheck(this, ColorSwatchView);

          this.onValueChange_ = this.onValueChange_.bind(this);
          config.value.emitter.on('change', this.onValueChange_);
          this.value = config.value;
          this.element = doc.createElement('div');
          this.element.classList.add(className$6());
          config.viewProps.bindClassModifiers(this.element);
          var swatchElem = doc.createElement('div');
          swatchElem.classList.add(className$6('sw'));
          this.element.appendChild(swatchElem);
          this.swatchElem_ = swatchElem;
          var buttonElem = doc.createElement('button');
          buttonElem.classList.add(className$6('b'));
          config.viewProps.bindDisabled(buttonElem);
          this.element.appendChild(buttonElem);
          this.buttonElement = buttonElem;
          this.update_();
        }

        _createClass(ColorSwatchView, [{
          key: "update_",
          value: function update_() {
            var value = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }]);

        return ColorSwatchView;
      }();

      var ColorSwatchController = /*#__PURE__*/_createClass(function ColorSwatchController(doc, config) {
        _classCallCheck(this, ColorSwatchController);

        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new ColorSwatchView(doc, {
          value: this.value,
          viewProps: this.viewProps
        });
      });

      var ColorController = /*#__PURE__*/function () {
        function ColorController(doc, config) {
          var _this36 = this;

          _classCallCheck(this, ColorController);

          this.onButtonBlur_ = this.onButtonBlur_.bind(this);
          this.onButtonClick_ = this.onButtonClick_.bind(this);
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.swatchC_ = new ColorSwatchController(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          var buttonElem = this.swatchC_.view.buttonElement;
          buttonElem.addEventListener('blur', this.onButtonBlur_);
          buttonElem.addEventListener('click', this.onButtonClick_);
          this.textC_ = new TextController(doc, {
            parser: config.parser,
            props: ValueMap.fromObject({
              formatter: config.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new ColorView(doc, {
            foldable: this.foldable_,
            pickerLayout: config.pickerLayout
          });
          this.view.swatchElement.appendChild(this.swatchC_.view.element);
          this.view.textElement.appendChild(this.textC_.view.element);
          this.popC_ = config.pickerLayout === 'popup' ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          var pickerC = new ColorPickerController(doc, {
            colorType: config.colorType,
            supportsAlpha: config.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
          });
          pickerC.view.allFocusableElements.forEach(function (elem) {
            elem.addEventListener('blur', _this36.onPopupChildBlur_);
            elem.addEventListener('keydown', _this36.onPopupChildKeydown_);
          });
          this.pickerC_ = pickerC;

          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(pickerC.view.element);
            connectValues({
              primary: this.foldable_.value('expanded'),
              secondary: this.popC_.shows,
              forward: function forward(p) {
                return p.rawValue;
              },
              backward: function backward(_, s) {
                return s.rawValue;
              }
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }

        _createClass(ColorController, [{
          key: "textController",
          get: function get() {
            return this.textC_;
          }
        }, {
          key: "onButtonBlur_",
          value: function onButtonBlur_(e) {
            if (!this.popC_) {
              return;
            }

            var elem = this.view.element;
            var nextTarget = forceCast(e.relatedTarget);

            if (!nextTarget || !elem.contains(nextTarget)) {
              this.popC_.shows.rawValue = false;
            }
          }
        }, {
          key: "onButtonClick_",
          value: function onButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));

            if (this.foldable_.get('expanded')) {
              this.pickerC_.view.allFocusableElements[0].focus();
            }
          }
        }, {
          key: "onPopupChildBlur_",
          value: function onPopupChildBlur_(ev) {
            if (!this.popC_) {
              return;
            }

            var elem = this.popC_.view.element;
            var nextTarget = findNextTarget(ev);

            if (nextTarget && elem.contains(nextTarget)) {
              return;
            }

            if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
              return;
            }

            this.popC_.shows.rawValue = false;
          }
        }, {
          key: "onPopupChildKeydown_",
          value: function onPopupChildKeydown_(ev) {
            if (this.popC_) {
              if (ev.key === 'Escape') {
                this.popC_.shows.rawValue = false;
              }
            } else if (this.view.pickerElement) {
              if (ev.key === 'Escape') {
                this.swatchC_.view.buttonElement.focus();
              }
            }
          }
        }]);

        return ColorController;
      }();

      function colorFromObject(value, opt_type) {
        if (Color.isColorObject(value)) {
          return Color.fromObject(value, opt_type);
        }

        return Color.black(opt_type);
      }

      function colorToRgbNumber(value) {
        return removeAlphaComponent(value.getComponents('rgb')).reduce(function (result, comp) {
          return result << 8 | Math.floor(comp) & 0xff;
        }, 0);
      }

      function colorToRgbaNumber(value) {
        return value.getComponents('rgb').reduce(function (result, comp, index) {
          var hex = Math.floor(index === 3 ? comp * 255 : comp) & 0xff;
          return result << 8 | hex;
        }, 0) >>> 0;
      }

      function numberToRgbColor(num) {
        return new Color([num >> 16 & 0xff, num >> 8 & 0xff, num & 0xff], 'rgb');
      }

      function numberToRgbaColor(num) {
        return new Color([num >> 24 & 0xff, num >> 16 & 0xff, num >> 8 & 0xff, mapRange(num & 0xff, 0, 255, 0, 1)], 'rgb');
      }

      function colorFromRgbNumber(value) {
        if (typeof value !== 'number') {
          return Color.black();
        }

        return numberToRgbColor(value);
      }

      function colorFromRgbaNumber(value) {
        if (typeof value !== 'number') {
          return Color.black();
        }

        return numberToRgbaColor(value);
      }

      function createColorStringWriter(format) {
        var stringify = findColorStringifier(format);
        return stringify ? function (target, value) {
          writePrimitive(target, stringify(value));
        } : null;
      }

      function createColorNumberWriter(supportsAlpha) {
        var colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
        return function (target, value) {
          writePrimitive(target, colorToNumber(value));
        };
      }

      function writeRgbaColorObject(target, value, opt_type) {
        var obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
        target.writeProperty('a', obj.a);
      }

      function writeRgbColorObject(target, value, opt_type) {
        var obj = value.toRgbaObject(opt_type);
        target.writeProperty('r', obj.r);
        target.writeProperty('g', obj.g);
        target.writeProperty('b', obj.b);
      }

      function createColorObjectWriter(supportsAlpha, opt_type) {
        return function (target, inValue) {
          if (supportsAlpha) {
            writeRgbaColorObject(target, inValue, opt_type);
          } else {
            writeRgbColorObject(target, inValue, opt_type);
          }
        };
      }

      function shouldSupportAlpha$1(inputParams) {
        var _a;

        if ((inputParams === null || inputParams === void 0 ? void 0 : inputParams.alpha) || ((_a = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a === void 0 ? void 0 : _a.alpha)) {
          return true;
        }

        return false;
      }

      function createFormatter$1(supportsAlpha) {
        return supportsAlpha ? function (v) {
          return colorToHexRgbaString(v, '0x');
        } : function (v) {
          return colorToHexRgbString(v, '0x');
        };
      }

      function isForColor(params) {
        if ('color' in params) {
          return true;
        }

        if ('view' in params && params.view === 'color') {
          return true;
        }

        return false;
      }

      var NumberColorInputPlugin = {
        id: 'input-color-number',
        type: 'input',
        accept: function accept(value, params) {
          if (typeof value !== 'number') {
            return null;
          }

          if (!isForColor(params)) {
            return null;
          }

          var result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(args) {
            return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
          },
          equals: Color.equals,
          writer: function writer(args) {
            return createColorNumberWriter(shouldSupportAlpha$1(args.params));
          }
        },
        controller: function controller(args) {
          var supportsAlpha = shouldSupportAlpha$1(args.params);
          var expanded = 'expanded' in args.params ? args.params.expanded : undefined;
          var picker = 'picker' in args.params ? args.params.picker : undefined;
          return new ColorController(args.document, {
            colorType: 'int',
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createFormatter$1(supportsAlpha),
            parser: createColorStringParser('int'),
            pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
            supportsAlpha: supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };

      function shouldSupportAlpha(initialValue) {
        return Color.isRgbaColorObject(initialValue);
      }

      function createColorObjectReader(opt_type) {
        return function (value) {
          return colorFromObject(value, opt_type);
        };
      }

      function createColorObjectFormatter(supportsAlpha, type) {
        return function (value) {
          if (supportsAlpha) {
            return colorToObjectRgbaString(value, type);
          }

          return colorToObjectRgbString(value, type);
        };
      }

      var ObjectColorInputPlugin = {
        id: 'input-color-object',
        type: 'input',
        accept: function accept(value, params) {
          if (!Color.isColorObject(value)) {
            return null;
          }

          var result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(args) {
            return createColorObjectReader(extractColorType(args.params));
          },
          equals: Color.equals,
          writer: function writer(args) {
            return createColorObjectWriter(shouldSupportAlpha(args.initialValue), extractColorType(args.params));
          }
        },
        controller: function controller(args) {
          var _a;

          var supportsAlpha = Color.isRgbaColorObject(args.initialValue);
          var expanded = 'expanded' in args.params ? args.params.expanded : undefined;
          var picker = 'picker' in args.params ? args.params.picker : undefined;
          var type = (_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int';
          return new ColorController(args.document, {
            colorType: type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: createColorObjectFormatter(supportsAlpha, type),
            parser: createColorStringParser(type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
            supportsAlpha: supportsAlpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      var StringColorInputPlugin = {
        id: 'input-color-string',
        type: 'input',
        accept: function accept(value, params) {
          if (typeof value !== 'string') {
            return null;
          }

          if ('view' in params && params.view === 'text') {
            return null;
          }

          var format = detectStringColorFormat(value, extractColorType(params));

          if (!format) {
            return null;
          }

          var stringifier = findColorStringifier(format);

          if (!stringifier) {
            return null;
          }

          var result = parseColorInputParams(params);
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(args) {
            var _a;

            return createColorStringBindingReader((_a = extractColorType(args.params)) !== null && _a !== void 0 ? _a : 'int');
          },
          equals: Color.equals,
          writer: function writer(args) {
            var format = detectStringColorFormat(args.initialValue, extractColorType(args.params));

            if (!format) {
              throw TpError.shouldNeverHappen();
            }

            var writer = createColorStringWriter(format);

            if (!writer) {
              throw TpError.notBindable();
            }

            return writer;
          }
        },
        controller: function controller(args) {
          var format = detectStringColorFormat(args.initialValue, extractColorType(args.params));

          if (!format) {
            throw TpError.shouldNeverHappen();
          }

          var stringifier = findColorStringifier(format);

          if (!stringifier) {
            throw TpError.shouldNeverHappen();
          }

          var expanded = 'expanded' in args.params ? args.params.expanded : undefined;
          var picker = 'picker' in args.params ? args.params.picker : undefined;
          return new ColorController(args.document, {
            colorType: format.type,
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            formatter: stringifier,
            parser: createColorStringParser(format.type),
            pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
            supportsAlpha: format.alpha,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };

      var PointNdConstraint = /*#__PURE__*/function () {
        function PointNdConstraint(config) {
          _classCallCheck(this, PointNdConstraint);

          this.components = config.components;
          this.asm_ = config.assembly;
        }

        _createClass(PointNdConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var _this37 = this;

            var comps = this.asm_.toComponents(value).map(function (comp, index) {
              var _a, _b;

              return (_b = (_a = _this37.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
            });
            return this.asm_.fromComponents(comps);
          }
        }]);

        return PointNdConstraint;
      }();

      var className$5 = ClassName('pndtxt');

      var PointNdTextView = /*#__PURE__*/_createClass(function PointNdTextView(doc, config) {
        var _this38 = this;

        _classCallCheck(this, PointNdTextView);

        this.textViews = config.textViews;
        this.element = doc.createElement('div');
        this.element.classList.add(className$5());
        this.textViews.forEach(function (v) {
          var axisElem = doc.createElement('div');
          axisElem.classList.add(className$5('a'));
          axisElem.appendChild(v.element);

          _this38.element.appendChild(axisElem);
        });
      });

      function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? 'fst' : index === config.axes.length - 1 ? 'lst' : 'mid',
          baseStep: config.axes[index].baseStep,
          parser: config.parser,
          props: config.axes[index].textProps,
          value: createValue(0, {
            constraint: config.axes[index].constraint
          }),
          viewProps: config.viewProps
        });
      }

      var PointNdTextController = /*#__PURE__*/_createClass(function PointNdTextController(doc, config) {
        var _this39 = this;

        _classCallCheck(this, PointNdTextController);

        this.value = config.value;
        this.viewProps = config.viewProps;
        this.acs_ = config.axes.map(function (_, index) {
          return createAxisController(doc, config, index);
        });
        this.acs_.forEach(function (c, index) {
          connectValues({
            primary: _this39.value,
            secondary: c.value,
            forward: function forward(p) {
              return config.assembly.toComponents(p.rawValue)[index];
            },
            backward: function backward(p, s) {
              var comps = config.assembly.toComponents(p.rawValue);
              comps[index] = s.rawValue;
              return config.assembly.fromComponents(comps);
            }
          });
        });
        this.view = new PointNdTextView(doc, {
          textViews: this.acs_.map(function (ac) {
            return ac.view;
          })
        });
      });

      function createStepConstraint(params, initialValue) {
        if ('step' in params && !isEmpty(params.step)) {
          return new StepConstraint(params.step, initialValue);
        }

        return null;
      }

      function createRangeConstraint(params) {
        if ('max' in params && !isEmpty(params.max) || 'min' in params && !isEmpty(params.min)) {
          return new RangeConstraint({
            max: params.max,
            min: params.min
          });
        }

        return null;
      }

      function createConstraint$4(params, initialValue) {
        var constraints = [];
        var sc = createStepConstraint(params, initialValue);

        if (sc) {
          constraints.push(sc);
        }

        var rc = createRangeConstraint(params);

        if (rc) {
          constraints.push(rc);
        }

        var lc = createListConstraint(params.options);

        if (lc) {
          constraints.push(lc);
        }

        return new CompositeConstraint(constraints);
      }

      function findRange(constraint) {
        var c = constraint ? findConstraint(constraint, RangeConstraint) : null;

        if (!c) {
          return [undefined, undefined];
        }

        return [c.minValue, c.maxValue];
      }

      function estimateSuitableRange(constraint) {
        var _findRange = findRange(constraint),
            _findRange2 = _slicedToArray(_findRange, 2),
            min = _findRange2[0],
            max = _findRange2[1];

        return [min !== null && min !== void 0 ? min : 0, max !== null && max !== void 0 ? max : 100];
      }

      var NumberInputPlugin = {
        id: 'input-number',
        type: 'input',
        accept: function accept(value, params) {
          if (typeof value !== 'number') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            format: p.optional["function"],
            max: p.optional.number,
            min: p.optional.number,
            options: p.optional.custom(parseListOptions),
            step: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return numberFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint$4(args.params, args.initialValue);
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        },
        controller: function controller(args) {
          var _a, _b;

          var value = args.value;
          var c = args.constraint;

          if (c && findConstraint(c, ListConstraint)) {
            return new ListController(args.document, {
              props: ValueMap.fromObject({
                options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
              }),
              value: value,
              viewProps: args.viewProps
            });
          }

          var formatter = (_b = 'format' in args.params ? args.params.format : undefined) !== null && _b !== void 0 ? _b : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));

          if (c && findConstraint(c, RangeConstraint)) {
            var _estimateSuitableRang = estimateSuitableRange(c),
                _estimateSuitableRang2 = _slicedToArray(_estimateSuitableRang, 2),
                min = _estimateSuitableRang2[0],
                max = _estimateSuitableRang2[1];

            return new SliderTextController(args.document, {
              baseStep: getBaseStep(c),
              parser: parseNumber,
              sliderProps: ValueMap.fromObject({
                maxValue: max,
                minValue: min
              }),
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c, value.rawValue),
                formatter: formatter
              }),
              value: value,
              viewProps: args.viewProps
            });
          }

          return new NumberTextController(args.document, {
            baseStep: getBaseStep(c),
            parser: parseNumber,
            props: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(c, value.rawValue),
              formatter: formatter
            }),
            value: value,
            viewProps: args.viewProps
          });
        }
      };

      var Point2d = /*#__PURE__*/function () {
        function Point2d() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _classCallCheck(this, Point2d);

          this.x = x;
          this.y = y;
        }

        _createClass(Point2d, [{
          key: "getComponents",
          value: function getComponents() {
            return [this.x, this.y];
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return {
              x: this.x,
              y: this.y
            };
          }
        }], [{
          key: "isObject",
          value: function isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }

            var x = obj.x;
            var y = obj.y;

            if (typeof x !== 'number' || typeof y !== 'number') {
              return false;
            }

            return true;
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y;
          }
        }]);

        return Point2d;
      }();

      var Point2dAssembly = {
        toComponents: function toComponents(p) {
          return p.getComponents();
        },
        fromComponents: function fromComponents(comps) {
          return _construct(Point2d, _toConsumableArray(comps));
        }
      };
      var className$4 = ClassName('p2d');

      var Point2dView = /*#__PURE__*/_createClass(function Point2dView(doc, config) {
        _classCallCheck(this, Point2dView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$4());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.expanded, valueToClassName(this.element, className$4(undefined, 'expanded')));
        var headElem = doc.createElement('div');
        headElem.classList.add(className$4('h'));
        this.element.appendChild(headElem);
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(className$4('b'));
        buttonElem.appendChild(createSvgIconElement(doc, 'p2dpad'));
        config.viewProps.bindDisabled(buttonElem);
        headElem.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var textElem = doc.createElement('div');
        textElem.classList.add(className$4('t'));
        headElem.appendChild(textElem);
        this.textElement = textElem;

        if (config.pickerLayout === 'inline') {
          var pickerElem = doc.createElement('div');
          pickerElem.classList.add(className$4('p'));
          this.element.appendChild(pickerElem);
          this.pickerElement = pickerElem;
        } else {
          this.pickerElement = null;
        }
      });

      var className$3 = ClassName('p2dp');

      var Point2dPickerView = /*#__PURE__*/function () {
        function Point2dPickerView(doc, config) {
          _classCallCheck(this, Point2dPickerView);

          this.onFoldableChange_ = this.onFoldableChange_.bind(this);
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.invertsY_ = config.invertsY;
          this.maxValue_ = config.maxValue;
          this.element = doc.createElement('div');
          this.element.classList.add(className$3());

          if (config.layout === 'popup') {
            this.element.classList.add(className$3(undefined, 'p'));
          }

          var padElem = doc.createElement('div');
          padElem.classList.add(className$3('p'));
          config.viewProps.bindTabIndex(padElem);
          this.element.appendChild(padElem);
          this.padElement = padElem;
          var svgElem = doc.createElementNS(SVG_NS, 'svg');
          svgElem.classList.add(className$3('g'));
          this.padElement.appendChild(svgElem);
          this.svgElem_ = svgElem;
          var xAxisElem = doc.createElementNS(SVG_NS, 'line');
          xAxisElem.classList.add(className$3('ax'));
          xAxisElem.setAttributeNS(null, 'x1', '0');
          xAxisElem.setAttributeNS(null, 'y1', '50%');
          xAxisElem.setAttributeNS(null, 'x2', '100%');
          xAxisElem.setAttributeNS(null, 'y2', '50%');
          this.svgElem_.appendChild(xAxisElem);
          var yAxisElem = doc.createElementNS(SVG_NS, 'line');
          yAxisElem.classList.add(className$3('ax'));
          yAxisElem.setAttributeNS(null, 'x1', '50%');
          yAxisElem.setAttributeNS(null, 'y1', '0');
          yAxisElem.setAttributeNS(null, 'x2', '50%');
          yAxisElem.setAttributeNS(null, 'y2', '100%');
          this.svgElem_.appendChild(yAxisElem);
          var lineElem = doc.createElementNS(SVG_NS, 'line');
          lineElem.classList.add(className$3('l'));
          lineElem.setAttributeNS(null, 'x1', '50%');
          lineElem.setAttributeNS(null, 'y1', '50%');
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          var markerElem = doc.createElement('div');
          markerElem.classList.add(className$3('m'));
          this.padElement.appendChild(markerElem);
          this.markerElem_ = markerElem;
          config.value.emitter.on('change', this.onValueChange_);
          this.value = config.value;
          this.update_();
        }

        _createClass(Point2dPickerView, [{
          key: "allFocusableElements",
          get: function get() {
            return [this.padElement];
          }
        }, {
          key: "update_",
          value: function update_() {
            var _this$value$rawValue$5 = this.value.rawValue.getComponents(),
                _this$value$rawValue$6 = _slicedToArray(_this$value$rawValue$5, 2),
                x = _this$value$rawValue$6[0],
                y = _this$value$rawValue$6[1];

            var max = this.maxValue_;
            var px = mapRange(x, -max, +max, 0, 100);
            var py = mapRange(y, -max, +max, 0, 100);
            var ipy = this.invertsY_ ? 100 - py : py;
            this.lineElem_.setAttributeNS(null, 'x2', "".concat(px, "%"));
            this.lineElem_.setAttributeNS(null, 'y2', "".concat(ipy, "%"));
            this.markerElem_.style.left = "".concat(px, "%");
            this.markerElem_.style.top = "".concat(ipy, "%");
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update_();
          }
        }, {
          key: "onFoldableChange_",
          value: function onFoldableChange_() {
            this.update_();
          }
        }]);

        return Point2dPickerView;
      }();

      function computeOffset(ev, baseSteps, invertsY) {
        return [getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)), getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)];
      }

      var Point2dPickerController = /*#__PURE__*/function () {
        function Point2dPickerController(doc, config) {
          _classCallCheck(this, Point2dPickerController);

          this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
          this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.baseSteps_ = config.baseSteps;
          this.maxValue_ = config.maxValue;
          this.invertsY_ = config.invertsY;
          this.view = new Point2dPickerView(doc, {
            invertsY: this.invertsY_,
            layout: config.layout,
            maxValue: this.maxValue_,
            value: this.value,
            viewProps: this.viewProps
          });
          this.ptHandler_ = new PointerHandler(this.view.padElement);
          this.ptHandler_.emitter.on('down', this.onPointerDown_);
          this.ptHandler_.emitter.on('move', this.onPointerMove_);
          this.ptHandler_.emitter.on('up', this.onPointerUp_);
          this.view.padElement.addEventListener('keydown', this.onPadKeyDown_);
          this.view.padElement.addEventListener('keyup', this.onPadKeyUp_);
        }

        _createClass(Point2dPickerController, [{
          key: "handlePointerEvent_",
          value: function handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }

            var max = this.maxValue_;
            var px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
            var py = mapRange(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
            this.value.setRawValue(new Point2d(px, py), opts);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onPadKeyDown_",
          value: function onPadKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }

            var _computeOffset = computeOffset(ev, this.baseSteps_, this.invertsY_),
                _computeOffset2 = _slicedToArray(_computeOffset, 2),
                dx = _computeOffset2[0],
                dy = _computeOffset2[1];

            if (dx === 0 && dy === 0) {
              return;
            }

            this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPadKeyUp_",
          value: function onPadKeyUp_(ev) {
            var _computeOffset3 = computeOffset(ev, this.baseSteps_, this.invertsY_),
                _computeOffset4 = _slicedToArray(_computeOffset3, 2),
                dx = _computeOffset4[0],
                dy = _computeOffset4[1];

            if (dx === 0 && dy === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return Point2dPickerController;
      }();

      var Point2dController = /*#__PURE__*/function () {
        function Point2dController(doc, config) {
          var _this40 = this;

          _classCallCheck(this, Point2dController);

          var _a, _b;

          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
          this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = Foldable.create(config.expanded);
          this.popC_ = config.pickerLayout === 'popup' ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          var padC = new Point2dPickerController(doc, {
            baseSteps: [config.axes[0].baseStep, config.axes[1].baseStep],
            invertsY: config.invertsY,
            layout: config.pickerLayout,
            maxValue: config.maxValue,
            value: this.value,
            viewProps: this.viewProps
          });
          padC.view.allFocusableElements.forEach(function (elem) {
            elem.addEventListener('blur', _this40.onPopupChildBlur_);
            elem.addEventListener('keydown', _this40.onPopupChildKeydown_);
          });
          this.pickerC_ = padC;
          this.textC_ = new PointNdTextController(doc, {
            assembly: Point2dAssembly,
            axes: config.axes,
            parser: config.parser,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view = new Point2dView(doc, {
            expanded: this.foldable_.value('expanded'),
            pickerLayout: config.pickerLayout,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.textC_.view.element);
          (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener('blur', this.onPadButtonBlur_);
          (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener('click', this.onPadButtonClick_);

          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(this.pickerC_.view.element);
            connectValues({
              primary: this.foldable_.value('expanded'),
              secondary: this.popC_.shows,
              forward: function forward(p) {
                return p.rawValue;
              },
              backward: function backward(_, s) {
                return s.rawValue;
              }
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }

        _createClass(Point2dController, [{
          key: "onPadButtonBlur_",
          value: function onPadButtonBlur_(e) {
            if (!this.popC_) {
              return;
            }

            var elem = this.view.element;
            var nextTarget = forceCast(e.relatedTarget);

            if (!nextTarget || !elem.contains(nextTarget)) {
              this.popC_.shows.rawValue = false;
            }
          }
        }, {
          key: "onPadButtonClick_",
          value: function onPadButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));

            if (this.foldable_.get('expanded')) {
              this.pickerC_.view.allFocusableElements[0].focus();
            }
          }
        }, {
          key: "onPopupChildBlur_",
          value: function onPopupChildBlur_(ev) {
            if (!this.popC_) {
              return;
            }

            var elem = this.popC_.view.element;
            var nextTarget = findNextTarget(ev);

            if (nextTarget && elem.contains(nextTarget)) {
              return;
            }

            if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
              return;
            }

            this.popC_.shows.rawValue = false;
          }
        }, {
          key: "onPopupChildKeydown_",
          value: function onPopupChildKeydown_(ev) {
            if (this.popC_) {
              if (ev.key === 'Escape') {
                this.popC_.shows.rawValue = false;
              }
            } else if (this.view.pickerElement) {
              if (ev.key === 'Escape') {
                this.view.buttonElement.focus();
              }
            }
          }
        }]);

        return Point2dController;
      }();

      function point2dFromUnknown(value) {
        return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
      }

      function writePoint2d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
      }

      function createDimensionConstraint(params, initialValue) {
        if (!params) {
          return undefined;
        }

        var constraints = [];
        var cs = createStepConstraint(params, initialValue);

        if (cs) {
          constraints.push(cs);
        }

        var rs = createRangeConstraint(params);

        if (rs) {
          constraints.push(rs);
        }

        return new CompositeConstraint(constraints);
      }

      function createConstraint$3(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point2dAssembly,
          components: [createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x), createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y)]
        });
      }

      function getSuitableMaxDimensionValue(constraint, rawValue) {
        var _a, _b;

        var rc = constraint && findConstraint(constraint, RangeConstraint);

        if (rc) {
          return Math.max(Math.abs((_a = rc.minValue) !== null && _a !== void 0 ? _a : 0), Math.abs((_b = rc.maxValue) !== null && _b !== void 0 ? _b : 0));
        }

        var step = getBaseStep(constraint);
        return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
      }

      function getSuitableMaxValue(initialValue, constraint) {
        var xc = constraint instanceof PointNdConstraint ? constraint.components[0] : undefined;
        var yc = constraint instanceof PointNdConstraint ? constraint.components[1] : undefined;
        var xr = getSuitableMaxDimensionValue(xc, initialValue.x);
        var yr = getSuitableMaxDimensionValue(yc, initialValue.y);
        return Math.max(xr, yr);
      }

      function createAxis$2(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint: constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }

      function shouldInvertY(params) {
        if (!('y' in params)) {
          return false;
        }

        var yParams = params.y;

        if (!yParams) {
          return false;
        }

        return 'inverted' in yParams ? !!yParams.inverted : false;
      }

      var Point2dInputPlugin = {
        id: 'input-point2d',
        type: 'input',
        accept: function accept(value, params) {
          if (!Point2d.isObject(value)) {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            expanded: p.optional["boolean"],
            picker: p.optional.custom(parsePickerLayout),
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.object({
              inverted: p.optional["boolean"],
              max: p.optional.number,
              min: p.optional.number,
              step: p.optional.number
            })
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return point2dFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint$3(args.params, args.initialValue);
          },
          equals: Point2d.equals,
          writer: function writer(_args) {
            return writePoint2d;
          }
        },
        controller: function controller(args) {
          var doc = args.document;
          var value = args.value;
          var c = args.constraint;

          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }

          var expanded = 'expanded' in args.params ? args.params.expanded : undefined;
          var picker = 'picker' in args.params ? args.params.picker : undefined;
          return new Point2dController(doc, {
            axes: [createAxis$2(value.rawValue.x, c.components[0]), createAxis$2(value.rawValue.y, c.components[1])],
            expanded: expanded !== null && expanded !== void 0 ? expanded : false,
            invertsY: shouldInvertY(args.params),
            maxValue: getSuitableMaxValue(value.rawValue, c),
            parser: parseNumber,
            pickerLayout: picker !== null && picker !== void 0 ? picker : 'popup',
            value: value,
            viewProps: args.viewProps
          });
        }
      };

      var Point3d = /*#__PURE__*/function () {
        function Point3d() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          _classCallCheck(this, Point3d);

          this.x = x;
          this.y = y;
          this.z = z;
        }

        _createClass(Point3d, [{
          key: "getComponents",
          value: function getComponents() {
            return [this.x, this.y, this.z];
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z
            };
          }
        }], [{
          key: "isObject",
          value: function isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }

            var x = obj.x;
            var y = obj.y;
            var z = obj.z;

            if (typeof x !== 'number' || typeof y !== 'number' || typeof z !== 'number') {
              return false;
            }

            return true;
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
          }
        }]);

        return Point3d;
      }();

      var Point3dAssembly = {
        toComponents: function toComponents(p) {
          return p.getComponents();
        },
        fromComponents: function fromComponents(comps) {
          return _construct(Point3d, _toConsumableArray(comps));
        }
      };

      function point3dFromUnknown(value) {
        return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
      }

      function writePoint3d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
      }

      function createConstraint$2(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point3dAssembly,
          components: [createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x), createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y), createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z)]
        });
      }

      function createAxis$1(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint: constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }

      var Point3dInputPlugin = {
        id: 'input-point3d',
        type: 'input',
        accept: function accept(value, params) {
          if (!Point3d.isObject(value)) {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return point3dFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint$2(args.params, args.initialValue);
          },
          equals: Point3d.equals,
          writer: function writer(_args) {
            return writePoint3d;
          }
        },
        controller: function controller(args) {
          var value = args.value;
          var c = args.constraint;

          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }

          return new PointNdTextController(args.document, {
            assembly: Point3dAssembly,
            axes: [createAxis$1(value.rawValue.x, c.components[0]), createAxis$1(value.rawValue.y, c.components[1]), createAxis$1(value.rawValue.z, c.components[2])],
            parser: parseNumber,
            value: value,
            viewProps: args.viewProps
          });
        }
      };

      var Point4d = /*#__PURE__*/function () {
        function Point4d() {
          var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

          _classCallCheck(this, Point4d);

          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }

        _createClass(Point4d, [{
          key: "getComponents",
          value: function getComponents() {
            return [this.x, this.y, this.z, this.w];
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w
            };
          }
        }], [{
          key: "isObject",
          value: function isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }

            var x = obj.x;
            var y = obj.y;
            var z = obj.z;
            var w = obj.w;

            if (typeof x !== 'number' || typeof y !== 'number' || typeof z !== 'number' || typeof w !== 'number') {
              return false;
            }

            return true;
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
          }
        }]);

        return Point4d;
      }();

      var Point4dAssembly = {
        toComponents: function toComponents(p) {
          return p.getComponents();
        },
        fromComponents: function fromComponents(comps) {
          return _construct(Point4d, _toConsumableArray(comps));
        }
      };

      function point4dFromUnknown(value) {
        return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
      }

      function writePoint4d(target, value) {
        target.writeProperty('x', value.x);
        target.writeProperty('y', value.y);
        target.writeProperty('z', value.z);
        target.writeProperty('w', value.w);
      }

      function createConstraint$1(params, initialValue) {
        return new PointNdConstraint({
          assembly: Point4dAssembly,
          components: [createDimensionConstraint('x' in params ? params.x : undefined, initialValue.x), createDimensionConstraint('y' in params ? params.y : undefined, initialValue.y), createDimensionConstraint('z' in params ? params.z : undefined, initialValue.z), createDimensionConstraint('w' in params ? params.w : undefined, initialValue.w)]
        });
      }

      function createAxis(initialValue, constraint) {
        return {
          baseStep: getBaseStep(constraint),
          constraint: constraint,
          textProps: ValueMap.fromObject({
            draggingScale: getSuitableDraggingScale(constraint, initialValue),
            formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
          })
        };
      }

      var Point4dInputPlugin = {
        id: 'input-point4d',
        type: 'input',
        accept: function accept(value, params) {
          if (!Point4d.isObject(value)) {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            x: p.optional.custom(parsePointDimensionParams),
            y: p.optional.custom(parsePointDimensionParams),
            z: p.optional.custom(parsePointDimensionParams),
            w: p.optional.custom(parsePointDimensionParams)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return point4dFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint$1(args.params, args.initialValue);
          },
          equals: Point4d.equals,
          writer: function writer(_args) {
            return writePoint4d;
          }
        },
        controller: function controller(args) {
          var value = args.value;
          var c = args.constraint;

          if (!(c instanceof PointNdConstraint)) {
            throw TpError.shouldNeverHappen();
          }

          return new PointNdTextController(args.document, {
            assembly: Point4dAssembly,
            axes: value.rawValue.getComponents().map(function (comp, index) {
              return createAxis(comp, c.components[index]);
            }),
            parser: parseNumber,
            value: value,
            viewProps: args.viewProps
          });
        }
      };

      function createConstraint(params) {
        var constraints = [];
        var lc = createListConstraint(params.options);

        if (lc) {
          constraints.push(lc);
        }

        return new CompositeConstraint(constraints);
      }

      var StringInputPlugin = {
        id: 'input-string',
        type: 'input',
        accept: function accept(value, params) {
          if (typeof value !== 'string') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            options: p.optional.custom(parseListOptions)
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return stringFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint(args.params);
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        },
        controller: function controller(args) {
          var _a;

          var doc = args.document;
          var value = args.value;
          var c = args.constraint;

          if (c && findConstraint(c, ListConstraint)) {
            return new ListController(doc, {
              props: ValueMap.fromObject({
                options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
              }),
              value: value,
              viewProps: args.viewProps
            });
          }

          return new TextController(doc, {
            parser: function parser(v) {
              return v;
            },
            props: ValueMap.fromObject({
              formatter: formatString
            }),
            value: value,
            viewProps: args.viewProps
          });
        }
      };
      var Constants = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      };
      var className$2 = ClassName('mll');

      var MultiLogView = /*#__PURE__*/function () {
        function MultiLogView(doc, config) {
          _classCallCheck(this, MultiLogView);

          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement('div');
          this.element.classList.add(className$2());
          config.viewProps.bindClassModifiers(this.element);
          var textareaElem = doc.createElement('textarea');
          textareaElem.classList.add(className$2('i'));
          textareaElem.style.height = "calc(var(--bld-us) * ".concat(config.lineCount, ")");
          textareaElem.readOnly = true;
          config.viewProps.bindDisabled(textareaElem);
          this.element.appendChild(textareaElem);
          this.textareaElem_ = textareaElem;
          config.value.emitter.on('change', this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }

        _createClass(MultiLogView, [{
          key: "update_",
          value: function update_() {
            var _this41 = this;

            var elem = this.textareaElem_;
            var shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
            var lines = [];
            this.value.rawValue.forEach(function (value) {
              if (value !== undefined) {
                lines.push(_this41.formatter_(value));
              }
            });
            elem.textContent = lines.join('\n');

            if (shouldScroll) {
              elem.scrollTop = elem.scrollHeight;
            }
          }
        }, {
          key: "onValueUpdate_",
          value: function onValueUpdate_() {
            this.update_();
          }
        }]);

        return MultiLogView;
      }();

      var MultiLogController = /*#__PURE__*/_createClass(function MultiLogController(doc, config) {
        _classCallCheck(this, MultiLogController);

        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new MultiLogView(doc, {
          formatter: config.formatter,
          lineCount: config.lineCount,
          value: this.value,
          viewProps: this.viewProps
        });
      });

      var className$1 = ClassName('sgl');

      var SingleLogView = /*#__PURE__*/function () {
        function SingleLogView(doc, config) {
          _classCallCheck(this, SingleLogView);

          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.formatter_ = config.formatter;
          this.element = doc.createElement('div');
          this.element.classList.add(className$1());
          config.viewProps.bindClassModifiers(this.element);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$1('i'));
          inputElem.readOnly = true;
          inputElem.type = 'text';
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on('change', this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }

        _createClass(SingleLogView, [{
          key: "update_",
          value: function update_() {
            var values = this.value.rawValue;
            var lastValue = values[values.length - 1];
            this.inputElement.value = lastValue !== undefined ? this.formatter_(lastValue) : '';
          }
        }, {
          key: "onValueUpdate_",
          value: function onValueUpdate_() {
            this.update_();
          }
        }]);

        return SingleLogView;
      }();

      var SingleLogController = /*#__PURE__*/_createClass(function SingleLogController(doc, config) {
        _classCallCheck(this, SingleLogController);

        this.value = config.value;
        this.viewProps = config.viewProps;
        this.view = new SingleLogView(doc, {
          formatter: config.formatter,
          value: this.value,
          viewProps: this.viewProps
        });
      });

      var BooleanMonitorPlugin = {
        id: 'monitor-bool',
        type: 'monitor',
        accept: function accept(value, params) {
          if (typeof value !== 'boolean') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            lineCount: p.optional.number
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return boolFromUnknown;
          }
        },
        controller: function controller(args) {
          var _a;

          if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
              formatter: BooleanFormatter,
              value: args.value,
              viewProps: args.viewProps
            });
          }

          return new MultiLogController(args.document, {
            formatter: BooleanFormatter,
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps
          });
        }
      };
      var className = ClassName('grl');

      var GraphLogView = /*#__PURE__*/function () {
        function GraphLogView(doc, config) {
          _classCallCheck(this, GraphLogView);

          this.onCursorChange_ = this.onCursorChange_.bind(this);
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className());
          config.viewProps.bindClassModifiers(this.element);
          this.formatter_ = config.formatter;
          this.props_ = config.props;
          this.cursor_ = config.cursor;
          this.cursor_.emitter.on('change', this.onCursorChange_);
          var svgElem = doc.createElementNS(SVG_NS, 'svg');
          svgElem.classList.add(className('g'));
          svgElem.style.height = "calc(var(--bld-us) * ".concat(config.lineCount, ")");
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          var lineElem = doc.createElementNS(SVG_NS, 'polyline');
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          var tooltipElem = doc.createElement('div');
          tooltipElem.classList.add(className('t'), ClassName('tt')());
          this.element.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on('change', this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }

        _createClass(GraphLogView, [{
          key: "graphElement",
          get: function get() {
            return this.svgElem_;
          }
        }, {
          key: "update_",
          value: function update_() {
            var bounds = this.svgElem_.getBoundingClientRect();
            var maxIndex = this.value.rawValue.length - 1;
            var min = this.props_.get('minValue');
            var max = this.props_.get('maxValue');
            var points = [];
            this.value.rawValue.forEach(function (v, index) {
              if (v === undefined) {
                return;
              }

              var x = mapRange(index, 0, maxIndex, 0, bounds.width);
              var y = mapRange(v, min, max, bounds.height, 0);
              points.push([x, y].join(','));
            });
            this.lineElem_.setAttributeNS(null, 'points', points.join(' '));
            var tooltipElem = this.tooltipElem_;
            var value = this.value.rawValue[this.cursor_.rawValue];

            if (value === undefined) {
              tooltipElem.classList.remove(className('t', 'a'));
              return;
            }

            var tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
            var ty = mapRange(value, min, max, bounds.height, 0);
            tooltipElem.style.left = "".concat(tx, "px");
            tooltipElem.style.top = "".concat(ty, "px");
            tooltipElem.textContent = "".concat(this.formatter_(value));

            if (!tooltipElem.classList.contains(className('t', 'a'))) {
              tooltipElem.classList.add(className('t', 'a'), className('t', 'in'));
              forceReflow(tooltipElem);
              tooltipElem.classList.remove(className('t', 'in'));
            }
          }
        }, {
          key: "onValueUpdate_",
          value: function onValueUpdate_() {
            this.update_();
          }
        }, {
          key: "onCursorChange_",
          value: function onCursorChange_() {
            this.update_();
          }
        }]);

        return GraphLogView;
      }();

      var GraphLogController = /*#__PURE__*/function () {
        function GraphLogController(doc, config) {
          _classCallCheck(this, GraphLogController);

          this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
          this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
          this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
          this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
          this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
          this.props_ = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.cursor_ = createValue(-1);
          this.view = new GraphLogView(doc, {
            cursor: this.cursor_,
            formatter: config.formatter,
            lineCount: config.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          });

          if (!supportsTouch(doc)) {
            this.view.element.addEventListener('mousemove', this.onGraphMouseMove_);
            this.view.element.addEventListener('mouseleave', this.onGraphMouseLeave_);
          } else {
            var ph = new PointerHandler(this.view.element);
            ph.emitter.on('down', this.onGraphPointerDown_);
            ph.emitter.on('move', this.onGraphPointerMove_);
            ph.emitter.on('up', this.onGraphPointerUp_);
          }
        }

        _createClass(GraphLogController, [{
          key: "onGraphMouseLeave_",
          value: function onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
          }
        }, {
          key: "onGraphMouseMove_",
          value: function onGraphMouseMove_(ev) {
            var bounds = this.view.element.getBoundingClientRect();
            this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
          }
        }, {
          key: "onGraphPointerDown_",
          value: function onGraphPointerDown_(ev) {
            this.onGraphPointerMove_(ev);
          }
        }, {
          key: "onGraphPointerMove_",
          value: function onGraphPointerMove_(ev) {
            if (!ev.data.point) {
              this.cursor_.rawValue = -1;
              return;
            }

            this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
          }
        }, {
          key: "onGraphPointerUp_",
          value: function onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
          }
        }]);

        return GraphLogController;
      }();

      function createFormatter(params) {
        return 'format' in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
      }

      function createTextMonitor(args) {
        var _a;

        if (args.value.rawValue.length === 1) {
          return new SingleLogController(args.document, {
            formatter: createFormatter(args.params),
            value: args.value,
            viewProps: args.viewProps
          });
        }

        return new MultiLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
          value: args.value,
          viewProps: args.viewProps
        });
      }

      function createGraphMonitor(args) {
        var _a, _b, _c;

        return new GraphLogController(args.document, {
          formatter: createFormatter(args.params),
          lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
          props: ValueMap.fromObject({
            maxValue: (_b = 'max' in args.params ? args.params.max : null) !== null && _b !== void 0 ? _b : 100,
            minValue: (_c = 'min' in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0
          }),
          value: args.value,
          viewProps: args.viewProps
        });
      }

      function shouldShowGraph(params) {
        return 'view' in params && params.view === 'graph';
      }

      var NumberMonitorPlugin = {
        id: 'monitor-number',
        type: 'monitor',
        accept: function accept(value, params) {
          if (typeof value !== 'number') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            format: p.optional["function"],
            lineCount: p.optional.number,
            max: p.optional.number,
            min: p.optional.number,
            view: p.optional.string
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          defaultBufferSize: function defaultBufferSize(params) {
            return shouldShowGraph(params) ? 64 : 1;
          },
          reader: function reader(_args) {
            return numberFromUnknown;
          }
        },
        controller: function controller(args) {
          if (shouldShowGraph(args.params)) {
            return createGraphMonitor(args);
          }

          return createTextMonitor(args);
        }
      };
      var StringMonitorPlugin = {
        id: 'monitor-string',
        type: 'monitor',
        accept: function accept(value, params) {
          if (typeof value !== 'string') {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            lineCount: p.optional.number,
            multiline: p.optional["boolean"]
          });
          return result ? {
            initialValue: value,
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return stringFromUnknown;
          }
        },
        controller: function controller(args) {
          var _a;

          var value = args.value;
          var multiline = value.rawValue.length > 1 || 'multiline' in args.params && args.params.multiline;

          if (multiline) {
            return new MultiLogController(args.document, {
              formatter: formatString,
              lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
              value: value,
              viewProps: args.viewProps
            });
          }

          return new SingleLogController(args.document, {
            formatter: formatString,
            value: value,
            viewProps: args.viewProps
          });
        }
      };

      var InputBinding = /*#__PURE__*/function () {
        function InputBinding(config) {
          _classCallCheck(this, InputBinding);

          this.onValueChange_ = this.onValueChange_.bind(this);
          this.reader = config.reader;
          this.writer = config.writer;
          this.emitter = new Emitter();
          this.value = config.value;
          this.value.emitter.on('change', this.onValueChange_);
          this.target = config.target;
          this.read();
        }

        _createClass(InputBinding, [{
          key: "read",
          value: function read() {
            var targetValue = this.target.read();

            if (targetValue !== undefined) {
              this.value.rawValue = this.reader(targetValue);
            }
          }
        }, {
          key: "write_",
          value: function write_(rawValue) {
            this.writer(this.target, rawValue);
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_(ev) {
            this.write_(ev.rawValue);
            this.emitter.emit('change', {
              options: ev.options,
              rawValue: ev.rawValue,
              sender: this
            });
          }
        }]);

        return InputBinding;
      }();

      function createInputBindingController(plugin, args) {
        var result = plugin.accept(args.target.read(), args.params);

        if (isEmpty(result)) {
          return null;
        }

        var p = ParamsParsers;
        var valueArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        var reader = plugin.binding.reader(valueArgs);
        var constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : undefined;
        var value = createValue(reader(result.initialValue), {
          constraint: constraint,
          equals: plugin.binding.equals
        });
        var binding = new InputBinding({
          reader: reader,
          target: args.target,
          value: value,
          writer: plugin.binding.writer(valueArgs)
        });
        var disabled = p.optional["boolean"](args.params.disabled).value;
        var hidden = p.optional["boolean"](args.params.hidden).value;
        var controller = plugin.controller({
          constraint: constraint,
          document: args.document,
          initialValue: result.initialValue,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled: disabled,
            hidden: hidden
          })
        });
        var label = p.optional.string(args.params.label).value;
        return new InputBindingController(args.document, {
          binding: binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: label !== null && label !== void 0 ? label : args.target.key
          }),
          valueController: controller
        });
      }

      var MonitorBinding = /*#__PURE__*/function () {
        function MonitorBinding(config) {
          _classCallCheck(this, MonitorBinding);

          this.onTick_ = this.onTick_.bind(this);
          this.reader_ = config.reader;
          this.target = config.target;
          this.emitter = new Emitter();
          this.value = config.value;
          this.ticker = config.ticker;
          this.ticker.emitter.on('tick', this.onTick_);
          this.read();
        }

        _createClass(MonitorBinding, [{
          key: "dispose",
          value: function dispose() {
            this.ticker.dispose();
          }
        }, {
          key: "read",
          value: function read() {
            var targetValue = this.target.read();

            if (targetValue === undefined) {
              return;
            }

            var buffer = this.value.rawValue;
            var newValue = this.reader_(targetValue);
            this.value.rawValue = createPushedBuffer(buffer, newValue);
            this.emitter.emit('update', {
              rawValue: newValue,
              sender: this
            });
          }
        }, {
          key: "onTick_",
          value: function onTick_(_) {
            this.read();
          }
        }]);

        return MonitorBinding;
      }();

      function createTicker(document, interval) {
        return interval === 0 ? new ManualTicker() : new IntervalTicker(document, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
      }

      function createMonitorBindingController(plugin, args) {
        var _a, _b, _c;

        var P = ParamsParsers;
        var result = plugin.accept(args.target.read(), args.params);

        if (isEmpty(result)) {
          return null;
        }

        var bindingArgs = {
          target: args.target,
          initialValue: result.initialValue,
          params: result.params
        };
        var reader = plugin.binding.reader(bindingArgs);
        var bufferSize = (_b = (_a = P.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
        var interval = P.optional.number(args.params.interval).value;
        var binding = new MonitorBinding({
          reader: reader,
          target: args.target,
          ticker: createTicker(args.document, interval),
          value: initializeBuffer(bufferSize)
        });
        var disabled = P.optional["boolean"](args.params.disabled).value;
        var hidden = P.optional["boolean"](args.params.hidden).value;
        var controller = plugin.controller({
          document: args.document,
          params: result.params,
          value: binding.value,
          viewProps: ViewProps.create({
            disabled: disabled,
            hidden: hidden
          })
        });
        var label = (_c = P.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : args.target.key;
        return new MonitorBindingController(args.document, {
          binding: binding,
          blade: createBlade(),
          props: ValueMap.fromObject({
            label: label
          }),
          valueController: controller
        });
      }

      var PluginPool = /*#__PURE__*/function () {
        function PluginPool() {
          _classCallCheck(this, PluginPool);

          this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
          };
        }

        _createClass(PluginPool, [{
          key: "getAll",
          value: function getAll() {
            return [].concat(_toConsumableArray(this.pluginsMap_.blades), _toConsumableArray(this.pluginsMap_.inputs), _toConsumableArray(this.pluginsMap_.monitors));
          }
        }, {
          key: "register",
          value: function register(r) {
            if (r.type === 'blade') {
              this.pluginsMap_.blades.unshift(r);
            } else if (r.type === 'input') {
              this.pluginsMap_.inputs.unshift(r);
            } else if (r.type === 'monitor') {
              this.pluginsMap_.monitors.unshift(r);
            }
          }
        }, {
          key: "createInput",
          value: function createInput(document, target, params) {
            var initialValue = target.read();

            if (isEmpty(initialValue)) {
              throw new TpError({
                context: {
                  key: target.key
                },
                type: 'nomatchingcontroller'
              });
            }

            var bc = this.pluginsMap_.inputs.reduce(function (result, plugin) {
              return result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
                document: document,
                target: target,
                params: params
              });
            }, null);

            if (bc) {
              return bc;
            }

            throw new TpError({
              context: {
                key: target.key
              },
              type: 'nomatchingcontroller'
            });
          }
        }, {
          key: "createMonitor",
          value: function createMonitor(document, target, params) {
            var bc = this.pluginsMap_.monitors.reduce(function (result, plugin) {
              return result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
                document: document,
                params: params,
                target: target
              });
            }, null);

            if (bc) {
              return bc;
            }

            throw new TpError({
              context: {
                key: target.key
              },
              type: 'nomatchingcontroller'
            });
          }
        }, {
          key: "createBlade",
          value: function createBlade(document, params) {
            var bc = this.pluginsMap_.blades.reduce(function (result, plugin) {
              return result !== null && result !== void 0 ? result : createBladeController(plugin, {
                document: document,
                params: params
              });
            }, null);

            if (!bc) {
              throw new TpError({
                type: 'nomatchingview',
                context: {
                  params: params
                }
              });
            }

            return bc;
          }
        }, {
          key: "createBladeApi",
          value: function createBladeApi(bc) {
            var _this42 = this;

            if (bc instanceof InputBindingController) {
              return new InputBindingApi(bc);
            }

            if (bc instanceof MonitorBindingController) {
              return new MonitorBindingApi(bc);
            }

            if (bc instanceof RackController) {
              return new RackApi(bc, this);
            }

            var api = this.pluginsMap_.blades.reduce(function (result, plugin) {
              return result !== null && result !== void 0 ? result : plugin.api({
                controller: bc,
                pool: _this42
              });
            }, null);

            if (!api) {
              throw TpError.shouldNeverHappen();
            }

            return api;
          }
        }]);

        return PluginPool;
      }();

      function createDefaultPluginPool() {
        var pool = new PluginPool();
        [Point2dInputPlugin, Point3dInputPlugin, Point4dInputPlugin, StringInputPlugin, NumberInputPlugin, StringColorInputPlugin, ObjectColorInputPlugin, NumberColorInputPlugin, BooleanInputPlugin, BooleanMonitorPlugin, StringMonitorPlugin, NumberMonitorPlugin, ButtonBladePlugin, FolderBladePlugin, SeparatorBladePlugin, TabBladePlugin].forEach(function (p) {
          pool.register(p);
        });
        return pool;
      }

      var ListApi = /*#__PURE__*/function (_BladeApi7) {
        _inherits(ListApi, _BladeApi7);

        var _super25 = _createSuper(ListApi);

        function ListApi(controller) {
          var _this43;

          _classCallCheck(this, ListApi);

          _this43 = _super25.call(this, controller);
          _this43.emitter_ = new Emitter();

          _this43.controller_.valueController.value.emitter.on('change', function (ev) {
            _this43.emitter_.emit('change', {
              event: new TpChangeEvent(_assertThisInitialized(_this43), ev.rawValue)
            });
          });

          return _this43;
        }

        _createClass(ListApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "options",
          get: function get() {
            return this.controller_.valueController.props.get('options');
          },
          set: function set(options) {
            this.controller_.valueController.props.set('options', options);
          }
        }, {
          key: "value",
          get: function get() {
            return this.controller_.valueController.value.rawValue;
          },
          set: function set(value) {
            this.controller_.valueController.value.rawValue = value;
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }]);

        return ListApi;
      }(BladeApi);

      var SliderApi = /*#__PURE__*/function (_BladeApi8) {
        _inherits(SliderApi, _BladeApi8);

        var _super26 = _createSuper(SliderApi);

        function SliderApi(controller) {
          var _this44;

          _classCallCheck(this, SliderApi);

          _this44 = _super26.call(this, controller);
          _this44.emitter_ = new Emitter();

          _this44.controller_.valueController.value.emitter.on('change', function (ev) {
            _this44.emitter_.emit('change', {
              event: new TpChangeEvent(_assertThisInitialized(_this44), ev.rawValue)
            });
          });

          return _this44;
        }

        _createClass(SliderApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "maxValue",
          get: function get() {
            return this.controller_.valueController.sliderController.props.get('maxValue');
          },
          set: function set(maxValue) {
            this.controller_.valueController.sliderController.props.set('maxValue', maxValue);
          }
        }, {
          key: "minValue",
          get: function get() {
            return this.controller_.valueController.sliderController.props.get('minValue');
          },
          set: function set(minValue) {
            this.controller_.valueController.sliderController.props.set('minValue', minValue);
          }
        }, {
          key: "value",
          get: function get() {
            return this.controller_.valueController.value.rawValue;
          },
          set: function set(value) {
            this.controller_.valueController.value.rawValue = value;
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }]);

        return SliderApi;
      }(BladeApi);

      var TextApi = /*#__PURE__*/function (_BladeApi9) {
        _inherits(TextApi, _BladeApi9);

        var _super27 = _createSuper(TextApi);

        function TextApi(controller) {
          var _this45;

          _classCallCheck(this, TextApi);

          _this45 = _super27.call(this, controller);
          _this45.emitter_ = new Emitter();

          _this45.controller_.valueController.value.emitter.on('change', function (ev) {
            _this45.emitter_.emit('change', {
              event: new TpChangeEvent(_assertThisInitialized(_this45), ev.rawValue)
            });
          });

          return _this45;
        }

        _createClass(TextApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "formatter",
          get: function get() {
            return this.controller_.valueController.props.get('formatter');
          },
          set: function set(formatter) {
            this.controller_.valueController.props.set('formatter', formatter);
          }
        }, {
          key: "value",
          get: function get() {
            return this.controller_.valueController.value.rawValue;
          },
          set: function set(value) {
            this.controller_.valueController.value.rawValue = value;
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }]);

        return TextApi;
      }(BladeApi);

      var ListBladePlugin = function () {
        return {
          id: 'list',
          type: 'blade',
          accept: function accept(params) {
            var p = ParamsParsers;
            var result = parseParams(params, {
              options: p.required.custom(parseListOptions),
              value: p.required.raw,
              view: p.required.constant('list'),
              label: p.optional.string
            });
            return result ? {
              params: result
            } : null;
          },
          controller: function controller(args) {
            var ic = new ListController(args.document, {
              props: ValueMap.fromObject({
                options: normalizeListOptions(args.params.options)
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api: function api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }

            if (!(args.controller.valueController instanceof ListController)) {
              return null;
            }

            return new ListApi(args.controller);
          }
        };
      }();
      /**
       * @hidden
       */


      function exportPresetJson(targets) {
        return targets.reduce(function (result, target) {
          return Object.assign(result, _defineProperty({}, target.presetKey, target.read()));
        }, {});
      }
      /**
       * @hidden
       */


      function importPresetJson(targets, preset) {
        targets.forEach(function (target) {
          var value = preset[target.presetKey];

          if (value !== undefined) {
            target.write(value);
          }
        });
      }

      var RootApi = /*#__PURE__*/function (_FolderApi) {
        _inherits(RootApi, _FolderApi);

        var _super28 = _createSuper(RootApi);

        /**
         * @hidden
         */
        function RootApi(controller, pool) {
          _classCallCheck(this, RootApi);

          return _super28.call(this, controller, pool);
        }

        _createClass(RootApi, [{
          key: "element",
          get: function get() {
            return this.controller_.view.element;
          }
          /**
           * Imports a preset of all inputs.
           * @param preset The preset object to import.
           */

        }, {
          key: "importPreset",
          value: function importPreset(preset) {
            var targets = this.controller_.rackController.rack.find(InputBindingController).map(function (ibc) {
              return ibc.binding.target;
            });
            importPresetJson(targets, preset);
            this.refresh();
          }
          /**
           * Exports a preset of all inputs.
           * @return An exported preset object.
           */

        }, {
          key: "exportPreset",
          value: function exportPreset() {
            var targets = this.controller_.rackController.rack.find(InputBindingController).map(function (ibc) {
              return ibc.binding.target;
            });
            return exportPresetJson(targets);
          }
          /**
           * Refreshes all bindings of the pane.
           */

        }, {
          key: "refresh",
          value: function refresh() {
            // Force-read all input bindings
            this.controller_.rackController.rack.find(InputBindingController).forEach(function (ibc) {
              ibc.binding.read();
            }); // Force-read all monitor bindings

            this.controller_.rackController.rack.find(MonitorBindingController).forEach(function (mbc) {
              mbc.binding.read();
            });
          }
        }]);

        return RootApi;
      }(FolderApi);

      var RootController = /*#__PURE__*/function (_FolderController) {
        _inherits(RootController, _FolderController);

        var _super29 = _createSuper(RootController);

        function RootController(doc, config) {
          _classCallCheck(this, RootController);

          return _super29.call(this, doc, {
            expanded: config.expanded,
            blade: config.blade,
            props: config.props,
            root: true,
            viewProps: config.viewProps
          });
        }

        return _createClass(RootController);
      }(FolderController);

      var SliderBladePlugin = {
        id: 'slider',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            max: p.required.number,
            min: p.required.number,
            view: p.required.constant('slider'),
            format: p.optional["function"],
            label: p.optional.string,
            value: p.optional.number
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          var _a, _b;

          var v = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
          var vc = new SliderTextController(args.document, {
            baseStep: 1,
            parser: parseNumber,
            sliderProps: ValueMap.fromObject({
              maxValue: args.params.max,
              minValue: args.params.min
            }),
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(undefined, v),
              formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString
            }),
            value: createValue(v),
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: vc
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }

          if (!(args.controller.valueController instanceof SliderTextController)) {
            return null;
          }

          return new SliderApi(args.controller);
        }
      };

      var TextBladePlugin = function () {
        return {
          id: 'text',
          type: 'blade',
          accept: function accept(params) {
            var p = ParamsParsers;
            var result = parseParams(params, {
              parse: p.required["function"],
              value: p.required.raw,
              view: p.required.constant('text'),
              format: p.optional["function"],
              label: p.optional.string
            });
            return result ? {
              params: result
            } : null;
          },
          controller: function controller(args) {
            var _a;

            var ic = new TextController(args.document, {
              parser: args.params.parse,
              props: ValueMap.fromObject({
                formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : function (v) {
                  return String(v);
                }
              }),
              value: createValue(args.params.value),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: ic
            });
          },
          api: function api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }

            if (!(args.controller.valueController instanceof TextController)) {
              return null;
            }

            return new TextApi(args.controller);
          }
        };
      }();

      function createDefaultWrapperElement(doc) {
        var elem = doc.createElement('div');
        elem.classList.add(ClassName('dfw')());

        if (doc.body) {
          doc.body.appendChild(elem);
        }

        return elem;
      }

      function embedStyle(doc, id, css) {
        if (doc.querySelector("style[data-tp-style=".concat(id, "]"))) {
          return;
        }

        var styleElem = doc.createElement('style');
        styleElem.dataset.tpStyle = id;
        styleElem.textContent = css;
        doc.head.appendChild(styleElem);
      }
      /**
       * The root pane of Tweakpane.
       */


      var Pane = /*#__PURE__*/function (_RootApi) {
        _inherits(Pane, _RootApi);

        var _super30 = _createSuper(Pane);

        function Pane(opt_config) {
          var _this46;

          _classCallCheck(this, Pane);

          var _a, _b;

          var config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
          var doc = (_a = config.document) !== null && _a !== void 0 ? _a : getWindowDocument();
          var pool = createDefaultPluginPool();
          var rootController = new RootController(doc, {
            expanded: config.expanded,
            blade: createBlade(),
            props: ValueMap.fromObject({
              title: config.title
            }),
            viewProps: ViewProps.create()
          });
          _this46 = _super30.call(this, rootController, pool);
          _this46.pool_ = pool;
          _this46.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);

          _this46.containerElem_.appendChild(_this46.element);

          _this46.doc_ = doc;
          _this46.usesDefaultWrapper_ = !config.container;

          _this46.setUpDefaultPlugins_();

          return _this46;
        }

        _createClass(Pane, [{
          key: "document",
          get: function get() {
            if (!this.doc_) {
              throw TpError.alreadyDisposed();
            }

            return this.doc_;
          }
        }, {
          key: "dispose",
          value: function dispose() {
            var containerElem = this.containerElem_;

            if (!containerElem) {
              throw TpError.alreadyDisposed();
            }

            if (this.usesDefaultWrapper_) {
              var parentElem = containerElem.parentElement;

              if (parentElem) {
                parentElem.removeChild(containerElem);
              }
            }

            this.containerElem_ = null;
            this.doc_ = null;

            _get(_getPrototypeOf(Pane.prototype), "dispose", this).call(this);
          }
        }, {
          key: "registerPlugin",
          value: function registerPlugin(bundle) {
            var _this47 = this;

            var plugins = 'plugin' in bundle ? [bundle.plugin] : 'plugins' in bundle ? bundle.plugins : [];
            plugins.forEach(function (p) {
              _this47.pool_.register(p);

              _this47.embedPluginStyle_(p);
            });
          }
        }, {
          key: "embedPluginStyle_",
          value: function embedPluginStyle_(plugin) {
            if (plugin.css) {
              embedStyle(this.document, "plugin-".concat(plugin.id), plugin.css);
            }
          }
        }, {
          key: "setUpDefaultPlugins_",
          value: function setUpDefaultPlugins_() {
            var _this48 = this;

            // NOTE: This string literal will be replaced with the default CSS by Rollup at the compilation time
            embedStyle(this.document, 'default', '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}');
            this.pool_.getAll().forEach(function (plugin) {
              _this48.embedPluginStyle_(plugin);
            });
            this.registerPlugin({
              plugins: [SliderBladePlugin, ListBladePlugin, TabBladePlugin, TextBladePlugin]
            });
          }
        }]);

        return Pane;
      }(RootApi);

      var VERSION = new Semver('3.1.0');
      exports.BladeApi = BladeApi;
      exports.ButtonApi = ButtonApi;
      exports.FolderApi = FolderApi;
      exports.InputBindingApi = InputBindingApi;
      exports.ListApi = ListApi;
      exports.MonitorBindingApi = MonitorBindingApi;
      exports.Pane = Pane;
      exports.SeparatorApi = SeparatorApi;
      exports.SliderApi = SliderApi;
      exports.TabApi = TabApi;
      exports.TabPageApi = TabPageApi;
      exports.TextApi = TextApi;
      exports.TpChangeEvent = TpChangeEvent;
      exports.VERSION = VERSION;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(tweakpane, tweakpane.exports);

  var tweakpaneTextareaPlugin$1 = {exports: {}};

  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    })(commonjsGlobal, function (exports) {

      function forceCast(v) {
        return v;
      }

      var PREFIX = 'tp';

      function ClassName(viewName) {
        var fn = function fn(opt_elementName, opt_modifier) {
          return [PREFIX, '-', viewName, 'v', opt_elementName ? "_".concat(opt_elementName) : '', opt_modifier ? "-".concat(opt_modifier) : ''].join('');
        };

        return fn;
      }

      function parseObject(value, keyToParserMap) {
        var keys = Object.keys(keyToParserMap);
        var result = keys.reduce(function (tmp, key) {
          if (tmp === undefined) {
            return undefined;
          }

          var parser = keyToParserMap[key];
          var result = parser(value[key]);
          return result.succeeded ? Object.assign(Object.assign({}, tmp), _defineProperty({}, key, result.value)) : undefined;
        }, {});
        return forceCast(result);
      }

      function parseArray(value, parseItem) {
        return value.reduce(function (tmp, item) {
          if (tmp === undefined) {
            return undefined;
          }

          var result = parseItem(item);

          if (!result.succeeded || result.value === undefined) {
            return undefined;
          }

          return [].concat(_toConsumableArray(tmp), [result.value]);
        }, []);
      }

      function isObject(value) {
        if (value === null) {
          return false;
        }

        return _typeof$1(value) === 'object';
      }

      function createParamsParserBuilder(parse) {
        return function (optional) {
          return function (v) {
            if (!optional && v === undefined) {
              return {
                succeeded: false,
                value: undefined
              };
            }

            if (optional && v === undefined) {
              return {
                succeeded: true,
                value: undefined
              };
            }

            var result = parse(v);
            return result !== undefined ? {
              succeeded: true,
              value: result
            } : {
              succeeded: false,
              value: undefined
            };
          };
        };
      }

      function createParamsParserBuilders(optional) {
        return {
          custom: function custom(parse) {
            return createParamsParserBuilder(parse)(optional);
          },
          "boolean": createParamsParserBuilder(function (v) {
            return typeof v === 'boolean' ? v : undefined;
          })(optional),
          number: createParamsParserBuilder(function (v) {
            return typeof v === 'number' ? v : undefined;
          })(optional),
          string: createParamsParserBuilder(function (v) {
            return typeof v === 'string' ? v : undefined;
          })(optional),
          "function": createParamsParserBuilder(function (v) {
            return typeof v === 'function' ? v : undefined;
          })(optional),
          constant: function constant(value) {
            return createParamsParserBuilder(function (v) {
              return v === value ? value : undefined;
            })(optional);
          },
          raw: createParamsParserBuilder(function (v) {
            return v;
          })(optional),
          object: function object(keyToParserMap) {
            return createParamsParserBuilder(function (v) {
              if (!isObject(v)) {
                return undefined;
              }

              return parseObject(v, keyToParserMap);
            })(optional);
          },
          array: function array(itemParser) {
            return createParamsParserBuilder(function (v) {
              if (!Array.isArray(v)) {
                return undefined;
              }

              return parseArray(v, itemParser);
            })(optional);
          }
        };
      }

      var ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };

      function parseParams(value, keyToParserMap) {
        var result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
      }

      var className = ClassName('txtr');

      var TextAreaView = /*#__PURE__*/function () {
        function TextAreaView(doc, config) {
          _classCallCheck(this, TextAreaView);

          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className());
          config.viewProps.bindClassModifiers(this.element); //this.onChange_ = this.onChange_.bind(this);

          var inputElem = doc.createElement('textarea');
          inputElem.rows = config.lineCount;
          inputElem.cols = 22;
          inputElem.placeholder = config.placeholder;
          inputElem.classList.add(className('i'));
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on('change', this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }

        _createClass(TextAreaView, [{
          key: "refresh",
          value: function refresh() {
            this.inputElement.value = this.value_.rawValue;
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.refresh();
          }
        }]);

        return TextAreaView;
      }();
      /**
       * @hidden
       */


      var TextAreaController = /*#__PURE__*/function () {
        function TextAreaController(doc, config) {
          _classCallCheck(this, TextAreaController);

          this.onInputChange_ = this.onInputChange_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.lineCount = config.lineCount;
          this.placeholder = config.placeholder; // console.log( this.lineCount )

          this.view = new TextAreaView(doc, {
            value: this.value,
            viewProps: this.viewProps,
            lineCount: this.lineCount,
            placeholder: this.placeholder
          });
          this.view.inputElement.addEventListener('keyup', this.onInputChange_);
        }

        _createClass(TextAreaController, [{
          key: "onInputChange_",
          value: function onInputChange_(e) {
            //console.log( e.key )
            //if( e.key === 'Enter' ){
            var inputElem = forceCast(e.currentTarget);
            var value = inputElem.value;
            this.value.rawValue = value;
            this.view.refresh(); //}
          }
        }]);

        return TextAreaController;
      }(); // NOTE: You can see JSDoc comments of `InputBindingPlugin` for details about each property
      //
      // `InputBindingPlugin<In, Ex, P>` means...
      // - The plugin receives the bound value as `Ex`,
      // - converts `Ex` into `In` and holds it
      // - P is the type of the parsed parameters
      //


      var TweakpaneTextareaPlugin = {
        id: 'input-template',
        // type: The plugin type.
        // - 'input': Input binding
        // - 'monitor': Monitor binding
        type: 'input',
        // This plugin template injects a compiled CSS by @rollup/plugin-replace
        // See rollup.config.js for details
        css: '.tp-txtrv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-txtrv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtrv:hover{background-color:var(--in-bg-h)}.tp-txtrv:focus{background-color:var(--in-bg-f)}.tp-txtrv:active{background-color:var(--in-bg-a)}.tp-txtrv:disabled{opacity:.5}.tp-txtrv{display:block;height:auto;padding-bottom:0;overflow:hidden;position:relative}.tp-txtrv.tp-v-disabled{opacity:.5}.tp-txtrv .tp-txtrv_i{font-family:var(--font-family);background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-size:11px;padding:4px;line-height:16px;min-width:0;width:100%;border:none;height:100%;resize:none;margin-bottom:-8px}.tp-txtrv .tp-txtrv_i:focus{outline:none}',
        accept: function accept(exValue, params) {
          if (typeof exValue !== 'string') {
            // Return null to deny the user input
            return null;
          } // Parse parameters object
          // console.log(params)


          var p = ParamsParsers;
          var result = parseParams(params, {
            // `view` option may be useful to provide a custom control for primitive values
            view: p.required.constant('textarea'),
            lineCount: p.optional.number,
            placeholder: p.optional.string
          });

          if (!result) {
            return null;
          } // Return a typed value and params to accept the user input


          return {
            initialValue: exValue,
            params: result
          };
        },
        binding: {
          reader: function reader(_args) {
            return function (exValue) {
              // Convert an external unknown value into the internal value
              return typeof exValue === 'string' ? exValue : '';
            };
          },
          writer: function writer(_args) {
            return function (target, inValue) {
              // Use `target.write()` to write the primitive value to the target,
              // or `target.writeProperty()` to write a property of the target
              target.write(inValue);
            };
          }
        },
        controller: function controller(args) {
          var _a, _b; // Create a controller for the plugin


          return new TextAreaController(args.document, {
            value: args.value,
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : 3,
            placeholder: (_b = args.params.placeholder) !== null && _b !== void 0 ? _b : 'Enter text here',
            viewProps: args.viewProps
          });
        }
      }; // Export your plugin(s) as constant `plugins`

      var plugins = [TweakpaneTextareaPlugin];
      exports.plugins = plugins;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(tweakpaneTextareaPlugin$1, tweakpaneTextareaPlugin$1.exports);

  var tweakpaneTextareaPlugin = /*@__PURE__*/getDefaultExportFromCjs(tweakpaneTextareaPlugin$1.exports);

  var TextareaPlugin = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    'default': tweakpaneTextareaPlugin
  }, [tweakpaneTextareaPlugin$1.exports]);

  var tweakpanePluginEssentials$1 = {exports: {}};

  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    })(commonjsGlobal, function (exports) {

      var BladeApi = /*#__PURE__*/function () {
        function BladeApi(controller) {
          _classCallCheck(this, BladeApi);

          this.controller_ = controller;
        }

        _createClass(BladeApi, [{
          key: "element",
          get: function get() {
            return this.controller_.view.element;
          }
        }, {
          key: "disabled",
          get: function get() {
            return this.controller_.viewProps.get('disabled');
          },
          set: function set(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
          }
        }, {
          key: "hidden",
          get: function get() {
            return this.controller_.viewProps.get('hidden');
          },
          set: function set(hidden) {
            this.controller_.viewProps.set('hidden', hidden);
          }
        }, {
          key: "dispose",
          value: function dispose() {
            this.controller_.viewProps.set('disposed', true);
          }
        }]);

        return BladeApi;
      }();

      var TpEvent = /*#__PURE__*/_createClass(function TpEvent(target) {
        _classCallCheck(this, TpEvent);

        this.target = target;
      });

      var TpChangeEvent = /*#__PURE__*/function (_TpEvent) {
        _inherits(TpChangeEvent, _TpEvent);

        var _super = _createSuper(TpChangeEvent);

        function TpChangeEvent(target, value, presetKey, last) {
          var _this;

          _classCallCheck(this, TpChangeEvent);

          _this = _super.call(this, target);
          _this.value = value;
          _this.presetKey = presetKey;
          _this.last = last !== null && last !== void 0 ? last : true;
          return _this;
        }

        return _createClass(TpChangeEvent);
      }(TpEvent);

      function forceCast(v) {
        return v;
      }

      function isEmpty(value) {
        return value === null || value === undefined;
      }

      var CREATE_MESSAGE_MAP = {
        alreadydisposed: function alreadydisposed() {
          return 'View has been already disposed';
        },
        invalidparams: function invalidparams(context) {
          return "Invalid parameters for '".concat(context.name, "'");
        },
        nomatchingcontroller: function nomatchingcontroller(context) {
          return "No matching controller for '".concat(context.key, "'");
        },
        nomatchingview: function nomatchingview(context) {
          return "No matching view for '".concat(JSON.stringify(context.params), "'");
        },
        notbindable: function notbindable() {
          return "Value is not bindable";
        },
        propertynotfound: function propertynotfound(context) {
          return "Property '".concat(context.name, "' not found");
        },
        shouldneverhappen: function shouldneverhappen() {
          return 'This error should never happen';
        }
      };

      var TpError = /*#__PURE__*/function () {
        function TpError(config) {
          _classCallCheck(this, TpError);

          var _a;

          this.message = (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== void 0 ? _a : 'Unexpected error';
          this.name = this.constructor.name;
          this.stack = new Error(this.message).stack;
          this.type = config.type;
        }

        _createClass(TpError, null, [{
          key: "alreadyDisposed",
          value: function alreadyDisposed() {
            return new TpError({
              type: 'alreadydisposed'
            });
          }
        }, {
          key: "notBindable",
          value: function notBindable() {
            return new TpError({
              type: 'notbindable'
            });
          }
        }, {
          key: "propertyNotFound",
          value: function propertyNotFound(name) {
            return new TpError({
              type: 'propertynotfound',
              context: {
                name: name
              }
            });
          }
        }, {
          key: "shouldNeverHappen",
          value: function shouldNeverHappen() {
            return new TpError({
              type: 'shouldneverhappen'
            });
          }
        }]);

        return TpError;
      }();

      var Emitter = /*#__PURE__*/function () {
        function Emitter() {
          _classCallCheck(this, Emitter);

          this.observers_ = {};
        }

        _createClass(Emitter, [{
          key: "on",
          value: function on(eventName, handler) {
            var observers = this.observers_[eventName];

            if (!observers) {
              observers = this.observers_[eventName] = [];
            }

            observers.push({
              handler: handler
            });
            return this;
          }
        }, {
          key: "off",
          value: function off(eventName, handler) {
            var observers = this.observers_[eventName];

            if (observers) {
              this.observers_[eventName] = observers.filter(function (observer) {
                return observer.handler !== handler;
              });
            }

            return this;
          }
        }, {
          key: "emit",
          value: function emit(eventName, event) {
            var observers = this.observers_[eventName];

            if (!observers) {
              return;
            }

            observers.forEach(function (observer) {
              observer.handler(event);
            });
          }
        }]);

        return Emitter;
      }();

      var PREFIX = 'tp';

      function ClassName(viewName) {
        var fn = function fn(opt_elementName, opt_modifier) {
          return [PREFIX, '-', viewName, 'v', opt_elementName ? "_".concat(opt_elementName) : '', opt_modifier ? "-".concat(opt_modifier) : ''].join('');
        };

        return fn;
      }

      function compose$1(h1, h2) {
        return function (input) {
          return h2(h1(input));
        };
      }

      function extractValue(ev) {
        return ev.rawValue;
      }

      function bindValue(value, applyValue) {
        value.emitter.on('change', compose$1(extractValue, applyValue));
        applyValue(value.rawValue);
      }

      function bindValueMap(valueMap, key, applyValue) {
        bindValue(valueMap.value(key), applyValue);
      }

      function applyClass(elem, className, active) {
        if (active) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      }

      function valueToClassName(elem, className) {
        return function (value) {
          applyClass(elem, className, value);
        };
      }

      function bindValueToTextContent(value, elem) {
        bindValue(value, function (text) {
          elem.textContent = text !== null && text !== void 0 ? text : '';
        });
      }

      var className$g = ClassName('btn');

      var ButtonView = /*#__PURE__*/_createClass(function ButtonView(doc, config) {
        _classCallCheck(this, ButtonView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$g());
        config.viewProps.bindClassModifiers(this.element);
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(className$g('b'));
        config.viewProps.bindDisabled(buttonElem);
        this.element.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var titleElem = doc.createElement('div');
        titleElem.classList.add(className$g('t'));
        bindValueToTextContent(config.props.value('title'), titleElem);
        this.buttonElement.appendChild(titleElem);
      });

      var ButtonController = /*#__PURE__*/function () {
        function ButtonController(doc, config) {
          _classCallCheck(this, ButtonController);

          this.emitter = new Emitter();
          this.onClick_ = this.onClick_.bind(this);
          this.props = config.props;
          this.viewProps = config.viewProps;
          this.view = new ButtonView(doc, {
            props: this.props,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener('click', this.onClick_);
        }

        _createClass(ButtonController, [{
          key: "onClick_",
          value: function onClick_() {
            this.emitter.emit('click', {
              sender: this
            });
          }
        }]);

        return ButtonController;
      }();

      var BoundValue = /*#__PURE__*/function () {
        function BoundValue(initialValue, config) {
          _classCallCheck(this, BoundValue);

          var _a;

          this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
          this.equals_ = (_a = config === null || config === void 0 ? void 0 : config.equals) !== null && _a !== void 0 ? _a : function (v1, v2) {
            return v1 === v2;
          };
          this.emitter = new Emitter();
          this.rawValue_ = initialValue;
        }

        _createClass(BoundValue, [{
          key: "constraint",
          get: function get() {
            return this.constraint_;
          }
        }, {
          key: "rawValue",
          get: function get() {
            return this.rawValue_;
          },
          set: function set(rawValue) {
            this.setRawValue(rawValue, {
              forceEmit: false,
              last: true
            });
          }
        }, {
          key: "setRawValue",
          value: function setRawValue(rawValue, options) {
            var opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };
            var constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
            var changed = !this.equals_(this.rawValue_, constrainedValue);

            if (!changed && !opts.forceEmit) {
              return;
            }

            this.emitter.emit('beforechange', {
              sender: this
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit('change', {
              options: opts,
              rawValue: constrainedValue,
              sender: this
            });
          }
        }]);

        return BoundValue;
      }();

      var PrimitiveValue = /*#__PURE__*/function () {
        function PrimitiveValue(initialValue) {
          _classCallCheck(this, PrimitiveValue);

          this.emitter = new Emitter();
          this.value_ = initialValue;
        }

        _createClass(PrimitiveValue, [{
          key: "rawValue",
          get: function get() {
            return this.value_;
          },
          set: function set(value) {
            this.setRawValue(value, {
              forceEmit: false,
              last: true
            });
          }
        }, {
          key: "setRawValue",
          value: function setRawValue(value, options) {
            var opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };

            if (this.value_ === value && !opts.forceEmit) {
              return;
            }

            this.emitter.emit('beforechange', {
              sender: this
            });
            this.value_ = value;
            this.emitter.emit('change', {
              options: opts,
              rawValue: this.value_,
              sender: this
            });
          }
        }]);

        return PrimitiveValue;
      }();

      function createValue(initialValue, config) {
        var constraint = config === null || config === void 0 ? void 0 : config.constraint;
        var equals = config === null || config === void 0 ? void 0 : config.equals;

        if (!constraint && !equals) {
          return new PrimitiveValue(initialValue);
        }

        return new BoundValue(initialValue, config);
      }

      var ValueMap = /*#__PURE__*/function () {
        function ValueMap(valueMap) {
          var _this2 = this;

          _classCallCheck(this, ValueMap);

          this.emitter = new Emitter();
          this.valMap_ = valueMap;

          var _loop = function _loop(key) {
            var v = _this2.valMap_[key];
            v.emitter.on('change', function () {
              _this2.emitter.emit('change', {
                key: key,
                sender: _this2
              });
            });
          };

          for (var key in this.valMap_) {
            _loop(key);
          }
        }

        _createClass(ValueMap, [{
          key: "get",
          value: function get(key) {
            return this.valMap_[key].rawValue;
          }
        }, {
          key: "set",
          value: function set(key, value) {
            this.valMap_[key].rawValue = value;
          }
        }, {
          key: "value",
          value: function value(key) {
            return this.valMap_[key];
          }
        }], [{
          key: "createCore",
          value: function createCore(initialValue) {
            var keys = Object.keys(initialValue);
            return keys.reduce(function (o, key) {
              return Object.assign(o, _defineProperty({}, key, createValue(initialValue[key])));
            }, {});
          }
        }, {
          key: "fromObject",
          value: function fromObject(initialValue) {
            var core = this.createCore(initialValue);
            return new ValueMap(core);
          }
        }]);

        return ValueMap;
      }();

      function parseObject(value, keyToParserMap) {
        var keys = Object.keys(keyToParserMap);
        var result = keys.reduce(function (tmp, key) {
          if (tmp === undefined) {
            return undefined;
          }

          var parser = keyToParserMap[key];
          var result = parser(value[key]);
          return result.succeeded ? Object.assign(Object.assign({}, tmp), _defineProperty({}, key, result.value)) : undefined;
        }, {});
        return forceCast(result);
      }

      function parseArray(value, parseItem) {
        return value.reduce(function (tmp, item) {
          if (tmp === undefined) {
            return undefined;
          }

          var result = parseItem(item);

          if (!result.succeeded || result.value === undefined) {
            return undefined;
          }

          return [].concat(_toConsumableArray(tmp), [result.value]);
        }, []);
      }

      function isObject(value) {
        if (value === null) {
          return false;
        }

        return _typeof$1(value) === 'object';
      }

      function createParamsParserBuilder(parse) {
        return function (optional) {
          return function (v) {
            if (!optional && v === undefined) {
              return {
                succeeded: false,
                value: undefined
              };
            }

            if (optional && v === undefined) {
              return {
                succeeded: true,
                value: undefined
              };
            }

            var result = parse(v);
            return result !== undefined ? {
              succeeded: true,
              value: result
            } : {
              succeeded: false,
              value: undefined
            };
          };
        };
      }

      function createParamsParserBuilders(optional) {
        return {
          custom: function custom(parse) {
            return createParamsParserBuilder(parse)(optional);
          },
          "boolean": createParamsParserBuilder(function (v) {
            return typeof v === 'boolean' ? v : undefined;
          })(optional),
          number: createParamsParserBuilder(function (v) {
            return typeof v === 'number' ? v : undefined;
          })(optional),
          string: createParamsParserBuilder(function (v) {
            return typeof v === 'string' ? v : undefined;
          })(optional),
          "function": createParamsParserBuilder(function (v) {
            return typeof v === 'function' ? v : undefined;
          })(optional),
          constant: function constant(value) {
            return createParamsParserBuilder(function (v) {
              return v === value ? value : undefined;
            })(optional);
          },
          raw: createParamsParserBuilder(function (v) {
            return v;
          })(optional),
          object: function object(keyToParserMap) {
            return createParamsParserBuilder(function (v) {
              if (!isObject(v)) {
                return undefined;
              }

              return parseObject(v, keyToParserMap);
            })(optional);
          },
          array: function array(itemParser) {
            return createParamsParserBuilder(function (v) {
              if (!Array.isArray(v)) {
                return undefined;
              }

              return parseArray(v, itemParser);
            })(optional);
          }
        };
      }

      var ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false)
      };

      function parseParams(value, keyToParserMap) {
        var result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
      }

      function disposeElement(elem) {
        if (elem && elem.parentElement) {
          elem.parentElement.removeChild(elem);
        }

        return null;
      }

      function getAllBladePositions() {
        return ['veryfirst', 'first', 'last', 'verylast'];
      }

      var className$f = ClassName('');
      var POS_TO_CLASS_NAME_MAP = {
        veryfirst: 'vfst',
        first: 'fst',
        last: 'lst',
        verylast: 'vlst'
      };

      var BladeController = /*#__PURE__*/function () {
        function BladeController(config) {
          var _this3 = this;

          _classCallCheck(this, BladeController);

          this.parent_ = null;
          this.blade = config.blade;
          this.view = config.view;
          this.viewProps = config.viewProps;
          var elem = this.view.element;
          this.blade.value('positions').emitter.on('change', function () {
            getAllBladePositions().forEach(function (pos) {
              elem.classList.remove(className$f(undefined, POS_TO_CLASS_NAME_MAP[pos]));
            });

            _this3.blade.get('positions').forEach(function (pos) {
              elem.classList.add(className$f(undefined, POS_TO_CLASS_NAME_MAP[pos]));
            });
          });
          this.viewProps.handleDispose(function () {
            disposeElement(elem);
          });
        }

        _createClass(BladeController, [{
          key: "parent",
          get: function get() {
            return this.parent_;
          }
        }]);

        return BladeController;
      }();

      var SVG_NS = 'http://www.w3.org/2000/svg';

      function forceReflow(element) {
        element.offsetHeight;
      }

      function disableTransitionTemporarily(element, callback) {
        var t = element.style.transition;
        element.style.transition = 'none';
        callback();
        element.style.transition = t;
      }

      function supportsTouch(doc) {
        return doc.ontouchstart !== undefined;
      }

      function removeChildNodes(element) {
        while (element.childNodes.length > 0) {
          element.removeChild(element.childNodes[0]);
        }
      }

      function findNextTarget(ev) {
        if (ev.relatedTarget) {
          return forceCast(ev.relatedTarget);
        }

        if ('explicitOriginalTarget' in ev) {
          return ev.explicitOriginalTarget;
        }

        return null;
      }

      var className$e = ClassName('lbl');

      function createLabelNode(doc, label) {
        var frag = doc.createDocumentFragment();
        var lineNodes = label.split('\n').map(function (line) {
          return doc.createTextNode(line);
        });
        lineNodes.forEach(function (lineNode, index) {
          if (index > 0) {
            frag.appendChild(doc.createElement('br'));
          }

          frag.appendChild(lineNode);
        });
        return frag;
      }

      var LabelView = /*#__PURE__*/_createClass(function LabelView(doc, config) {
        var _this4 = this;

        _classCallCheck(this, LabelView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$e());
        config.viewProps.bindClassModifiers(this.element);
        var labelElem = doc.createElement('div');
        labelElem.classList.add(className$e('l'));
        bindValueMap(config.props, 'label', function (value) {
          if (isEmpty(value)) {
            _this4.element.classList.add(className$e(undefined, 'nol'));
          } else {
            _this4.element.classList.remove(className$e(undefined, 'nol'));

            removeChildNodes(labelElem);
            labelElem.appendChild(createLabelNode(doc, value));
          }
        });
        this.element.appendChild(labelElem);
        this.labelElement = labelElem;
        var valueElem = doc.createElement('div');
        valueElem.classList.add(className$e('v'));
        this.element.appendChild(valueElem);
        this.valueElement = valueElem;
      });

      var LabelController = /*#__PURE__*/function (_BladeController) {
        _inherits(LabelController, _BladeController);

        var _super2 = _createSuper(LabelController);

        function LabelController(doc, config) {
          var _this5;

          _classCallCheck(this, LabelController);

          var viewProps = config.valueController.viewProps;
          _this5 = _super2.call(this, Object.assign(Object.assign({}, config), {
            view: new LabelView(doc, {
              props: config.props,
              viewProps: viewProps
            }),
            viewProps: viewProps
          }));
          _this5.props = config.props;
          _this5.valueController = config.valueController;

          _this5.view.valueElement.appendChild(_this5.valueController.view.element);

          return _this5;
        }

        return _createClass(LabelController);
      }(BladeController);

      var ValueBladeController = /*#__PURE__*/function (_BladeController2) {
        _inherits(ValueBladeController, _BladeController2);

        var _super3 = _createSuper(ValueBladeController);

        function ValueBladeController(config) {
          var _this6;

          _classCallCheck(this, ValueBladeController);

          _this6 = _super3.call(this, config);
          _this6.value = config.value;
          return _this6;
        }

        return _createClass(ValueBladeController);
      }(BladeController);

      var Foldable = /*#__PURE__*/function (_ValueMap) {
        _inherits(Foldable, _ValueMap);

        var _super4 = _createSuper(Foldable);

        function Foldable(valueMap) {
          _classCallCheck(this, Foldable);

          return _super4.call(this, valueMap);
        }

        _createClass(Foldable, [{
          key: "styleExpanded",
          get: function get() {
            var _a;

            return (_a = this.get('temporaryExpanded')) !== null && _a !== void 0 ? _a : this.get('expanded');
          }
        }, {
          key: "styleHeight",
          get: function get() {
            if (!this.styleExpanded) {
              return '0';
            }

            var exHeight = this.get('expandedHeight');

            if (this.get('shouldFixHeight') && !isEmpty(exHeight)) {
              return "".concat(exHeight, "px");
            }

            return 'auto';
          }
        }, {
          key: "bindExpandedClass",
          value: function bindExpandedClass(elem, expandedClassName) {
            var _this7 = this;

            var onExpand = function onExpand() {
              var expanded = _this7.styleExpanded;

              if (expanded) {
                elem.classList.add(expandedClassName);
              } else {
                elem.classList.remove(expandedClassName);
              }
            };

            bindValueMap(this, 'expanded', onExpand);
            bindValueMap(this, 'temporaryExpanded', onExpand);
          }
        }, {
          key: "cleanUpTransition",
          value: function cleanUpTransition() {
            this.set('shouldFixHeight', false);
            this.set('expandedHeight', null);
            this.set('completed', true);
          }
        }], [{
          key: "create",
          value: function create(expanded) {
            var coreObj = {
              completed: true,
              expanded: expanded,
              expandedHeight: null,
              shouldFixHeight: false,
              temporaryExpanded: null
            };
            var core = ValueMap.createCore(coreObj);
            return new Foldable(core);
          }
        }]);

        return Foldable;
      }(ValueMap);

      function createFoldable(expanded) {
        return Foldable.create(expanded);
      }

      function computeExpandedFolderHeight(folder, containerElement) {
        var height = 0;
        disableTransitionTemporarily(containerElement, function () {
          folder.set('expandedHeight', null);
          folder.set('temporaryExpanded', true);
          forceReflow(containerElement);
          height = containerElement.clientHeight;
          folder.set('temporaryExpanded', null);
          forceReflow(containerElement);
        });
        return height;
      }

      function applyHeight(foldable, elem) {
        elem.style.height = foldable.styleHeight;
      }

      function bindFoldable(foldable, elem) {
        foldable.value('expanded').emitter.on('beforechange', function () {
          foldable.set('completed', false);

          if (isEmpty(foldable.get('expandedHeight'))) {
            foldable.set('expandedHeight', computeExpandedFolderHeight(foldable, elem));
          }

          foldable.set('shouldFixHeight', true);
          forceReflow(elem);
        });
        foldable.emitter.on('change', function () {
          applyHeight(foldable, elem);
        });
        applyHeight(foldable, elem);
        elem.addEventListener('transitionend', function (ev) {
          if (ev.propertyName !== 'height') {
            return;
          }

          foldable.cleanUpTransition();
        });
      }

      var PlainView = /*#__PURE__*/_createClass(function PlainView(doc, config) {
        _classCallCheck(this, PlainView);

        var className = ClassName(config.viewName);
        this.element = doc.createElement('div');
        this.element.classList.add(className());
        config.viewProps.bindClassModifiers(this.element);
      });

      var LabeledValueController = /*#__PURE__*/function (_ValueBladeController) {
        _inherits(LabeledValueController, _ValueBladeController);

        var _super5 = _createSuper(LabeledValueController);

        function LabeledValueController(doc, config) {
          var _this8;

          _classCallCheck(this, LabeledValueController);

          var viewProps = config.valueController.viewProps;
          _this8 = _super5.call(this, Object.assign(Object.assign({}, config), {
            value: config.valueController.value,
            view: new LabelView(doc, {
              props: config.props,
              viewProps: viewProps
            }),
            viewProps: viewProps
          }));
          _this8.props = config.props;
          _this8.valueController = config.valueController;

          _this8.view.valueElement.appendChild(_this8.valueController.view.element);

          return _this8;
        }

        return _createClass(LabeledValueController);
      }(ValueBladeController);

      var className$d = ClassName('');

      function valueToModifier(elem, modifier) {
        return valueToClassName(elem, className$d(undefined, modifier));
      }

      var ViewProps = /*#__PURE__*/function (_ValueMap2) {
        _inherits(ViewProps, _ValueMap2);

        var _super6 = _createSuper(ViewProps);

        function ViewProps(valueMap) {
          _classCallCheck(this, ViewProps);

          return _super6.call(this, valueMap);
        }

        _createClass(ViewProps, [{
          key: "bindClassModifiers",
          value: function bindClassModifiers(elem) {
            bindValueMap(this, 'disabled', valueToModifier(elem, 'disabled'));
            bindValueMap(this, 'hidden', valueToModifier(elem, 'hidden'));
          }
        }, {
          key: "bindDisabled",
          value: function bindDisabled(target) {
            bindValueMap(this, 'disabled', function (disabled) {
              target.disabled = disabled;
            });
          }
        }, {
          key: "bindTabIndex",
          value: function bindTabIndex(elem) {
            bindValueMap(this, 'disabled', function (disabled) {
              elem.tabIndex = disabled ? -1 : 0;
            });
          }
        }, {
          key: "handleDispose",
          value: function handleDispose(callback) {
            this.value('disposed').emitter.on('change', function (disposed) {
              if (disposed) {
                callback();
              }
            });
          }
        }], [{
          key: "create",
          value: function create(opt_initialValue) {
            var _a, _b;

            var initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            var coreObj = {
              disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
              disposed: false,
              hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false
            };
            var core = ValueMap.createCore(coreObj);
            return new ViewProps(core);
          }
        }]);

        return ViewProps;
      }(ValueMap);

      var ManualTicker = /*#__PURE__*/function () {
        function ManualTicker() {
          _classCallCheck(this, ManualTicker);

          this.disabled = false;
          this.emitter = new Emitter();
        }

        _createClass(ManualTicker, [{
          key: "dispose",
          value: function dispose() {}
        }, {
          key: "tick",
          value: function tick() {
            if (this.disabled) {
              return;
            }

            this.emitter.emit('tick', {
              sender: this
            });
          }
        }]);

        return ManualTicker;
      }();

      var IntervalTicker = /*#__PURE__*/function () {
        function IntervalTicker(doc, interval) {
          _classCallCheck(this, IntervalTicker);

          this.disabled_ = false;
          this.timerId_ = null;
          this.onTick_ = this.onTick_.bind(this);
          this.doc_ = doc;
          this.emitter = new Emitter();
          this.interval_ = interval;
          this.setTimer_();
        }

        _createClass(IntervalTicker, [{
          key: "disabled",
          get: function get() {
            return this.disabled_;
          },
          set: function set(inactive) {
            this.disabled_ = inactive;

            if (this.disabled_) {
              this.clearTimer_();
            } else {
              this.setTimer_();
            }
          }
        }, {
          key: "dispose",
          value: function dispose() {
            this.clearTimer_();
          }
        }, {
          key: "clearTimer_",
          value: function clearTimer_() {
            if (this.timerId_ === null) {
              return;
            }

            var win = this.doc_.defaultView;

            if (win) {
              win.clearInterval(this.timerId_);
            }

            this.timerId_ = null;
          }
        }, {
          key: "setTimer_",
          value: function setTimer_() {
            this.clearTimer_();

            if (this.interval_ <= 0) {
              return;
            }

            var win = this.doc_.defaultView;

            if (win) {
              this.timerId_ = win.setInterval(this.onTick_, this.interval_);
            }
          }
        }, {
          key: "onTick_",
          value: function onTick_() {
            if (this.disabled_) {
              return;
            }

            this.emitter.emit('tick', {
              sender: this
            });
          }
        }]);

        return IntervalTicker;
      }();

      var CompositeConstraint = /*#__PURE__*/function () {
        function CompositeConstraint(constraints) {
          _classCallCheck(this, CompositeConstraint);

          this.constraints = constraints;
        }

        _createClass(CompositeConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            return this.constraints.reduce(function (result, c) {
              return c.constrain(result);
            }, value);
          }
        }]);

        return CompositeConstraint;
      }();

      function findConstraint(c, constraintClass) {
        if (c instanceof constraintClass) {
          return c;
        }

        if (c instanceof CompositeConstraint) {
          var result = c.constraints.reduce(function (tmpResult, sc) {
            if (tmpResult) {
              return tmpResult;
            }

            return sc instanceof constraintClass ? sc : null;
          }, null);

          if (result) {
            return result;
          }
        }

        return null;
      }

      var RangeConstraint = /*#__PURE__*/function () {
        function RangeConstraint(config) {
          _classCallCheck(this, RangeConstraint);

          this.maxValue = config.max;
          this.minValue = config.min;
        }

        _createClass(RangeConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var result = value;

            if (!isEmpty(this.minValue)) {
              result = Math.max(result, this.minValue);
            }

            if (!isEmpty(this.maxValue)) {
              result = Math.min(result, this.maxValue);
            }

            return result;
          }
        }]);

        return RangeConstraint;
      }();

      var StepConstraint = /*#__PURE__*/function () {
        function StepConstraint(step) {
          var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          _classCallCheck(this, StepConstraint);

          this.step = step;
          this.origin = origin;
        }

        _createClass(StepConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var o = this.origin % this.step;
            var r = Math.round((value - o) / this.step);
            return o + r * this.step;
          }
        }]);

        return StepConstraint;
      }();

      var className$c = ClassName('pop');

      var PopupView = /*#__PURE__*/_createClass(function PopupView(doc, config) {
        _classCallCheck(this, PopupView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$c());
        config.viewProps.bindClassModifiers(this.element);
        bindValue(config.shows, valueToClassName(this.element, className$c(undefined, 'v')));
      });

      var PopupController = /*#__PURE__*/_createClass(function PopupController(doc, config) {
        _classCallCheck(this, PopupController);

        this.shows = createValue(false);
        this.viewProps = config.viewProps;
        this.view = new PopupView(doc, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      });

      var className$b = ClassName('txt');

      var TextView = /*#__PURE__*/function () {
        function TextView(doc, config) {
          _classCallCheck(this, TextView);

          this.onChange_ = this.onChange_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className$b());
          config.viewProps.bindClassModifiers(this.element);
          this.props_ = config.props;
          this.props_.emitter.on('change', this.onChange_);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$b('i'));
          inputElem.type = 'text';
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          config.value.emitter.on('change', this.onChange_);
          this.value_ = config.value;
          this.refresh();
        }

        _createClass(TextView, [{
          key: "refresh",
          value: function refresh() {
            var formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value_.rawValue);
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.refresh();
          }
        }]);

        return TextView;
      }();

      var TextController = /*#__PURE__*/function () {
        function TextController(doc, config) {
          _classCallCheck(this, TextController);

          this.onInputChange_ = this.onInputChange_.bind(this);
          this.parser_ = config.parser;
          this.props = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new TextView(doc, {
            props: config.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener('change', this.onInputChange_);
        }

        _createClass(TextController, [{
          key: "onInputChange_",
          value: function onInputChange_(e) {
            var inputElem = forceCast(e.currentTarget);
            var value = inputElem.value;
            var parsedValue = this.parser_(value);

            if (!isEmpty(parsedValue)) {
              this.value.rawValue = parsedValue;
            }

            this.view.refresh();
          }
        }]);

        return TextController;
      }();

      function boolFromUnknown(value) {
        if (value === 'false') {
          return false;
        }

        return !!value;
      }

      var NumberLiteralNode = /*#__PURE__*/function () {
        function NumberLiteralNode(text) {
          _classCallCheck(this, NumberLiteralNode);

          this.text = text;
        }

        _createClass(NumberLiteralNode, [{
          key: "evaluate",
          value: function evaluate() {
            return Number(this.text);
          }
        }, {
          key: "toString",
          value: function toString() {
            return this.text;
          }
        }]);

        return NumberLiteralNode;
      }();

      var BINARY_OPERATION_MAP = {
        '**': function _(v1, v2) {
          return Math.pow(v1, v2);
        },
        '*': function _(v1, v2) {
          return v1 * v2;
        },
        '/': function _(v1, v2) {
          return v1 / v2;
        },
        '%': function _(v1, v2) {
          return v1 % v2;
        },
        '+': function _(v1, v2) {
          return v1 + v2;
        },
        '-': function _(v1, v2) {
          return v1 - v2;
        },
        '<<': function _(v1, v2) {
          return v1 << v2;
        },
        '>>': function _(v1, v2) {
          return v1 >> v2;
        },
        '>>>': function _(v1, v2) {
          return v1 >>> v2;
        },
        '&': function _(v1, v2) {
          return v1 & v2;
        },
        '^': function _(v1, v2) {
          return v1 ^ v2;
        },
        '|': function _(v1, v2) {
          return v1 | v2;
        }
      };

      var BinaryOperationNode = /*#__PURE__*/function () {
        function BinaryOperationNode(operator, left, right) {
          _classCallCheck(this, BinaryOperationNode);

          this.left = left;
          this.operator = operator;
          this.right = right;
        }

        _createClass(BinaryOperationNode, [{
          key: "evaluate",
          value: function evaluate() {
            var op = BINARY_OPERATION_MAP[this.operator];

            if (!op) {
              throw new Error("unexpected binary operator: '".concat(this.operator));
            }

            return op(this.left.evaluate(), this.right.evaluate());
          }
        }, {
          key: "toString",
          value: function toString() {
            return ['b(', this.left.toString(), this.operator, this.right.toString(), ')'].join(' ');
          }
        }]);

        return BinaryOperationNode;
      }();

      var UNARY_OPERATION_MAP = {
        '+': function _(v) {
          return v;
        },
        '-': function _(v) {
          return -v;
        },
        '~': function _(v) {
          return ~v;
        }
      };

      var UnaryOperationNode = /*#__PURE__*/function () {
        function UnaryOperationNode(operator, expr) {
          _classCallCheck(this, UnaryOperationNode);

          this.operator = operator;
          this.expression = expr;
        }

        _createClass(UnaryOperationNode, [{
          key: "evaluate",
          value: function evaluate() {
            var op = UNARY_OPERATION_MAP[this.operator];

            if (!op) {
              throw new Error("unexpected unary operator: '".concat(this.operator));
            }

            return op(this.expression.evaluate());
          }
        }, {
          key: "toString",
          value: function toString() {
            return ['u(', this.operator, this.expression.toString(), ')'].join(' ');
          }
        }]);

        return UnaryOperationNode;
      }();

      function combineReader(parsers) {
        return function (text, cursor) {
          for (var i = 0; i < parsers.length; i++) {
            var result = parsers[i](text, cursor);

            if (result !== '') {
              return result;
            }
          }

          return '';
        };
      }

      function readWhitespace(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^\s+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readNonZeroDigit(text, cursor) {
        var ch = text.substr(cursor, 1);
        return ch.match(/^[1-9]$/) ? ch : '';
      }

      function readDecimalDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-9]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readSignedInteger(text, cursor) {
        var ds = readDecimalDigits(text, cursor);

        if (ds !== '') {
          return ds;
        }

        var sign = text.substr(cursor, 1);
        cursor += 1;

        if (sign !== '-' && sign !== '+') {
          return '';
        }

        var sds = readDecimalDigits(text, cursor);

        if (sds === '') {
          return '';
        }

        return sign + sds;
      }

      function readExponentPart(text, cursor) {
        var e = text.substr(cursor, 1);
        cursor += 1;

        if (e.toLowerCase() !== 'e') {
          return '';
        }

        var si = readSignedInteger(text, cursor);

        if (si === '') {
          return '';
        }

        return e + si;
      }

      function readDecimalIntegerLiteral(text, cursor) {
        var ch = text.substr(cursor, 1);

        if (ch === '0') {
          return ch;
        }

        var nzd = readNonZeroDigit(text, cursor);
        cursor += nzd.length;

        if (nzd === '') {
          return '';
        }

        return nzd + readDecimalDigits(text, cursor);
      }

      function readDecimalLiteral1(text, cursor) {
        var dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;

        if (dil === '') {
          return '';
        }

        var dot = text.substr(cursor, 1);
        cursor += dot.length;

        if (dot !== '.') {
          return '';
        }

        var dds = readDecimalDigits(text, cursor);
        cursor += dds.length;
        return dil + dot + dds + readExponentPart(text, cursor);
      }

      function readDecimalLiteral2(text, cursor) {
        var dot = text.substr(cursor, 1);
        cursor += dot.length;

        if (dot !== '.') {
          return '';
        }

        var dds = readDecimalDigits(text, cursor);
        cursor += dds.length;

        if (dds === '') {
          return '';
        }

        return dot + dds + readExponentPart(text, cursor);
      }

      function readDecimalLiteral3(text, cursor) {
        var dil = readDecimalIntegerLiteral(text, cursor);
        cursor += dil.length;

        if (dil === '') {
          return '';
        }

        return dil + readExponentPart(text, cursor);
      }

      var readDecimalLiteral = combineReader([readDecimalLiteral1, readDecimalLiteral2, readDecimalLiteral3]);

      function parseBinaryDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[01]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readBinaryIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0b') {
          return '';
        }

        var bds = parseBinaryDigits(text, cursor);

        if (bds === '') {
          return '';
        }

        return prefix + bds;
      }

      function readOctalDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-7]+/);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readOctalIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0o') {
          return '';
        }

        var ods = readOctalDigits(text, cursor);

        if (ods === '') {
          return '';
        }

        return prefix + ods;
      }

      function readHexDigits(text, cursor) {
        var _a;

        var m = text.substr(cursor).match(/^[0-9a-f]+/i);
        return (_a = m && m[0]) !== null && _a !== void 0 ? _a : '';
      }

      function readHexIntegerLiteral(text, cursor) {
        var prefix = text.substr(cursor, 2);
        cursor += prefix.length;

        if (prefix.toLowerCase() !== '0x') {
          return '';
        }

        var hds = readHexDigits(text, cursor);

        if (hds === '') {
          return '';
        }

        return prefix + hds;
      }

      var readNonDecimalIntegerLiteral = combineReader([readBinaryIntegerLiteral, readOctalIntegerLiteral, readHexIntegerLiteral]);
      var readNumericLiteral = combineReader([readNonDecimalIntegerLiteral, readDecimalLiteral]);

      function parseLiteral(text, cursor) {
        var num = readNumericLiteral(text, cursor);
        cursor += num.length;

        if (num === '') {
          return null;
        }

        return {
          evaluable: new NumberLiteralNode(num),
          cursor: cursor
        };
      }

      function parseParenthesizedExpression(text, cursor) {
        var op = text.substr(cursor, 1);
        cursor += op.length;

        if (op !== '(') {
          return null;
        }

        var expr = parseExpression(text, cursor);

        if (!expr) {
          return null;
        }

        cursor = expr.cursor;
        cursor += readWhitespace(text, cursor).length;
        var cl = text.substr(cursor, 1);
        cursor += cl.length;

        if (cl !== ')') {
          return null;
        }

        return {
          evaluable: expr.evaluable,
          cursor: cursor
        };
      }

      function parsePrimaryExpression(text, cursor) {
        var _a;

        return (_a = parseLiteral(text, cursor)) !== null && _a !== void 0 ? _a : parseParenthesizedExpression(text, cursor);
      }

      function parseUnaryExpression(text, cursor) {
        var expr = parsePrimaryExpression(text, cursor);

        if (expr) {
          return expr;
        }

        var op = text.substr(cursor, 1);
        cursor += op.length;

        if (op !== '+' && op !== '-' && op !== '~') {
          return null;
        }

        var num = parseUnaryExpression(text, cursor);

        if (!num) {
          return null;
        }

        cursor = num.cursor;
        return {
          cursor: cursor,
          evaluable: new UnaryOperationNode(op, num.evaluable)
        };
      }

      function readBinaryOperator(ops, text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        var op = ops.filter(function (op) {
          return text.startsWith(op, cursor);
        })[0];

        if (!op) {
          return null;
        }

        cursor += op.length;
        cursor += readWhitespace(text, cursor).length;
        return {
          cursor: cursor,
          operator: op
        };
      }

      function createBinaryOperationExpressionParser(exprParser, ops) {
        return function (text, cursor) {
          var firstExpr = exprParser(text, cursor);

          if (!firstExpr) {
            return null;
          }

          cursor = firstExpr.cursor;
          var expr = firstExpr.evaluable;

          for (;;) {
            var op = readBinaryOperator(ops, text, cursor);

            if (!op) {
              break;
            }

            cursor = op.cursor;
            var nextExpr = exprParser(text, cursor);

            if (!nextExpr) {
              return null;
            }

            cursor = nextExpr.cursor;
            expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
          }

          return expr ? {
            cursor: cursor,
            evaluable: expr
          } : null;
        };
      }

      var parseBinaryOperationExpression = [['**'], ['*', '/', '%'], ['+', '-'], ['<<', '>>>', '>>'], ['&'], ['^'], ['|']].reduce(function (parser, ops) {
        return createBinaryOperationExpressionParser(parser, ops);
      }, parseUnaryExpression);

      function parseExpression(text, cursor) {
        cursor += readWhitespace(text, cursor).length;
        return parseBinaryOperationExpression(text, cursor);
      }

      function parseEcmaNumberExpression(text) {
        var expr = parseExpression(text, 0);

        if (!expr) {
          return null;
        }

        var cursor = expr.cursor + readWhitespace(text, expr.cursor).length;

        if (cursor !== text.length) {
          return null;
        }

        return expr.evaluable;
      }

      function parseNumber(text) {
        var _a;

        var r = parseEcmaNumberExpression(text);
        return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
      }

      function numberFromUnknown(value) {
        if (typeof value === 'number') {
          return value;
        }

        if (typeof value === 'string') {
          var pv = parseNumber(value);

          if (!isEmpty(pv)) {
            return pv;
          }
        }

        return 0;
      }

      function createNumberFormatter(digits) {
        return function (value) {
          return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
      }

      var innerFormatter = createNumberFormatter(0);

      function formatPercentage(value) {
        return innerFormatter(value) + '%';
      }

      function stringFromUnknown(value) {
        return String(value);
      }

      function fillBuffer(buffer, bufferSize) {
        while (buffer.length < bufferSize) {
          buffer.push(undefined);
        }
      }

      function initializeBuffer(bufferSize) {
        var buffer = [];
        fillBuffer(buffer, bufferSize);
        return createValue(buffer);
      }

      function createTrimmedBuffer(buffer) {
        var index = buffer.indexOf(undefined);
        return forceCast(index < 0 ? buffer : buffer.slice(0, index));
      }

      function createPushedBuffer(buffer, newValue) {
        var newBuffer = [].concat(_toConsumableArray(createTrimmedBuffer(buffer)), [newValue]);

        if (newBuffer.length > buffer.length) {
          newBuffer.splice(0, newBuffer.length - buffer.length);
        } else {
          fillBuffer(newBuffer, buffer.length);
        }

        return newBuffer;
      }

      function connectValues(_ref) {
        var primary = _ref.primary,
            secondary = _ref.secondary,
            forward = _ref.forward,
            backward = _ref.backward;
        var changing = false;

        function preventFeedback(callback) {
          if (changing) {
            return;
          }

          changing = true;
          callback();
          changing = false;
        }

        primary.emitter.on('change', function (ev) {
          preventFeedback(function () {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        secondary.emitter.on('change', function (ev) {
          preventFeedback(function () {
            primary.setRawValue(backward(primary, secondary), ev.options);
          });
          preventFeedback(function () {
            secondary.setRawValue(forward(primary, secondary), ev.options);
          });
        });
        preventFeedback(function () {
          secondary.setRawValue(forward(primary, secondary), {
            forceEmit: false,
            last: true
          });
        });
      }

      function getStepForKey(baseStep, keys) {
        var step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);

        if (keys.upKey) {
          return +step;
        } else if (keys.downKey) {
          return -step;
        }

        return 0;
      }

      function getVerticalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === 'ArrowDown',
          shiftKey: ev.shiftKey,
          upKey: ev.key === 'ArrowUp'
        };
      }

      function getHorizontalStepKeys(ev) {
        return {
          altKey: ev.altKey,
          downKey: ev.key === 'ArrowLeft',
          shiftKey: ev.shiftKey,
          upKey: ev.key === 'ArrowRight'
        };
      }

      function isVerticalArrowKey(key) {
        return key === 'ArrowUp' || key === 'ArrowDown';
      }

      function isArrowKey(key) {
        return isVerticalArrowKey(key) || key === 'ArrowLeft' || key === 'ArrowRight';
      }

      function computeOffset(ev, elem) {
        var _a, _b;

        var win = elem.ownerDocument.defaultView;
        var rect = elem.getBoundingClientRect();
        return {
          x: ev.pageX - (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) + rect.left),
          y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) + rect.top)
        };
      }

      var PointerHandler = /*#__PURE__*/function () {
        function PointerHandler(element) {
          _classCallCheck(this, PointerHandler);

          this.lastTouch_ = null;
          this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
          this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
          this.onMouseDown_ = this.onMouseDown_.bind(this);
          this.onTouchEnd_ = this.onTouchEnd_.bind(this);
          this.onTouchMove_ = this.onTouchMove_.bind(this);
          this.onTouchStart_ = this.onTouchStart_.bind(this);
          this.elem_ = element;
          this.emitter = new Emitter();
          element.addEventListener('touchstart', this.onTouchStart_, {
            passive: false
          });
          element.addEventListener('touchmove', this.onTouchMove_, {
            passive: true
          });
          element.addEventListener('touchend', this.onTouchEnd_);
          element.addEventListener('mousedown', this.onMouseDown_);
        }

        _createClass(PointerHandler, [{
          key: "computePosition_",
          value: function computePosition_(offset) {
            var rect = this.elem_.getBoundingClientRect();
            return {
              bounds: {
                width: rect.width,
                height: rect.height
              },
              point: offset ? {
                x: offset.x,
                y: offset.y
              } : null
            };
          }
        }, {
          key: "onMouseDown_",
          value: function onMouseDown_(ev) {
            var _a;

            ev.preventDefault();
            (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
            var doc = this.elem_.ownerDocument;
            doc.addEventListener('mousemove', this.onDocumentMouseMove_);
            doc.addEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('down', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onDocumentMouseMove_",
          value: function onDocumentMouseMove_(ev) {
            this.emitter.emit('move', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onDocumentMouseUp_",
          value: function onDocumentMouseUp_(ev) {
            var doc = this.elem_.ownerDocument;
            doc.removeEventListener('mousemove', this.onDocumentMouseMove_);
            doc.removeEventListener('mouseup', this.onDocumentMouseUp_);
            this.emitter.emit('up', {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }, {
          key: "onTouchStart_",
          value: function onTouchStart_(ev) {
            ev.preventDefault();
            var touch = ev.targetTouches.item(0);
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('down', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
        }, {
          key: "onTouchMove_",
          value: function onTouchMove_(ev) {
            var touch = ev.targetTouches.item(0);
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('move', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
        }, {
          key: "onTouchEnd_",
          value: function onTouchEnd_(ev) {
            var _a;

            var touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
            var rect = this.elem_.getBoundingClientRect();
            this.emitter.emit('up', {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : undefined),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }]);

        return PointerHandler;
      }();

      function mapRange(value, start1, end1, start2, end2) {
        var p = (value - start1) / (end1 - start1);
        return start2 + p * (end2 - start2);
      }

      function getDecimalDigits(value) {
        var text = String(value.toFixed(10));
        var frac = text.split('.')[1];
        return frac.replace(/0+$/, '').length;
      }

      function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      var className$a = ClassName('txt');

      var NumberTextView = /*#__PURE__*/function () {
        function NumberTextView(doc, config) {
          _classCallCheck(this, NumberTextView);

          this.onChange_ = this.onChange_.bind(this);
          this.props_ = config.props;
          this.props_.emitter.on('change', this.onChange_);
          this.element = doc.createElement('div');
          this.element.classList.add(className$a(), className$a(undefined, 'num'));

          if (config.arrayPosition) {
            this.element.classList.add(className$a(undefined, config.arrayPosition));
          }

          config.viewProps.bindClassModifiers(this.element);
          var inputElem = doc.createElement('input');
          inputElem.classList.add(className$a('i'));
          inputElem.type = 'text';
          config.viewProps.bindDisabled(inputElem);
          this.element.appendChild(inputElem);
          this.inputElement = inputElem;
          this.onDraggingChange_ = this.onDraggingChange_.bind(this);
          this.dragging_ = config.dragging;
          this.dragging_.emitter.on('change', this.onDraggingChange_);
          this.element.classList.add(className$a());
          this.inputElement.classList.add(className$a('i'));
          var knobElem = doc.createElement('div');
          knobElem.classList.add(className$a('k'));
          this.element.appendChild(knobElem);
          this.knobElement = knobElem;
          var guideElem = doc.createElementNS(SVG_NS, 'svg');
          guideElem.classList.add(className$a('g'));
          this.knobElement.appendChild(guideElem);
          var bodyElem = doc.createElementNS(SVG_NS, 'path');
          bodyElem.classList.add(className$a('gb'));
          guideElem.appendChild(bodyElem);
          this.guideBodyElem_ = bodyElem;
          var headElem = doc.createElementNS(SVG_NS, 'path');
          headElem.classList.add(className$a('gh'));
          guideElem.appendChild(headElem);
          this.guideHeadElem_ = headElem;
          var tooltipElem = doc.createElement('div');
          tooltipElem.classList.add(ClassName('tt')());
          this.knobElement.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on('change', this.onChange_);
          this.value = config.value;
          this.refresh();
        }

        _createClass(NumberTextView, [{
          key: "onDraggingChange_",
          value: function onDraggingChange_(ev) {
            if (ev.rawValue === null) {
              this.element.classList.remove(className$a(undefined, 'drg'));
              return;
            }

            this.element.classList.add(className$a(undefined, 'drg'));
            var x = ev.rawValue / this.props_.get('draggingScale');
            var aox = x + (x > 0 ? -1 : x < 0 ? +1 : 0);
            var adx = constrainRange(-aox, -4, +4);
            this.guideHeadElem_.setAttributeNS(null, 'd', ["M ".concat(aox + adx, ",0 L").concat(aox, ",4 L").concat(aox + adx, ",8"), "M ".concat(x, ",-1 L").concat(x, ",9")].join(' '));
            this.guideBodyElem_.setAttributeNS(null, 'd', "M 0,4 L".concat(x, ",4"));
            var formatter = this.props_.get('formatter');
            this.tooltipElem_.textContent = formatter(this.value.rawValue);
            this.tooltipElem_.style.left = "".concat(x, "px");
          }
        }, {
          key: "refresh",
          value: function refresh() {
            var formatter = this.props_.get('formatter');
            this.inputElement.value = formatter(this.value.rawValue);
          }
        }, {
          key: "onChange_",
          value: function onChange_() {
            this.refresh();
          }
        }]);

        return NumberTextView;
      }();

      var NumberTextController = /*#__PURE__*/function () {
        function NumberTextController(doc, config) {
          _classCallCheck(this, NumberTextController);

          var _a;

          this.originRawValue_ = 0;
          this.onInputChange_ = this.onInputChange_.bind(this);
          this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
          this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.parser_ = config.parser;
          this.props = config.props;
          this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.dragging_ = createValue(null);
          this.view = new NumberTextView(doc, {
            arrayPosition: config.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.inputElement.addEventListener('change', this.onInputChange_);
          this.view.inputElement.addEventListener('keydown', this.onInputKeyDown_);
          this.view.inputElement.addEventListener('keyup', this.onInputKeyUp_);
          var ph = new PointerHandler(this.view.knobElement);
          ph.emitter.on('down', this.onPointerDown_);
          ph.emitter.on('move', this.onPointerMove_);
          ph.emitter.on('up', this.onPointerUp_);
        }

        _createClass(NumberTextController, [{
          key: "constrainValue_",
          value: function constrainValue_(value) {
            var _a, _b;

            var min = (_a = this.sliderProps_) === null || _a === void 0 ? void 0 : _a.get('minValue');
            var max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get('maxValue');
            var v = value;

            if (min !== undefined) {
              v = Math.max(v, min);
            }

            if (max !== undefined) {
              v = Math.min(v, max);
            }

            return v;
          }
        }, {
          key: "onInputChange_",
          value: function onInputChange_(e) {
            var inputElem = forceCast(e.currentTarget);
            var value = inputElem.value;
            var parsedValue = this.parser_(value);

            if (!isEmpty(parsedValue)) {
              this.value.rawValue = this.constrainValue_(parsedValue);
            }

            this.view.refresh();
          }
        }, {
          key: "onInputKeyDown_",
          value: function onInputKeyDown_(ev) {
            var step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onInputKeyUp_",
          value: function onInputKeyUp_(ev) {
            var step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));

            if (step === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_() {
            this.originRawValue_ = this.value.rawValue;
            this.dragging_.rawValue = 0;
          }
        }, {
          key: "computeDraggingValue_",
          value: function computeDraggingValue_(data) {
            if (!data.point) {
              return null;
            }

            var dx = data.point.x - data.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + dx * this.props.get('draggingScale'));
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            var v = this.computeDraggingValue_(ev.data);

            if (v === null) {
              return;
            }

            this.value.setRawValue(v, {
              forceEmit: false,
              last: false
            });
            this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            var v = this.computeDraggingValue_(ev.data);

            if (v === null) {
              return;
            }

            this.value.setRawValue(v, {
              forceEmit: true,
              last: true
            });
            this.dragging_.rawValue = null;
          }
        }]);

        return NumberTextController;
      }();

      function writePrimitive(target, value) {
        target.write(value);
      }

      function findStep(constraint) {
        var c = constraint ? findConstraint(constraint, StepConstraint) : null;

        if (!c) {
          return null;
        }

        return c.step;
      }

      function getSuitableDecimalDigits(constraint, rawValue) {
        var sc = constraint && findConstraint(constraint, StepConstraint);

        if (sc) {
          return getDecimalDigits(sc.step);
        }

        return Math.max(getDecimalDigits(rawValue), 2);
      }

      function getBaseStep(constraint) {
        var step = findStep(constraint);
        return step !== null && step !== void 0 ? step : 1;
      }

      function getSuitableDraggingScale(constraint, rawValue) {
        var _a;

        var sc = constraint && findConstraint(constraint, StepConstraint);
        var base = Math.abs((_a = sc === null || sc === void 0 ? void 0 : sc.step) !== null && _a !== void 0 ? _a : rawValue);
        return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
      }

      function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
      }

      function zerofill(comp) {
        var hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? "0".concat(hex) : hex;
      }

      function colorToHexRgbString(value) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
        var hexes = removeAlphaComponent(value.getComponents('rgb')).map(zerofill).join('');
        return "".concat(prefix).concat(hexes);
      }

      function colorToHexRgbaString(value) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
        var rgbaComps = value.getComponents('rgb');
        var hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join('');
        return "".concat(prefix).concat(hexes);
      }

      function colorToFunctionalRgbString(value, opt_type) {
        var formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        var comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map(function (comp) {
          return formatter(comp);
        });
        return "rgb(".concat(comps.join(', '), ")");
      }

      function createFunctionalRgbColorFormatter(type) {
        return function (value) {
          return colorToFunctionalRgbString(value, type);
        };
      }

      function colorToFunctionalRgbaString(value, opt_type) {
        var aFormatter = createNumberFormatter(2);
        var rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        var comps = value.getComponents('rgb', opt_type).map(function (comp, index) {
          var formatter = index === 3 ? aFormatter : rgbFormatter;
          return formatter(comp);
        });
        return "rgba(".concat(comps.join(', '), ")");
      }

      function createFunctionalRgbaColorFormatter(type) {
        return function (value) {
          return colorToFunctionalRgbaString(value, type);
        };
      }

      function colorToFunctionalHslString(value) {
        var formatters = [createNumberFormatter(0), formatPercentage, formatPercentage];
        var comps = removeAlphaComponent(value.getComponents('hsl')).map(function (comp, index) {
          return formatters[index](comp);
        });
        return "hsl(".concat(comps.join(', '), ")");
      }

      function colorToFunctionalHslaString(value) {
        var formatters = [createNumberFormatter(0), formatPercentage, formatPercentage, createNumberFormatter(2)];
        var comps = value.getComponents('hsl').map(function (comp, index) {
          return formatters[index](comp);
        });
        return "hsla(".concat(comps.join(', '), ")");
      }

      function colorToObjectRgbString(value, type) {
        var formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        var names = ['r', 'g', 'b'];
        var comps = removeAlphaComponent(value.getComponents('rgb', type)).map(function (comp, index) {
          return "".concat(names[index], ": ").concat(formatter(comp));
        });
        return "{".concat(comps.join(', '), "}");
      }

      function createObjectRgbColorFormatter(type) {
        return function (value) {
          return colorToObjectRgbString(value, type);
        };
      }

      function colorToObjectRgbaString(value, type) {
        var aFormatter = createNumberFormatter(2);
        var rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        var names = ['r', 'g', 'b', 'a'];
        var comps = value.getComponents('rgb', type).map(function (comp, index) {
          var formatter = index === 3 ? aFormatter : rgbFormatter;
          return "".concat(names[index], ": ").concat(formatter(comp));
        });
        return "{".concat(comps.join(', '), "}");
      }

      function createObjectRgbaColorFormatter(type) {
        return function (value) {
          return colorToObjectRgbaString(value, type);
        };
      }

      [{
        format: {
          alpha: false,
          mode: 'rgb',
          notation: 'hex',
          type: 'int'
        },
        stringifier: colorToHexRgbString
      }, {
        format: {
          alpha: true,
          mode: 'rgb',
          notation: 'hex',
          type: 'int'
        },
        stringifier: colorToHexRgbaString
      }, {
        format: {
          alpha: false,
          mode: 'hsl',
          notation: 'func',
          type: 'int'
        },
        stringifier: colorToFunctionalHslString
      }, {
        format: {
          alpha: true,
          mode: 'hsl',
          notation: 'func',
          type: 'int'
        },
        stringifier: colorToFunctionalHslaString
      }].concat(_toConsumableArray(['int', 'float'].reduce(function (prev, type) {
        return [].concat(_toConsumableArray(prev), [{
          format: {
            alpha: false,
            mode: 'rgb',
            notation: 'func',
            type: type
          },
          stringifier: createFunctionalRgbColorFormatter(type)
        }, {
          format: {
            alpha: true,
            mode: 'rgb',
            notation: 'func',
            type: type
          },
          stringifier: createFunctionalRgbaColorFormatter(type)
        }, {
          format: {
            alpha: false,
            mode: 'rgb',
            notation: 'object',
            type: type
          },
          stringifier: createObjectRgbColorFormatter(type)
        }, {
          format: {
            alpha: true,
            mode: 'rgb',
            notation: 'object',
            type: type
          },
          stringifier: createObjectRgbaColorFormatter(type)
        }]);
      }, [])));

      var PointNdConstraint = /*#__PURE__*/function () {
        function PointNdConstraint(config) {
          _classCallCheck(this, PointNdConstraint);

          this.components = config.components;
          this.asm_ = config.assembly;
        }

        _createClass(PointNdConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var _this9 = this;

            var comps = this.asm_.toComponents(value).map(function (comp, index) {
              var _a, _b;

              return (_b = (_a = _this9.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
            });
            return this.asm_.fromComponents(comps);
          }
        }]);

        return PointNdConstraint;
      }();

      var className$9 = ClassName('pndtxt');

      var PointNdTextView = /*#__PURE__*/_createClass(function PointNdTextView(doc, config) {
        var _this10 = this;

        _classCallCheck(this, PointNdTextView);

        this.textViews = config.textViews;
        this.element = doc.createElement('div');
        this.element.classList.add(className$9());
        this.textViews.forEach(function (v) {
          var axisElem = doc.createElement('div');
          axisElem.classList.add(className$9('a'));
          axisElem.appendChild(v.element);

          _this10.element.appendChild(axisElem);
        });
      });

      function createAxisController(doc, config, index) {
        return new NumberTextController(doc, {
          arrayPosition: index === 0 ? 'fst' : index === config.axes.length - 1 ? 'lst' : 'mid',
          baseStep: config.axes[index].baseStep,
          parser: config.parser,
          props: config.axes[index].textProps,
          value: createValue(0, {
            constraint: config.axes[index].constraint
          }),
          viewProps: config.viewProps
        });
      }

      var PointNdTextController = /*#__PURE__*/_createClass(function PointNdTextController(doc, config) {
        var _this11 = this;

        _classCallCheck(this, PointNdTextController);

        this.value = config.value;
        this.viewProps = config.viewProps;
        this.acs_ = config.axes.map(function (_, index) {
          return createAxisController(doc, config, index);
        });
        this.acs_.forEach(function (c, index) {
          connectValues({
            primary: _this11.value,
            secondary: c.value,
            forward: function forward(p) {
              return config.assembly.toComponents(p.rawValue)[index];
            },
            backward: function backward(p, s) {
              var comps = config.assembly.toComponents(p.rawValue);
              comps[index] = s.rawValue;
              return config.assembly.fromComponents(comps);
            }
          });
        });
        this.view = new PointNdTextView(doc, {
          textViews: this.acs_.map(function (ac) {
            return ac.view;
          })
        });
      });

      function createStepConstraint(params, initialValue) {
        if ('step' in params && !isEmpty(params.step)) {
          return new StepConstraint(params.step, initialValue);
        }

        return null;
      }

      function createRangeConstraint(params) {
        if ('max' in params && !isEmpty(params.max) || 'min' in params && !isEmpty(params.min)) {
          return new RangeConstraint({
            max: params.max,
            min: params.min
          });
        }

        return null;
      }

      var Constants = {
        monitor: {
          defaultInterval: 200,
          defaultLineCount: 3
        }
      };
      var className$8 = ClassName('grl');

      var GraphLogView = /*#__PURE__*/function () {
        function GraphLogView(doc, config) {
          _classCallCheck(this, GraphLogView);

          this.onCursorChange_ = this.onCursorChange_.bind(this);
          this.onValueUpdate_ = this.onValueUpdate_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className$8());
          config.viewProps.bindClassModifiers(this.element);
          this.formatter_ = config.formatter;
          this.props_ = config.props;
          this.cursor_ = config.cursor;
          this.cursor_.emitter.on('change', this.onCursorChange_);
          var svgElem = doc.createElementNS(SVG_NS, 'svg');
          svgElem.classList.add(className$8('g'));
          svgElem.style.height = "calc(var(--bld-us) * ".concat(config.lineCount, ")");
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          var lineElem = doc.createElementNS(SVG_NS, 'polyline');
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          var tooltipElem = doc.createElement('div');
          tooltipElem.classList.add(className$8('t'), ClassName('tt')());
          this.element.appendChild(tooltipElem);
          this.tooltipElem_ = tooltipElem;
          config.value.emitter.on('change', this.onValueUpdate_);
          this.value = config.value;
          this.update_();
        }

        _createClass(GraphLogView, [{
          key: "graphElement",
          get: function get() {
            return this.svgElem_;
          }
        }, {
          key: "update_",
          value: function update_() {
            var bounds = this.svgElem_.getBoundingClientRect();
            var maxIndex = this.value.rawValue.length - 1;
            var min = this.props_.get('minValue');
            var max = this.props_.get('maxValue');
            var points = [];
            this.value.rawValue.forEach(function (v, index) {
              if (v === undefined) {
                return;
              }

              var x = mapRange(index, 0, maxIndex, 0, bounds.width);
              var y = mapRange(v, min, max, bounds.height, 0);
              points.push([x, y].join(','));
            });
            this.lineElem_.setAttributeNS(null, 'points', points.join(' '));
            var tooltipElem = this.tooltipElem_;
            var value = this.value.rawValue[this.cursor_.rawValue];

            if (value === undefined) {
              tooltipElem.classList.remove(className$8('t', 'a'));
              return;
            }

            var tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
            var ty = mapRange(value, min, max, bounds.height, 0);
            tooltipElem.style.left = "".concat(tx, "px");
            tooltipElem.style.top = "".concat(ty, "px");
            tooltipElem.textContent = "".concat(this.formatter_(value));

            if (!tooltipElem.classList.contains(className$8('t', 'a'))) {
              tooltipElem.classList.add(className$8('t', 'a'), className$8('t', 'in'));
              forceReflow(tooltipElem);
              tooltipElem.classList.remove(className$8('t', 'in'));
            }
          }
        }, {
          key: "onValueUpdate_",
          value: function onValueUpdate_() {
            this.update_();
          }
        }, {
          key: "onCursorChange_",
          value: function onCursorChange_() {
            this.update_();
          }
        }]);

        return GraphLogView;
      }();

      var GraphLogController = /*#__PURE__*/function () {
        function GraphLogController(doc, config) {
          _classCallCheck(this, GraphLogController);

          this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
          this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
          this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
          this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
          this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
          this.props_ = config.props;
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.cursor_ = createValue(-1);
          this.view = new GraphLogView(doc, {
            cursor: this.cursor_,
            formatter: config.formatter,
            lineCount: config.lineCount,
            props: this.props_,
            value: this.value,
            viewProps: this.viewProps
          });

          if (!supportsTouch(doc)) {
            this.view.element.addEventListener('mousemove', this.onGraphMouseMove_);
            this.view.element.addEventListener('mouseleave', this.onGraphMouseLeave_);
          } else {
            var ph = new PointerHandler(this.view.element);
            ph.emitter.on('down', this.onGraphPointerDown_);
            ph.emitter.on('move', this.onGraphPointerMove_);
            ph.emitter.on('up', this.onGraphPointerUp_);
          }
        }

        _createClass(GraphLogController, [{
          key: "onGraphMouseLeave_",
          value: function onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
          }
        }, {
          key: "onGraphMouseMove_",
          value: function onGraphMouseMove_(ev) {
            var bounds = this.view.element.getBoundingClientRect();
            this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
          }
        }, {
          key: "onGraphPointerDown_",
          value: function onGraphPointerDown_(ev) {
            this.onGraphPointerMove_(ev);
          }
        }, {
          key: "onGraphPointerMove_",
          value: function onGraphPointerMove_(ev) {
            if (!ev.data.point) {
              this.cursor_.rawValue = -1;
              return;
            }

            this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
          }
        }, {
          key: "onGraphPointerUp_",
          value: function onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
          }
        }]);

        return GraphLogController;
      }();

      var ButtonCellApi = /*#__PURE__*/function () {
        function ButtonCellApi(controller) {
          _classCallCheck(this, ButtonCellApi);

          this.controller_ = controller;
        }

        _createClass(ButtonCellApi, [{
          key: "disabled",
          get: function get() {
            return this.controller_.viewProps.get('disabled');
          },
          set: function set(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
          }
        }, {
          key: "title",
          get: function get() {
            var _a;

            return (_a = this.controller_.props.get('title')) !== null && _a !== void 0 ? _a : '';
          },
          set: function set(title) {
            this.controller_.props.set('title', title);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var _this12 = this;

            var bh = handler.bind(this);
            var emitter = this.controller_.emitter;
            emitter.on(eventName, function () {
              bh(new TpEvent(_this12));
            });
            return this;
          }
        }]);

        return ButtonCellApi;
      }();

      var TpButtonGridEvent = /*#__PURE__*/function (_TpEvent2) {
        _inherits(TpButtonGridEvent, _TpEvent2);

        var _super7 = _createSuper(TpButtonGridEvent);

        function TpButtonGridEvent(target, cell, index) {
          var _this13;

          _classCallCheck(this, TpButtonGridEvent);

          _this13 = _super7.call(this, target);
          _this13.cell = cell;
          _this13.index = index;
          return _this13;
        }

        return _createClass(TpButtonGridEvent);
      }(TpEvent);

      var ButtonGridApi = /*#__PURE__*/function (_BladeApi) {
        _inherits(ButtonGridApi, _BladeApi);

        var _super8 = _createSuper(ButtonGridApi);

        function ButtonGridApi(controller) {
          var _this14;

          _classCallCheck(this, ButtonGridApi);

          _this14 = _super8.call(this, controller);
          _this14.cellToApiMap_ = new Map();
          _this14.emitter_ = new Emitter();
          var gc = _this14.controller_.valueController;
          gc.cellControllers.forEach(function (cc, i) {
            var api = new ButtonCellApi(cc);

            _this14.cellToApiMap_.set(cc, api);

            cc.emitter.on('click', function () {
              var x = i % gc.size[0];
              var y = Math.floor(i / gc.size[0]);

              _this14.emitter_.emit('click', {
                event: new TpButtonGridEvent(_assertThisInitialized(_this14), api, [x, y])
              });
            });
          });
          return _this14;
        }

        _createClass(ButtonGridApi, [{
          key: "cell",
          value: function cell(x, y) {
            var gc = this.controller_.valueController;
            var cc = gc.cellControllers[y * gc.size[0] + x];
            return this.cellToApiMap_.get(cc);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var bh = handler.bind(this);
            this.emitter_.on(eventName, function (ev) {
              bh(ev.event);
            });
            return this;
          }
        }]);

        return ButtonGridApi;
      }(BladeApi);

      var ButtonGridController = /*#__PURE__*/function () {
        function ButtonGridController(doc, config) {
          var _this15 = this;

          _classCallCheck(this, ButtonGridController);

          this.size = config.size;

          var _this$size = _slicedToArray(this.size, 2),
              w = _this$size[0],
              h = _this$size[1];

          var bcs = [];

          for (var _y = 0; _y < h; _y++) {
            for (var x = 0; x < w; x++) {
              var bc = new ButtonController(doc, {
                props: ValueMap.fromObject(Object.assign({}, config.cellConfig(x, _y))),
                viewProps: ViewProps.create()
              });
              bcs.push(bc);
            }
          }

          this.cellCs_ = bcs;
          this.viewProps = ViewProps.create();
          this.viewProps.handleDispose(function () {
            _this15.cellCs_.forEach(function (c) {
              c.viewProps.set('disposed', true);
            });
          });
          this.view = new PlainView(doc, {
            viewProps: this.viewProps,
            viewName: 'btngrid'
          });
          this.view.element.style.gridTemplateColumns = "repeat(".concat(w, ", 1fr)");
          this.cellCs_.forEach(function (bc) {
            _this15.view.element.appendChild(bc.view.element);
          });
        }

        _createClass(ButtonGridController, [{
          key: "cellControllers",
          get: function get() {
            return this.cellCs_;
          }
        }]);

        return ButtonGridController;
      }();

      var ButtonGridBladePlugin = {
        id: 'buttongrid',
        type: 'blade',
        // TODO:
        css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            cells: p.required["function"],
            size: p.required.array(p.required.number),
            view: p.required.constant('buttongrid'),
            label: p.optional.string
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new ButtonGridController(args.document, {
              cellConfig: args.params.cells,
              size: args.params.size
            })
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }

          if (!(args.controller.valueController instanceof ButtonGridController)) {
            return null;
          }

          return new ButtonGridApi(args.controller);
        }
      };

      var CubicBezierApi = /*#__PURE__*/function (_BladeApi2) {
        _inherits(CubicBezierApi, _BladeApi2);

        var _super9 = _createSuper(CubicBezierApi);

        function CubicBezierApi() {
          _classCallCheck(this, CubicBezierApi);

          return _super9.apply(this, arguments);
        }

        _createClass(CubicBezierApi, [{
          key: "label",
          get: function get() {
            return this.controller_.props.get('label');
          },
          set: function set(label) {
            this.controller_.props.set('label', label);
          }
        }, {
          key: "value",
          get: function get() {
            return this.controller_.valueController.value.rawValue;
          },
          set: function set(value) {
            this.controller_.valueController.value.rawValue = value;
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var _this16 = this;

            var bh = handler.bind(this);
            this.controller_.valueController.value.emitter.on(eventName, function (ev) {
              bh(new TpChangeEvent(_this16, ev.rawValue, undefined, ev.options.last));
            });
            return this;
          }
        }]);

        return CubicBezierApi;
      }(BladeApi);

      function interpolate(x1, x2, t) {
        return x1 * (1 - t) + x2 * t;
      }

      var MAX_ITERATION = 20;
      var X_DELTA = 0.001;
      var CACHE_RESOLUTION = 100;

      function _y2(cb, x) {
        var dt = 0.25;
        var t = 0.5;
        var y = -1;

        for (var i = 0; i < MAX_ITERATION; i++) {
          var _cb$curve = cb.curve(t),
              _cb$curve2 = _slicedToArray(_cb$curve, 2),
              tx = _cb$curve2[0],
              ty = _cb$curve2[1];

          t += dt * (tx < x ? +1 : -1);
          y = ty;
          dt *= 0.5;

          if (Math.abs(x - tx) < X_DELTA) {
            break;
          }
        }

        return y;
      }

      var CubicBezier = /*#__PURE__*/function () {
        function CubicBezier() {
          var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

          _classCallCheck(this, CubicBezier);

          this.cache_ = [];
          this.comps_ = [x1, y1, x2, y2];
        }

        _createClass(CubicBezier, [{
          key: "x1",
          get: function get() {
            return this.comps_[0];
          }
        }, {
          key: "y1",
          get: function get() {
            return this.comps_[1];
          }
        }, {
          key: "x2",
          get: function get() {
            return this.comps_[2];
          }
        }, {
          key: "y2",
          get: function get() {
            return this.comps_[3];
          }
        }, {
          key: "curve",
          value: function curve(t) {
            var x01 = interpolate(0, this.x1, t);
            var y01 = interpolate(0, this.y1, t);
            var x12 = interpolate(this.x1, this.x2, t);
            var y12 = interpolate(this.y1, this.y2, t);
            var x23 = interpolate(this.x2, 1, t);
            var y23 = interpolate(this.y2, 1, t);
            var xr0 = interpolate(x01, x12, t);
            var yr0 = interpolate(y01, y12, t);
            var xr1 = interpolate(x12, x23, t);
            var yr1 = interpolate(y12, y23, t);
            return [interpolate(xr0, xr1, t), interpolate(yr0, yr1, t)];
          }
        }, {
          key: "y",
          value: function y(x) {
            if (this.cache_.length === 0) {
              var cache = [];

              for (var i = 0; i < CACHE_RESOLUTION; i++) {
                cache.push(_y2(this, mapRange(i, 0, CACHE_RESOLUTION - 1, 0, 1)));
              }

              this.cache_ = cache;
            }

            return this.cache_[Math.round(mapRange(constrainRange(x, 0, 1), 0, 1, 0, CACHE_RESOLUTION - 1))];
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]];
          }
        }], [{
          key: "isObject",
          value: function isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }

            if (!Array.isArray(obj)) {
              return false;
            }

            return typeof obj[0] === 'number' && typeof obj[1] === 'number' && typeof obj[2] === 'number' && typeof obj[3] === 'number';
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            return v1.x1 === v2.x1 && v1.y1 === v2.y1 && v1.x2 === v2.x2 && v1.y2 === v2.y2;
          }
        }]);

        return CubicBezier;
      }();

      var CubicBezierAssembly = {
        toComponents: function toComponents(p) {
          return p.toObject();
        },
        fromComponents: function fromComponents(comps) {
          return _construct(CubicBezier, _toConsumableArray(comps));
        }
      };

      function cubicBezierToString(cb) {
        var formatter = createNumberFormatter(2);
        var comps = cb.toObject().map(function (c) {
          return formatter(c);
        });
        return "cubic-bezier(".concat(comps.join(', '), ")");
      }

      var COMPS_EMPTY = [0, 0.5, 0.5, 1];

      function cubicBezierFromString(text) {
        var m = text.match(/^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/);

        if (!m) {
          return _construct(CubicBezier, COMPS_EMPTY);
        }

        var comps = [m[1], m[2], m[3], m[4]].reduce(function (comps, comp) {
          if (!comps) {
            return null;
          }

          var n = Number(comp);

          if (isNaN(n)) {
            return null;
          }

          return [].concat(_toConsumableArray(comps), [n]);
        }, []);
        return _construct(CubicBezier, _toConsumableArray(comps !== null && comps !== void 0 ? comps : COMPS_EMPTY));
      }

      var className$7 = ClassName('cbz');

      var CubicBezierView = /*#__PURE__*/_createClass(function CubicBezierView(doc, config) {
        _classCallCheck(this, CubicBezierView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$7());
        config.viewProps.bindClassModifiers(this.element);
        config.foldable.bindExpandedClass(this.element, className$7(undefined, 'expanded'));
        bindValueMap(config.foldable, 'completed', valueToClassName(this.element, className$7(undefined, 'cpl')));
        var headElem = doc.createElement('div');
        headElem.classList.add(className$7('h'));
        this.element.appendChild(headElem);
        var buttonElem = doc.createElement('button');
        buttonElem.classList.add(className$7('b'));
        config.viewProps.bindDisabled(buttonElem);
        var iconElem = doc.createElementNS(SVG_NS, 'svg');
        iconElem.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>';
        buttonElem.appendChild(iconElem);
        headElem.appendChild(buttonElem);
        this.buttonElement = buttonElem;
        var textElem = doc.createElement('div');
        textElem.classList.add(className$7('t'));
        headElem.appendChild(textElem);
        this.textElement = textElem;

        if (config.pickerLayout === 'inline') {
          var pickerElem = doc.createElement('div');
          pickerElem.classList.add(className$7('p'));
          this.element.appendChild(pickerElem);
          this.pickerElement = pickerElem;
        } else {
          this.pickerElement = null;
        }
      });

      var className$6 = ClassName('cbzp');

      var CubicBezierPickerView = /*#__PURE__*/_createClass(function CubicBezierPickerView(doc, config) {
        _classCallCheck(this, CubicBezierPickerView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$6());
        config.viewProps.bindClassModifiers(this.element);
        var graphElem = doc.createElement('div');
        graphElem.classList.add(className$6('g'));
        this.element.appendChild(graphElem);
        this.graphElement = graphElem;
        var textElem = doc.createElement('div');
        textElem.classList.add(className$6('t'));
        this.element.appendChild(textElem);
        this.textElement = textElem;
      });

      function waitToBeAddedToDom(elem, callback) {
        var ob = new MutationObserver(function (ml) {
          var _iterator = _createForOfIteratorHelper(ml),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var m = _step.value;

              if (m.type !== 'childList') {
                continue;
              }

              m.addedNodes.forEach(function (elem) {
                if (!elem.contains(elem)) {
                  return;
                }

                callback();
                ob.disconnect();
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        });
        var doc = elem.ownerDocument;
        ob.observe(doc.body, {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      var className$5 = ClassName('cbzg'); // TODO: Apply to core

      function compose(h1, h2) {
        return function (input) {
          return h2(h1(input));
        };
      }

      var CubicBezierGraphView = /*#__PURE__*/function () {
        function CubicBezierGraphView(doc, config) {
          var _this17 = this;

          _classCallCheck(this, CubicBezierGraphView);

          this.element = doc.createElement('div');
          this.element.classList.add(className$5());
          config.viewProps.bindClassModifiers(this.element);
          config.viewProps.bindTabIndex(this.element);
          var previewElem = doc.createElement('div');
          previewElem.classList.add(className$5('p'));
          this.element.appendChild(previewElem);
          this.previewElement = previewElem;
          var svgElem = doc.createElementNS(SVG_NS, 'svg');
          svgElem.classList.add(className$5('g'));
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          var guideElem = doc.createElementNS(SVG_NS, 'path');
          guideElem.classList.add(className$5('u'));
          this.svgElem_.appendChild(guideElem);
          this.guideElem_ = guideElem;
          var lineElem = doc.createElementNS(SVG_NS, 'polyline');
          lineElem.classList.add(className$5('l'));
          this.svgElem_.appendChild(lineElem);
          this.lineElem_ = lineElem;
          this.handleElems_ = [doc.createElement('div'), doc.createElement('div')];
          this.handleElems_.forEach(function (elem) {
            elem.classList.add(className$5('h'));

            _this17.element.appendChild(elem);
          });
          this.vectorElems_ = [doc.createElementNS(SVG_NS, 'line'), doc.createElementNS(SVG_NS, 'line')];
          this.vectorElems_.forEach(function (elem) {
            elem.classList.add(className$5('v'));

            _this17.svgElem_.appendChild(elem);
          });
          this.value_ = config.value;
          this.value_.emitter.on('change', this.onValueChange_.bind(this));
          this.sel_ = config.selection;
          this.handleElems_.forEach(function (elem, index) {
            bindValue(_this17.sel_, compose(function (selection) {
              return selection === index;
            }, valueToClassName(elem, className$5('h', 'sel'))));
          });
          waitToBeAddedToDom(this.element, function () {
            _this17.refresh();
          });
        }

        _createClass(CubicBezierGraphView, [{
          key: "getVertMargin_",
          value: function getVertMargin_(h) {
            return h * 0.25;
          }
        }, {
          key: "valueToPosition",
          value: function valueToPosition(x, y) {
            var bounds = this.element.getBoundingClientRect();
            var w = bounds.width;
            var h = bounds.height;
            var vm = this.getVertMargin_(h);
            return {
              x: mapRange(x, 0, 1, 0, w),
              y: mapRange(y, 0, 1, h - vm, vm)
            };
          }
        }, {
          key: "positionToValue",
          value: function positionToValue(x, y) {
            var bounds = this.element.getBoundingClientRect();
            var w = bounds.width;
            var h = bounds.height;
            var vm = this.getVertMargin_(h);
            return {
              x: constrainRange(mapRange(x, 0, w, 0, 1), 0, 1),
              y: mapRange(y, h - vm, vm, 0, 1)
            };
          }
        }, {
          key: "refresh",
          value: function refresh() {
            var _this18 = this;

            this.guideElem_.setAttributeNS(null, 'd', [0, 1].map(function (index) {
              var p1 = _this18.valueToPosition(0, index);

              var p2 = _this18.valueToPosition(1, index);

              return ["M ".concat(p1.x, ",").concat(p1.y), "L ".concat(p2.x, ",").concat(p2.y)].join(' ');
            }).join(' '));
            var bezier = this.value_.rawValue;
            var points = [];
            var t = 0;

            for (;;) {
              var p = this.valueToPosition.apply(this, _toConsumableArray(bezier.curve(t)));
              points.push([p.x, p.y].join(','));

              if (t >= 1) {
                break;
              }

              t = Math.min(t + 0.05, 1);
            }

            this.lineElem_.setAttributeNS(null, 'points', points.join(' '));
            var obj = bezier.toObject();
            [0, 1].forEach(function (index) {
              var p1 = _this18.valueToPosition(index, index);

              var p2 = _this18.valueToPosition(obj[index * 2], obj[index * 2 + 1]);

              var vElem = _this18.vectorElems_[index];
              vElem.setAttributeNS(null, 'x1', String(p1.x));
              vElem.setAttributeNS(null, 'y1', String(p1.y));
              vElem.setAttributeNS(null, 'x2', String(p2.x));
              vElem.setAttributeNS(null, 'y2', String(p2.y));
              var hElem = _this18.handleElems_[index];
              hElem.style.left = "".concat(p2.x, "px");
              hElem.style.top = "".concat(p2.y, "px");
            });
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.refresh();
          }
        }]);

        return CubicBezierGraphView;
      }();

      var TICK_COUNT = 24;
      var PREVIEW_DELAY = 400;
      var PREVIEW_DURATION = 1000;
      var className$4 = ClassName('cbzprv');

      var CubicBezierPreviewView = /*#__PURE__*/function () {
        function CubicBezierPreviewView(doc, config) {
          var _this19 = this;

          _classCallCheck(this, CubicBezierPreviewView);

          this.stopped_ = true;
          this.startTime_ = -1;
          this.onDispose_ = this.onDispose_.bind(this);
          this.onTimer_ = this.onTimer_.bind(this);
          this.onValueChange_ = this.onValueChange_.bind(this);
          this.element = doc.createElement('div');
          this.element.classList.add(className$4());
          config.viewProps.bindClassModifiers(this.element);
          var svgElem = doc.createElementNS(SVG_NS, 'svg');
          svgElem.classList.add(className$4('g'));
          this.element.appendChild(svgElem);
          this.svgElem_ = svgElem;
          var ticksElem = doc.createElementNS(SVG_NS, 'path');
          ticksElem.classList.add(className$4('t'));
          this.svgElem_.appendChild(ticksElem);
          this.ticksElem_ = ticksElem;
          var markerElem = doc.createElement('div');
          markerElem.classList.add(className$4('m'));
          this.element.appendChild(markerElem);
          this.markerElem_ = markerElem;
          this.value_ = config.value;
          this.value_.emitter.on('change', this.onValueChange_);
          config.viewProps.handleDispose(this.onDispose_);
          waitToBeAddedToDom(this.element, function () {
            _this19.refresh();
          });
        }

        _createClass(CubicBezierPreviewView, [{
          key: "play",
          value: function play() {
            this.stop();
            this.updateMarker_(0);
            this.markerElem_.classList.add(className$4('m', 'a'));
            this.startTime_ = new Date().getTime() + PREVIEW_DELAY;
            this.stopped_ = false;
            requestAnimationFrame(this.onTimer_);
          }
        }, {
          key: "stop",
          value: function stop() {
            this.stopped_ = true;
            this.markerElem_.classList.remove(className$4('m', 'a'));
          }
        }, {
          key: "onDispose_",
          value: function onDispose_() {
            this.stop();
          }
        }, {
          key: "updateMarker_",
          value: function updateMarker_(progress) {
            var p = this.value_.rawValue.y(constrainRange(progress, 0, 1));
            this.markerElem_.style.left = "".concat(p * 100, "%");
          }
        }, {
          key: "refresh",
          value: function refresh() {
            var bounds = this.svgElem_.getBoundingClientRect();
            var w = bounds.width;
            var h = bounds.height;
            var ds = [];
            var bezier = this.value_.rawValue;

            for (var i = 0; i < TICK_COUNT; i++) {
              var px = mapRange(i, 0, TICK_COUNT - 1, 0, 1);
              var x = mapRange(bezier.y(px), 0, 1, 0, w);
              ds.push("M ".concat(x, ",0 v").concat(h));
            }

            this.ticksElem_.setAttributeNS(null, 'd', ds.join(' '));
          }
        }, {
          key: "onTimer_",
          value: function onTimer_() {
            if (this.startTime_ === null) {
              return;
            }

            var dt = new Date().getTime() - this.startTime_;
            var p = dt / PREVIEW_DURATION;
            this.updateMarker_(p);

            if (dt > PREVIEW_DURATION + PREVIEW_DELAY) {
              this.stop();
            }

            if (!this.stopped_) {
              requestAnimationFrame(this.onTimer_);
            }
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.refresh();
            this.play();
          }
        }]);

        return CubicBezierPreviewView;
      }();

      function getDistance(x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function lockAngle(x1, y1, x2, y2) {
        var d = getDistance(x1, y1, x2, y2);
        var a = Math.atan2(y2 - y1, x2 - x1);
        var la = Math.round(a / (Math.PI / 4)) * Math.PI / 4;
        return {
          x: x1 + Math.cos(la) * d,
          y: y1 + Math.sin(la) * d
        };
      }

      var CubicBezierGraphController = /*#__PURE__*/function () {
        function CubicBezierGraphController(doc, config) {
          var _this20 = this;

          _classCallCheck(this, CubicBezierGraphController);

          this.onKeyDown_ = this.onKeyDown_.bind(this);
          this.onKeyUp_ = this.onKeyUp_.bind(this);
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.baseStep_ = config.baseStep;
          this.value = config.value;
          this.sel_ = createValue(0);
          this.viewProps = config.viewProps;
          this.view = new CubicBezierGraphView(doc, {
            selection: this.sel_,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.element.addEventListener('keydown', this.onKeyDown_);
          this.view.element.addEventListener('keyup', this.onKeyUp_);
          this.prevView_ = new CubicBezierPreviewView(doc, {
            value: this.value,
            viewProps: this.viewProps
          });
          this.prevView_.element.addEventListener('mousedown', function (ev) {
            ev.stopImmediatePropagation();
            ev.preventDefault();

            _this20.prevView_.play();
          });
          this.view.previewElement.appendChild(this.prevView_.element);
          var ptHandler = new PointerHandler(this.view.element);
          ptHandler.emitter.on('down', this.onPointerDown_);
          ptHandler.emitter.on('move', this.onPointerMove_);
          ptHandler.emitter.on('up', this.onPointerUp_);
        }

        _createClass(CubicBezierGraphController, [{
          key: "refresh",
          value: function refresh() {
            this.view.refresh();
            this.prevView_.refresh();
            this.prevView_.play();
          }
        }, {
          key: "updateValue_",
          value: function updateValue_(point, locksAngle, opts) {
            var index = this.sel_.rawValue;
            var comps = this.value.rawValue.toObject();
            var vp = this.view.positionToValue(point.x, point.y);
            var v = locksAngle ? lockAngle(index, index, vp.x, vp.y) : vp;
            comps[index * 2] = v.x;
            comps[index * 2 + 1] = v.y;
            this.value.setRawValue(_construct(CubicBezier, _toConsumableArray(comps)), opts);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            var data = ev.data;

            if (!data.point) {
              return;
            }

            var bezier = this.value.rawValue;
            var p1 = this.view.valueToPosition(bezier.x1, bezier.y1);
            var d1 = getDistance(data.point.x, data.point.y, p1.x, p1.y);
            var p2 = this.view.valueToPosition(bezier.x2, bezier.y2);
            var d2 = getDistance(data.point.x, data.point.y, p2.x, p2.y);
            this.sel_.rawValue = d1 <= d2 ? 0 : 1;
            this.updateValue_(data.point, ev.shiftKey, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            var data = ev.data;

            if (!data.point) {
              return;
            }

            this.updateValue_(data.point, ev.shiftKey, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            var data = ev.data;

            if (!data.point) {
              return;
            }

            this.updateValue_(data.point, ev.shiftKey, {
              forceEmit: true,
              last: true
            });
          }
        }, {
          key: "onKeyDown_",
          value: function onKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }

            var index = this.sel_.rawValue;
            var comps = this.value.rawValue.toObject();
            comps[index * 2] += getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            comps[index * 2 + 1] += getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            this.value.setRawValue(_construct(CubicBezier, _toConsumableArray(comps)), {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onKeyUp_",
          value: function onKeyUp_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }

            var xStep = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            var yStep = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));

            if (xStep === 0 && yStep === 0) {
              return;
            }

            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }]);

        return CubicBezierGraphController;
      }();

      var CubicBezierPickerController = /*#__PURE__*/function () {
        function CubicBezierPickerController(doc, config) {
          _classCallCheck(this, CubicBezierPickerController);

          this.value = config.value;
          this.viewProps = config.viewProps;
          this.view = new CubicBezierPickerView(doc, {
            viewProps: this.viewProps
          });
          this.gc_ = new CubicBezierGraphController(doc, {
            baseStep: config.axis.baseStep,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.graphElement.appendChild(this.gc_.view.element);
          var xAxis = Object.assign(Object.assign({}, config.axis), {
            constraint: new RangeConstraint({
              max: 1,
              min: 0
            })
          });
          var yAxis = Object.assign(Object.assign({}, config.axis), {
            constraint: undefined
          });
          this.tc_ = new PointNdTextController(doc, {
            assembly: CubicBezierAssembly,
            axes: [xAxis, yAxis, xAxis, yAxis],
            parser: parseNumber,
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.tc_.view.element);
        }

        _createClass(CubicBezierPickerController, [{
          key: "allFocusableElements",
          get: function get() {
            return [this.gc_.view.element].concat(_toConsumableArray(this.tc_.view.textViews.map(function (v) {
              return v.inputElement;
            })));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.gc_.refresh();
          }
        }]);

        return CubicBezierPickerController;
      }();

      var CubicBezierController = /*#__PURE__*/function () {
        function CubicBezierController(doc, config) {
          var _this21 = this;

          _classCallCheck(this, CubicBezierController);

          this.onButtonBlur_ = this.onButtonBlur_.bind(this);
          this.onButtonClick_ = this.onButtonClick_.bind(this);
          this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
          this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
          this.value = config.value;
          this.viewProps = config.viewProps;
          this.foldable_ = createFoldable(config.expanded);
          this.view = new CubicBezierView(doc, {
            foldable: this.foldable_,
            pickerLayout: config.pickerLayout,
            viewProps: this.viewProps
          });
          this.view.buttonElement.addEventListener('blur', this.onButtonBlur_);
          this.view.buttonElement.addEventListener('click', this.onButtonClick_);
          this.tc_ = new TextController(doc, {
            parser: cubicBezierFromString,
            props: ValueMap.fromObject({
              formatter: cubicBezierToString
            }),
            value: this.value,
            viewProps: this.viewProps
          });
          this.view.textElement.appendChild(this.tc_.view.element);
          this.popC_ = config.pickerLayout === 'popup' ? new PopupController(doc, {
            viewProps: this.viewProps
          }) : null;
          var pickerC = new CubicBezierPickerController(doc, {
            axis: config.axis,
            value: this.value,
            viewProps: this.viewProps
          });
          pickerC.allFocusableElements.forEach(function (elem) {
            elem.addEventListener('blur', _this21.onPopupChildBlur_);
            elem.addEventListener('keydown', _this21.onPopupChildKeydown_);
          });
          this.pickerC_ = pickerC;

          if (this.popC_) {
            this.view.element.appendChild(this.popC_.view.element);
            this.popC_.view.element.appendChild(this.pickerC_.view.element);
            bindValue(this.popC_.shows, function (shows) {
              if (shows) {
                pickerC.refresh();
              }
            });
            connectValues({
              primary: this.foldable_.value('expanded'),
              secondary: this.popC_.shows,
              forward: function forward(p) {
                return p.rawValue;
              },
              backward: function backward(_, s) {
                return s.rawValue;
              }
            });
          } else if (this.view.pickerElement) {
            this.view.pickerElement.appendChild(this.pickerC_.view.element);
            bindFoldable(this.foldable_, this.view.pickerElement);
          }
        }

        _createClass(CubicBezierController, [{
          key: "onButtonBlur_",
          value: function onButtonBlur_(ev) {
            if (!this.popC_) {
              return;
            }

            var nextTarget = forceCast(ev.relatedTarget);

            if (!nextTarget || !this.popC_.view.element.contains(nextTarget)) {
              this.popC_.shows.rawValue = false;
            }
          }
        }, {
          key: "onButtonClick_",
          value: function onButtonClick_() {
            this.foldable_.set('expanded', !this.foldable_.get('expanded'));

            if (this.foldable_.get('expanded')) {
              this.pickerC_.allFocusableElements[0].focus();
            }
          }
        }, {
          key: "onPopupChildBlur_",
          value: function onPopupChildBlur_(ev) {
            if (!this.popC_) {
              return;
            }

            var elem = this.popC_.view.element;
            var nextTarget = findNextTarget(ev);

            if (nextTarget && elem.contains(nextTarget)) {
              // Next target is in the popup
              return;
            }

            if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
              // Next target is the trigger button
              return;
            }

            this.popC_.shows.rawValue = false;
          }
        }, {
          key: "onPopupChildKeydown_",
          value: function onPopupChildKeydown_(ev) {
            if (!this.popC_) {
              return;
            }

            if (ev.key === 'Escape') {
              this.popC_.shows.rawValue = false;
            }
          }
        }]);

        return CubicBezierController;
      }();

      function createConstraint$1() {
        return new PointNdConstraint({
          assembly: CubicBezierAssembly,
          components: [0, 1, 2, 3].map(function (index) {
            return index % 2 === 0 ? new RangeConstraint({
              min: 0,
              max: 1
            }) : undefined;
          })
        });
      }

      var CubicBezierBladePlugin = {
        id: 'cubic-bezier',
        type: 'blade',
        css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            value: p.required.array(p.required.number),
            view: p.required.constant('cubicbezier'),
            expanded: p.optional["boolean"],
            label: p.optional.string,
            picker: p.optional.custom(function (v) {
              return v === 'inline' || v === 'popup' ? v : undefined;
            })
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          var _a, _b;

          var rv = _construct(CubicBezier, _toConsumableArray(args.params.value));

          var v = createValue(rv, {
            constraint: createConstraint$1(),
            equals: CubicBezier.equals
          });
          var vc = new CubicBezierController(args.document, {
            axis: {
              baseStep: 0.1,
              textProps: ValueMap.fromObject({
                draggingScale: 0.01,
                formatter: createNumberFormatter(2)
              })
            },
            expanded: (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
            pickerLayout: (_b = args.params.picker) !== null && _b !== void 0 ? _b : 'popup',
            value: v,
            viewProps: args.viewProps
          });
          return new LabeledValueController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: vc
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof LabeledValueController)) {
            return null;
          }

          if (!(args.controller.valueController instanceof CubicBezierController)) {
            return null;
          }

          return new CubicBezierApi(args.controller);
        }
      };

      var FpsGraphBladeApi = /*#__PURE__*/function (_BladeApi3) {
        _inherits(FpsGraphBladeApi, _BladeApi3);

        var _super10 = _createSuper(FpsGraphBladeApi);

        function FpsGraphBladeApi() {
          _classCallCheck(this, FpsGraphBladeApi);

          return _super10.apply(this, arguments);
        }

        _createClass(FpsGraphBladeApi, [{
          key: "begin",
          value: function begin() {
            this.controller_.valueController.begin();
          }
        }, {
          key: "end",
          value: function end() {
            this.controller_.valueController.end();
          }
        }]);

        return FpsGraphBladeApi;
      }(BladeApi);

      var MAX_TIMESTAMPS = 20;

      var Fpswatch = /*#__PURE__*/function () {
        function Fpswatch() {
          _classCallCheck(this, Fpswatch);

          this.start_ = null;
          this.duration_ = 0;
          this.fps_ = null;
          this.frameCount_ = 0;
          this.timestamps_ = [];
        }

        _createClass(Fpswatch, [{
          key: "duration",
          get: function get() {
            return this.duration_;
          }
        }, {
          key: "fps",
          get: function get() {
            return this.fps_;
          }
        }, {
          key: "begin",
          value: function begin(now) {
            this.start_ = now.getTime();
          }
        }, {
          key: "calculateFps_",
          value: function calculateFps_(nowTime) {
            if (this.timestamps_.length === 0) {
              return null;
            }

            var ts = this.timestamps_[0];
            return 1000 * (this.frameCount_ - ts.frameCount) / (nowTime - ts.time);
          }
        }, {
          key: "compactTimestamps_",
          value: function compactTimestamps_() {
            if (this.timestamps_.length <= MAX_TIMESTAMPS) {
              return;
            }

            var len = this.timestamps_.length - MAX_TIMESTAMPS;
            this.timestamps_.splice(0, len);
            var df = this.timestamps_[0].frameCount;
            this.timestamps_.forEach(function (ts) {
              ts.frameCount -= df;
            });
            this.frameCount_ -= df;
          }
        }, {
          key: "end",
          value: function end(now) {
            if (this.start_ === null) {
              return;
            }

            var t = now.getTime();
            this.duration_ = t - this.start_;
            this.start_ = null;
            this.fps_ = this.calculateFps_(t);
            this.timestamps_.push({
              frameCount: this.frameCount_,
              time: t
            });
            ++this.frameCount_;
            this.compactTimestamps_();
          }
        }]);

        return Fpswatch;
      }();

      var className$3 = ClassName('fps');

      var FpsView = /*#__PURE__*/_createClass(function FpsView(doc, config) {
        _classCallCheck(this, FpsView);

        this.element = doc.createElement('div');
        this.element.classList.add(className$3());
        config.viewProps.bindClassModifiers(this.element);
        this.graphElement = doc.createElement('div');
        this.graphElement.classList.add(className$3('g'));
        this.element.appendChild(this.graphElement);
        var labelElement = doc.createElement('div');
        labelElement.classList.add(className$3('l'));
        this.element.appendChild(labelElement);
        var valueElement = doc.createElement('span');
        valueElement.classList.add(className$3('v'));
        valueElement.textContent = '--';
        labelElement.appendChild(valueElement);
        this.valueElement = valueElement;
        var unitElement = doc.createElement('span');
        unitElement.classList.add(className$3('u'));
        unitElement.textContent = 'FPS';
        labelElement.appendChild(unitElement);
      });

      var FpsGraphController = /*#__PURE__*/function () {
        function FpsGraphController(doc, config) {
          var _this22 = this;

          _classCallCheck(this, FpsGraphController);

          this.stopwatch_ = new Fpswatch();
          this.onTick_ = this.onTick_.bind(this);
          this.ticker_ = config.ticker;
          this.ticker_.emitter.on('tick', this.onTick_);
          this.value_ = config.value;
          this.viewProps = config.viewProps;
          this.view = new FpsView(doc, {
            viewProps: this.viewProps
          });
          this.graphC_ = new GraphLogController(doc, {
            formatter: createNumberFormatter(0),
            lineCount: config.lineCount,
            props: ValueMap.fromObject({
              maxValue: config.maxValue,
              minValue: config.minValue
            }),
            value: this.value_,
            viewProps: this.viewProps
          });
          this.view.graphElement.appendChild(this.graphC_.view.element);
          this.viewProps.handleDispose(function () {
            _this22.graphC_.viewProps.set('disposed', true);

            _this22.ticker_.dispose();
          });
        }

        _createClass(FpsGraphController, [{
          key: "begin",
          value: function begin() {
            this.stopwatch_.begin(new Date());
          }
        }, {
          key: "end",
          value: function end() {
            this.stopwatch_.end(new Date());
          }
        }, {
          key: "onTick_",
          value: function onTick_() {
            var fps = this.stopwatch_.fps;

            if (fps !== null) {
              var buffer = this.value_.rawValue;
              this.value_.rawValue = createPushedBuffer(buffer, fps);
              this.view.valueElement.textContent = fps.toFixed(0);
            }
          }
        }]);

        return FpsGraphController;
      }();

      function createTicker(document, interval) {
        return interval === 0 ? new ManualTicker() : new IntervalTicker(document, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
      }

      var FpsGraphBladePlugin = {
        id: 'fpsgraph',
        type: 'blade',
        accept: function accept(params) {
          var p = ParamsParsers;
          var result = parseParams(params, {
            view: p.required.constant('fpsgraph'),
            interval: p.optional.number,
            label: p.optional.string,
            lineCount: p.optional.number,
            max: p.optional.number,
            min: p.optional.number
          });
          return result ? {
            params: result
          } : null;
        },
        controller: function controller(args) {
          var _a, _b, _c, _d;

          var interval = (_a = args.params.interval) !== null && _a !== void 0 ? _a : 500;
          return new LabelController(args.document, {
            blade: args.blade,
            props: ValueMap.fromObject({
              label: args.params.label
            }),
            valueController: new FpsGraphController(args.document, {
              lineCount: (_b = args.params.lineCount) !== null && _b !== void 0 ? _b : 2,
              maxValue: (_c = args.params.max) !== null && _c !== void 0 ? _c : 90,
              minValue: (_d = args.params.min) !== null && _d !== void 0 ? _d : 0,
              ticker: createTicker(args.document, interval),
              value: initializeBuffer(80),
              viewProps: args.viewProps
            })
          });
        },
        api: function api(args) {
          if (!(args.controller instanceof LabelController)) {
            return null;
          }

          if (!(args.controller.valueController instanceof FpsGraphController)) {
            return null;
          }

          return new FpsGraphBladeApi(args.controller);
        }
      };

      var Interval = /*#__PURE__*/function () {
        function Interval(min, max) {
          _classCallCheck(this, Interval);

          this.min = min;
          this.max = max;
        }

        _createClass(Interval, [{
          key: "length",
          get: function get() {
            return this.max - this.min;
          }
        }, {
          key: "toObject",
          value: function toObject() {
            return {
              min: this.min,
              max: this.max
            };
          }
        }], [{
          key: "isObject",
          value: function isObject(obj) {
            if (_typeof$1(obj) !== 'object' || obj === null) {
              return false;
            }

            var min = obj.min;
            var max = obj.max;

            if (typeof min !== 'number' || typeof max !== 'number') {
              return false;
            }

            return true;
          }
        }, {
          key: "equals",
          value: function equals(v1, v2) {
            return v1.min === v2.min && v1.max === v2.max;
          }
        }]);

        return Interval;
      }();

      var IntervalAssembly = {
        fromComponents: function fromComponents(comps) {
          return new Interval(comps[0], comps[1]);
        },
        toComponents: function toComponents(p) {
          return [p.min, p.max];
        }
      };

      var IntervalConstraint = /*#__PURE__*/function () {
        function IntervalConstraint(edge) {
          _classCallCheck(this, IntervalConstraint);

          this.edge = edge;
        }

        _createClass(IntervalConstraint, [{
          key: "constrain",
          value: function constrain(value) {
            var _a, _b, _c, _d, _e, _f, _g, _h;

            if (value.min <= value.max) {
              return new Interval((_b = (_a = this.edge) === null || _a === void 0 ? void 0 : _a.constrain(value.min)) !== null && _b !== void 0 ? _b : value.min, (_d = (_c = this.edge) === null || _c === void 0 ? void 0 : _c.constrain(value.max)) !== null && _d !== void 0 ? _d : value.max);
            }

            var c = (value.min + value.max) / 2;
            return new Interval((_f = (_e = this.edge) === null || _e === void 0 ? void 0 : _e.constrain(c)) !== null && _f !== void 0 ? _f : c, (_h = (_g = this.edge) === null || _g === void 0 ? void 0 : _g.constrain(c)) !== null && _h !== void 0 ? _h : c);
          }
        }]);

        return IntervalConstraint;
      }();

      var className$2 = ClassName('rsltxt');

      var RangeSliderTextView = /*#__PURE__*/_createClass(function RangeSliderTextView(doc, config) {
        _classCallCheck(this, RangeSliderTextView);

        this.sliderView_ = config.sliderView;
        this.textView_ = config.textView;
        this.element = doc.createElement('div');
        this.element.classList.add(className$2());
        var sliderElem = doc.createElement('div');
        sliderElem.classList.add(className$2('s'));
        sliderElem.appendChild(this.sliderView_.element);
        this.element.appendChild(sliderElem);
        var textElem = doc.createElement('div');
        textElem.classList.add(className$2('t'));
        textElem.appendChild(this.textView_.element);
        this.element.appendChild(textElem);
      });

      var className$1 = ClassName('rsl');

      var RangeSliderView = /*#__PURE__*/function () {
        function RangeSliderView(doc, config) {
          _classCallCheck(this, RangeSliderView);

          this.maxValue_ = config.maxValue;
          this.minValue_ = config.minValue;
          this.element = doc.createElement('div');
          this.element.classList.add(className$1());
          config.viewProps.bindClassModifiers(this.element);
          this.value_ = config.value;
          this.value_.emitter.on('change', this.onValueChange_.bind(this));
          var trackElem = doc.createElement('div');
          trackElem.classList.add(className$1('t'));
          this.element.appendChild(trackElem);
          this.trackElement = trackElem;
          var barElem = doc.createElement('div');
          barElem.classList.add(className$1('b'));
          trackElem.appendChild(barElem);
          this.barElement = barElem;
          var knobElems = ['min', 'max'].map(function (modifier) {
            var elem = doc.createElement('div');
            elem.classList.add(className$1('k'), className$1('k', modifier));
            trackElem.appendChild(elem);
            return elem;
          });
          this.knobElements = [knobElems[0], knobElems[1]];
          this.update();
        }

        _createClass(RangeSliderView, [{
          key: "valueToX_",
          value: function valueToX_(value) {
            return constrainRange(mapRange(value, this.minValue_, this.maxValue_, 0, 1), 0, 1) * 100;
          }
        }, {
          key: "update",
          value: function update() {
            var v = this.value_.rawValue;

            if (v.length === 0) {
              this.element.classList.add(className$1(undefined, 'zero'));
            } else {
              this.element.classList.remove(className$1(undefined, 'zero'));
            }

            var xs = [this.valueToX_(v.min), this.valueToX_(v.max)];
            this.barElement.style.left = "".concat(xs[0], "%");
            this.barElement.style.right = "".concat(100 - xs[1], "%");
            this.knobElements.forEach(function (elem, index) {
              elem.style.left = "".concat(xs[index], "%");
            });
          }
        }, {
          key: "onValueChange_",
          value: function onValueChange_() {
            this.update();
          }
        }]);

        return RangeSliderView;
      }();

      var RangeSliderController = /*#__PURE__*/function () {
        function RangeSliderController(doc, config) {
          _classCallCheck(this, RangeSliderController);

          this.grabbing_ = null;
          this.grabOffset_ = 0;
          this.onPointerDown_ = this.onPointerDown_.bind(this);
          this.onPointerMove_ = this.onPointerMove_.bind(this);
          this.onPointerUp_ = this.onPointerUp_.bind(this);
          this.maxValue_ = config.maxValue;
          this.minValue_ = config.minValue;
          this.viewProps = config.viewProps;
          this.value = config.value;
          this.view = new RangeSliderView(doc, {
            maxValue: config.maxValue,
            minValue: config.minValue,
            value: this.value,
            viewProps: config.viewProps
          });
          var ptHandler = new PointerHandler(this.view.trackElement);
          ptHandler.emitter.on('down', this.onPointerDown_);
          ptHandler.emitter.on('move', this.onPointerMove_);
          ptHandler.emitter.on('up', this.onPointerUp_);
        }

        _createClass(RangeSliderController, [{
          key: "ofs_",
          value: function ofs_() {
            if (this.grabbing_ === 'min') {
              return this.view.knobElements[0].getBoundingClientRect().width / 2;
            }

            if (this.grabbing_ === 'max') {
              return -this.view.knobElements[1].getBoundingClientRect().width / 2;
            }

            return 0;
          }
        }, {
          key: "valueFromData_",
          value: function valueFromData_(data) {
            if (!data.point) {
              return null;
            }

            var p = (data.point.x + this.ofs_()) / data.bounds.width;
            return mapRange(p, 0, 1, this.minValue_, this.maxValue_);
          }
        }, {
          key: "onPointerDown_",
          value: function onPointerDown_(ev) {
            if (!ev.data.point) {
              return;
            }

            var p = ev.data.point.x / ev.data.bounds.width;
            var v = this.value.rawValue;
            var pmin = mapRange(v.min, this.minValue_, this.maxValue_, 0, 1);
            var pmax = mapRange(v.max, this.minValue_, this.maxValue_, 0, 1);

            if (Math.abs(pmax - p) <= 0.025) {
              this.grabbing_ = 'max';
            } else if (Math.abs(pmin - p) <= 0.025) {
              this.grabbing_ = 'min';
            } else if (p >= pmin && p <= pmax) {
              this.grabbing_ = 'length';
              this.grabOffset_ = mapRange(p - pmin, 0, 1, 0, this.maxValue_ - this.minValue_);
            } else if (p < pmin) {
              this.grabbing_ = 'min';
              this.onPointerMove_(ev);
            } else if (p > pmax) {
              this.grabbing_ = 'max';
              this.onPointerMove_(ev);
            }
          }
        }, {
          key: "applyPointToValue_",
          value: function applyPointToValue_(data, opts) {
            var v = this.valueFromData_(data);

            if (v === null) {
              return;
            }

            if (this.grabbing_ === 'min') {
              this.value.setRawValue(new Interval(v, this.value.rawValue.max), opts);
            } else if (this.grabbing_ === 'max') {
              this.value.setRawValue(new Interval(this.value.rawValue.min, v), opts);
            } else if (this.grabbing_ === 'length') {
              var len = this.value.rawValue.length;
              var min = v - this.grabOffset_;
              var max = min + len;

              if (min < this.minValue_) {
                min = this.minValue_;
                max = this.minValue_ + len;
              } else if (max > this.maxValue_) {
                min = this.maxValue_ - len;
                max = this.maxValue_;
              }

              this.value.setRawValue(new Interval(min, max), opts);
            }
          }
        }, {
          key: "onPointerMove_",
          value: function onPointerMove_(ev) {
            this.applyPointToValue_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
        }, {
          key: "onPointerUp_",
          value: function onPointerUp_(ev) {
            this.applyPointToValue_(ev.data, {
              forceEmit: true,
              last: true
            });
            this.grabbing_ = null;
          }
        }]);

        return RangeSliderController;
      }();

      var RangeSliderTextController = /*#__PURE__*/function () {
        function RangeSliderTextController(doc, config) {
          _classCallCheck(this, RangeSliderTextController);

          this.value = config.value;
          this.viewProps = config.viewProps;
          this.sc_ = new RangeSliderController(doc, config);
          var axis = {
            baseStep: config.baseStep,
            constraint: config.constraint,
            textProps: ValueMap.fromObject({
              draggingScale: config.draggingScale,
              formatter: config.formatter
            })
          };
          this.tc_ = new PointNdTextController(doc, {
            assembly: IntervalAssembly,
            axes: [axis, axis],
            parser: config.parser,
            value: this.value,
            viewProps: config.viewProps
          });
          this.view = new RangeSliderTextView(doc, {
            sliderView: this.sc_.view,
            textView: this.tc_.view
          });
        }

        _createClass(RangeSliderTextController, [{
          key: "textController",
          get: function get() {
            return this.tc_;
          }
        }]);

        return RangeSliderTextController;
      }();

      function intervalFromUnknown(value) {
        return Interval.isObject(value) ? new Interval(value.min, value.max) : new Interval(0, 0);
      }

      function writeInterval(target, value) {
        target.writeProperty('max', value.max);
        target.writeProperty('min', value.min);
      }

      function createConstraint(params) {
        var constraints = [];
        var rc = createRangeConstraint(params);

        if (rc) {
          constraints.push(rc);
        }

        var sc = createStepConstraint(params);

        if (sc) {
          constraints.push(sc);
        }

        return new IntervalConstraint(new CompositeConstraint(constraints));
      }

      var IntervalInputPlugin = {
        id: 'input-interval',
        type: 'input',
        css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
        accept: function accept(exValue, params) {
          if (!Interval.isObject(exValue)) {
            return null;
          }

          var p = ParamsParsers;
          var result = parseParams(params, {
            format: p.optional["function"],
            max: p.optional.number,
            min: p.optional.number,
            step: p.optional.number
          });
          return result ? {
            initialValue: new Interval(exValue.min, exValue.max),
            params: result
          } : null;
        },
        binding: {
          reader: function reader(_args) {
            return intervalFromUnknown;
          },
          constraint: function constraint(args) {
            return createConstraint(args.params);
          },
          equals: Interval.equals,
          writer: function writer(_args) {
            return writeInterval;
          }
        },
        controller: function controller(args) {
          var _a;

          var v = args.value;
          var c = args.constraint;

          if (!(c instanceof IntervalConstraint)) {
            throw TpError.shouldNeverHappen();
          }

          var midValue = (v.rawValue.min + v.rawValue.max) / 2;
          var formatter = (_a = args.params.format) !== null && _a !== void 0 ? _a : createNumberFormatter(getSuitableDecimalDigits(c.edge, midValue));
          var rc = c.edge && findConstraint(c.edge, RangeConstraint);

          if ((rc === null || rc === void 0 ? void 0 : rc.minValue) !== undefined && (rc === null || rc === void 0 ? void 0 : rc.maxValue) !== undefined) {
            return new RangeSliderTextController(args.document, {
              baseStep: getBaseStep(c.edge),
              constraint: c.edge,
              draggingScale: getSuitableDraggingScale(rc, midValue),
              formatter: formatter,
              maxValue: rc.maxValue,
              minValue: rc.minValue,
              parser: parseNumber,
              value: v,
              viewProps: args.viewProps
            });
          }

          var axis = {
            baseStep: getBaseStep(c.edge),
            constraint: c.edge,
            textProps: ValueMap.fromObject({
              draggingScale: midValue,
              formatter: formatter
            })
          };
          return new PointNdTextController(args.document, {
            assembly: IntervalAssembly,
            axes: [axis, axis],
            parser: parseNumber,
            value: v,
            viewProps: args.viewProps
          });
        }
      };

      var RadioCellApi = /*#__PURE__*/function () {
        function RadioCellApi(controller) {
          _classCallCheck(this, RadioCellApi);

          this.controller_ = controller;
        }

        _createClass(RadioCellApi, [{
          key: "disabled",
          get: function get() {
            return this.controller_.viewProps.get('disabled');
          },
          set: function set(disabled) {
            this.controller_.viewProps.set('disabled', disabled);
          }
        }, {
          key: "title",
          get: function get() {
            var _a;

            return (_a = this.controller_.props.get('title')) !== null && _a !== void 0 ? _a : '';
          },
          set: function set(title) {
            this.controller_.props.set('title', title);
          }
        }]);

        return RadioCellApi;
      }();

      var TpRadioGridChangeEvent = /*#__PURE__*/function (_TpChangeEvent) {
        _inherits(TpRadioGridChangeEvent, _TpChangeEvent);

        var _super11 = _createSuper(TpRadioGridChangeEvent);

        function TpRadioGridChangeEvent(target, cell, index, value, presetKey) {
          var _this23;

          _classCallCheck(this, TpRadioGridChangeEvent);

          _this23 = _super11.call(this, target, value, presetKey);
          _this23.cell = cell;
          _this23.index = index;
          return _this23;
        }

        return _createClass(TpRadioGridChangeEvent);
      }(TpChangeEvent);

      var RadioGridApi = /*#__PURE__*/function (_BladeApi4) {
        _inherits(RadioGridApi, _BladeApi4);

        var _super12 = _createSuper(RadioGridApi);

        function RadioGridApi(controller) {
          var _this24;

          _classCallCheck(this, RadioGridApi);

          _this24 = _super12.call(this, controller);
          _this24.cellToApiMap_ = new Map();
          var gc = _this24.controller_.valueController;
          gc.cellControllers.forEach(function (cc) {
            var api = new RadioCellApi(cc);

            _this24.cellToApiMap_.set(cc, api);
          });
          return _this24;
        }

        _createClass(RadioGridApi, [{
          key: "value",
          get: function get() {
            return this.controller_.value;
          }
        }, {
          key: "cell",
          value: function cell(x, y) {
            var gc = this.controller_.valueController;
            var cc = gc.cellControllers[y * gc.size[0] + x];
            return this.cellToApiMap_.get(cc);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            var _this25 = this;

            var bh = handler.bind(this);
            this.controller_.value.emitter.on(eventName, function (ev) {
              var gc = _this25.controller_.valueController;
              var cc = gc.findCellByValue(ev.rawValue);

              if (!cc) {
                return;
              }

              var capi = _this25.cellToApiMap_.get(cc);

              if (!capi) {
                return;
              }

              var i = gc.cellControllers.indexOf(cc);
              bh(new TpRadioGridChangeEvent(_this25, capi, [i % gc.size[0], Math.floor(i / gc.size[0])], ev.rawValue, undefined));
            });
          }
        }]);

        return RadioGridApi;
      }(BladeApi);

      var className = ClassName('rad');

      var RadioView = /*#__PURE__*/_createClass(function RadioView(doc, config) {
        _classCallCheck(this, RadioView);

        this.element = doc.createElement('div');
        this.element.classList.add(className());
        config.viewProps.bindClassModifiers(this.element);
        var labelElem = doc.createElement('label');
        labelElem.classList.add(className('l'));
        this.element.appendChild(labelElem);
        var inputElem = doc.createElement('input');
        inputElem.classList.add(className('i'));
        inputElem.name = config.name;
        inputElem.type = 'radio';
        config.viewProps.bindDisabled(inputElem);
        labelElem.appendChild(inputElem);
        this.inputElement = inputElem;
        var bodyElem = doc.createElement('div');
        bodyElem.classList.add(className('b'));
        labelElem.appendChild(bodyElem);
        var titleElem = doc.createElement('div');
        titleElem.classList.add(className('t'));
        bodyElem.appendChild(titleElem);
        bindValueMap(config.props, 'title', function (title) {
          titleElem.textContent = title;
        });
      });

      var RadioController = /*#__PURE__*/_createClass(function RadioController(doc, config) {
        _classCallCheck(this, RadioController);

        this.props = config.props;
        this.viewProps = config.viewProps;
        this.view = new RadioView(doc, {
          name: config.name,
          props: this.props,
          viewProps: this.viewProps
        });
      });

      var RadioGridController = /*#__PURE__*/function () {
        function RadioGridController(doc, config) {
          var _this26 = this;

          _classCallCheck(this, RadioGridController);

          this.cellCs_ = [];
          this.cellValues_ = [];
          this.onCellInputChange_ = this.onCellInputChange_.bind(this);
          this.size = config.size;

          var _this$size2 = _slicedToArray(this.size, 2),
              w = _this$size2[0],
              h = _this$size2[1];

          for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
              var bc = new RadioController(doc, {
                name: config.groupName,
                props: ValueMap.fromObject(Object.assign({}, config.cellConfig(x, y))),
                viewProps: ViewProps.create()
              });
              this.cellCs_.push(bc);
              this.cellValues_.push(config.cellConfig(x, y).value);
            }
          }

          this.value = config.value;
          bindValue(this.value, function (value) {
            var cc = _this26.findCellByValue(value);

            if (!cc) {
              return;
            }

            cc.view.inputElement.checked = true;
          });
          this.viewProps = ViewProps.create();
          this.view = new PlainView(doc, {
            viewProps: this.viewProps,
            viewName: 'radgrid'
          });
          this.view.element.style.gridTemplateColumns = "repeat(".concat(w, ", 1fr)");
          this.cellCs_.forEach(function (bc) {
            bc.view.inputElement.addEventListener('change', _this26.onCellInputChange_);

            _this26.view.element.appendChild(bc.view.element);
          });
        }

        _createClass(RadioGridController, [{
          key: "cellControllers",
          get: function get() {
            return this.cellCs_;
          }
        }, {
          key: "findCellByValue",
          value: function findCellByValue(value) {
            var index = this.cellValues_.findIndex(function (v) {
              return v === value;
            });

            if (index < 0) {
              return null;
            }

            return this.cellCs_[index];
          }
        }, {
          key: "onCellInputChange_",
          value: function onCellInputChange_(ev) {
            var inputElem = ev.currentTarget;
            var index = this.cellCs_.findIndex(function (c) {
              return c.view.inputElement === inputElem;
            });

            if (index < 0) {
              return;
            }

            this.value.rawValue = this.cellValues_[index];
          }
        }]);

        return RadioGridController;
      }();

      var RadioGridBladePlugin = function () {
        return {
          id: 'radiogrid',
          type: 'blade',
          accept: function accept(params) {
            var p = ParamsParsers;
            var result = parseParams(params, {
              cells: p.required["function"],
              groupName: p.required.string,
              size: p.required.array(p.required.number),
              value: p.required.raw,
              view: p.required.constant('radiogrid'),
              label: p.optional.string
            });
            return result ? {
              params: result
            } : null;
          },
          controller: function controller(args) {
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: new RadioGridController(args.document, {
                groupName: args.params.groupName,
                cellConfig: args.params.cells,
                size: args.params.size,
                value: createValue(args.params.value)
              })
            });
          },
          api: function api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }

            if (!(args.controller.valueController instanceof RadioGridController)) {
              return null;
            }

            return new RadioGridApi(args.controller);
          }
        };
      }();

      function createRadioGridInputPlugin(config) {
        return {
          id: 'input-radiogrid',
          type: 'input',
          accept: function accept(value, params) {
            if (!config.isType(value)) {
              return null;
            }

            var p = ParamsParsers;
            var result = parseParams(params, {
              cells: p.required["function"],
              groupName: p.required.string,
              size: p.required.array(p.required.number),
              view: p.required.constant('radiogrid')
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: config.binding,
          controller: function controller(args) {
            return new RadioGridController(args.document, {
              cellConfig: args.params.cells,
              groupName: args.params.groupName,
              size: args.params.size,
              value: args.value
            });
          }
        };
      }

      var RadioGruidNumberInputPlugin = createRadioGridInputPlugin({
        isType: function isType(value) {
          return typeof value === 'number';
        },
        binding: {
          reader: function reader(_args) {
            return numberFromUnknown;
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        }
      });
      var RadioGruidStringInputPlugin = createRadioGridInputPlugin({
        isType: function isType(value) {
          return typeof value === 'string';
        },
        binding: {
          reader: function reader(_args) {
            return stringFromUnknown;
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        }
      });
      var RadioGruidBooleanInputPlugin = createRadioGridInputPlugin({
        isType: function isType(value) {
          return typeof value === 'boolean';
        },
        binding: {
          reader: function reader(_args) {
            return boolFromUnknown;
          },
          writer: function writer(_args) {
            return writePrimitive;
          }
        }
      });
      var plugins = [ButtonGridBladePlugin, CubicBezierBladePlugin, FpsGraphBladePlugin, IntervalInputPlugin, RadioGridBladePlugin, RadioGruidBooleanInputPlugin, RadioGruidNumberInputPlugin, RadioGruidStringInputPlugin];
      exports.CubicBezier = CubicBezier;
      exports.plugins = plugins;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(tweakpanePluginEssentials$1, tweakpanePluginEssentials$1.exports);

  var tweakpanePluginEssentials = /*@__PURE__*/getDefaultExportFromCjs(tweakpanePluginEssentials$1.exports);

  var EssentialsPlugin = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    'default': tweakpanePluginEssentials
  }, [tweakpanePluginEssentials$1.exports]);

  var eventemitter3 = {exports: {}};

  (function (module) {

    var has = Object.prototype.hasOwnProperty,
        prefix = '~';
    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */

    function Events() {} //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //


    if (Object.create) {
      Events.prototype = Object.create(null); //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //

      if (!new Events().__proto__) prefix = false;
    }
    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */


    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */


    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }

      var listener = new EE(fn, context || emitter, once),
          evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */


    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
    }
    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */


    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */


    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
          events,
          name;
      if (this._eventsCount === 0) return names;

      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }

      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }

      return names;
    };
    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */


    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
          handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];

      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }

      return ee;
    };
    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */


    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
          listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */


    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
          len = arguments.length,
          args,
          i;

      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;

          case 2:
            return listeners.fn.call(listeners.context, a1), true;

          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;

          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;

          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }

        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
            j;

        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;

            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;

            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;

            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;

            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }

      return true;
    };
    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */


    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */


    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */


    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;

      if (!fn) {
        clearEvent(this, evt);
        return this;
      }

      var listeners = this._events[evt];

      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        } //
        // Reset the array, or remove it completely if we have no more listeners.
        //


        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
      }

      return this;
    };
    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */


    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;

      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }

      return this;
    }; //
    // Alias methods names because people roll like that.
    //


    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
    // Expose the prefix.
    //

    EventEmitter.prefixed = prefix; //
    // Allow `EventEmitter` to be imported as module namespace.
    //

    EventEmitter.EventEmitter = EventEmitter; //
    // Expose the module.
    //

    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);

  var draggable_min = {exports: {}};

  (function (module, exports) {
    !function (t, e) {
      module.exports = e() ;
    }(commonjsGlobal, function () {

      var t = {
        grid: 0,
        filterTarget: null,
        limit: {
          x: null,
          y: null
        },
        threshold: 0,
        setCursor: !1,
        setPosition: !0,
        smoothDrag: !0,
        useGPU: !0,
        onDrag: u,
        onDragStart: u,
        onDragEnd: u
      },
          e = {
        transform: function () {
          for (var t = " -o- -ms- -moz- -webkit-".split(" "), e = document.body.style, n = t.length; n--;) {
            var o = t[n] + "transform";
            if (o in e) return o;
          }
        }()
      },
          n = {
        assign: function assign() {
          for (var t = arguments[0], e = arguments.length, n = 1; n < e; n++) {
            var o = arguments[n];

            for (var i in o) {
              t[i] = o[i];
            }
          }

          return t;
        },
        bind: function bind(t, e) {
          return function () {
            t.apply(e, arguments);
          };
        },
        on: function on(t, e, o) {
          if (e && o) n.addEvent(t, e, o);else if (e) for (var i in e) {
            n.addEvent(t, i, e[i]);
          }
        },
        off: function off(t, e, o) {
          if (e && o) n.removeEvent(t, e, o);else if (e) for (var i in e) {
            n.removeEvent(t, i, e[i]);
          }
        },
        limit: function limit(t, e) {
          return e instanceof Array ? t < (e = [+e[0], +e[1]])[0] ? t = e[0] : t > e[1] && (t = e[1]) : t = +e, t;
        },
        addEvent: "attachEvent" in Element.prototype ? function (t, e, n) {
          t.attachEvent("on" + e, n);
        } : function (t, e, n) {
          t.addEventListener(e, n, !1);
        },
        removeEvent: "attachEvent" in Element.prototype ? function (t, e, n) {
          t.detachEvent("on" + e, n);
        } : function (t, e, n) {
          t.removeEventListener(e, n);
        }
      };

      function o(e, o) {
        var i = this,
            r = n.bind(i.start, i),
            s = n.bind(i.drag, i),
            u = n.bind(i.stop, i);
        if (!a(e)) throw new TypeError("Draggable expects argument 0 to be an Element");
        o = n.assign({}, t, o), n.assign(i, {
          element: e,
          handle: o.handle && a(o.handle) ? o.handle : e,
          handlers: {
            start: {
              mousedown: r,
              touchstart: r
            },
            move: {
              mousemove: s,
              mouseup: u,
              touchmove: s,
              touchend: u
            }
          },
          options: o
        }), i.initialize();
      }

      function i(t) {
        return parseInt(t, 10);
      }

      function r(t) {
        return "currentStyle" in t ? t.currentStyle : getComputedStyle(t);
      }

      function s(t) {
        return null != t;
      }

      function a(t) {
        return t instanceof Element || "undefined" != typeof HTMLDocument && t instanceof HTMLDocument;
      }

      function u() {}

      return n.assign(o.prototype, {
        setOption: function setOption(t, e) {
          var n = this;
          return n.options[t] = e, n.initialize(), n;
        },
        get: function get() {
          var t = this.dragEvent;
          return {
            x: t.x,
            y: t.y
          };
        },
        set: function set(t, e) {
          var n = this.dragEvent;
          return n.original = {
            x: n.x,
            y: n.y
          }, this.move(t, e), this;
        },
        dragEvent: {
          started: !1,
          x: 0,
          y: 0
        },
        initialize: function initialize() {
          var t,
              o = this,
              i = o.element,
              s = (o.handle, i.style),
              a = r(i),
              u = o.options,
              f = e.transform,
              l = o._dimensions = {
            height: i.offsetHeight,
            left: i.offsetLeft,
            top: i.offsetTop,
            width: i.offsetWidth
          };
          u.useGPU && f && ("none" === (t = a[f]) && (t = ""), s[f] = t + " translate3d(0,0,0)"), u.setPosition && (s.display = "block", s.left = l.left + "px", s.top = l.top + "px", s.width = l.width + "px", s.height = l.height + "px", s.bottom = s.right = "auto", s.margin = 0, s.position = "absolute"), u.setCursor && (s.cursor = "move"), o.setLimit(u.limit), n.assign(o.dragEvent, {
            x: l.left,
            y: l.top
          }), n.on(o.handle, o.handlers.start);
        },
        start: function start(t) {
          var e = this,
              o = e.getCursor(t),
              i = e.element;
          e.useTarget(t.target || t.srcElement) && (t.preventDefault && !t.target.getAttribute("contenteditable") ? t.preventDefault() : t.target.getAttribute("contenteditable") || (t.returnValue = !1), e.dragEvent.oldZindex = i.style.zIndex, i.style.zIndex = 1e4, e.setCursor(o), e.setPosition(), e.setZoom(), n.on(document, e.handlers.move));
        },
        drag: function drag(t) {
          var e = this,
              n = e.dragEvent,
              o = e.element,
              i = e._cursor,
              r = e._dimensions,
              s = e.options,
              a = r.zoom,
              u = e.getCursor(t),
              f = s.threshold,
              l = (u.x - i.x) / a + r.left,
              d = (u.y - i.y) / a + r.top;
          !n.started && f && Math.abs(i.x - u.x) < f && Math.abs(i.y - u.y) < f || (n.original || (n.original = {
            x: l,
            y: d
          }), n.started || (s.onDragStart(o, l, d, t), n.started = !0), e.move(l, d) && s.onDrag(o, n.x, n.y, t));
        },
        move: function move(t, e) {
          var n = this,
              o = n.dragEvent,
              i = n.options,
              r = i.grid,
              s = n.element.style,
              a = n.limit(t, e, o.original.x, o.original.y);
          return !i.smoothDrag && r && (a = n.round(a, r)), (a.x !== o.x || a.y !== o.y) && (o.x = a.x, o.y = a.y, s.left = a.x + "px", s.top = a.y + "px", !0);
        },
        stop: function stop(t) {
          var e,
              o = this,
              i = o.dragEvent,
              r = o.element,
              s = o.options,
              a = s.grid;
          n.off(document, o.handlers.move), r.style.zIndex = i.oldZindex, s.smoothDrag && a && (e = o.round({
            x: i.x,
            y: i.y
          }, a), o.move(e.x, e.y), n.assign(o.dragEvent, e)), o.dragEvent.started && s.onDragEnd(r, i.x, i.y, t), o.reset();
        },
        reset: function reset() {
          this.dragEvent.started = !1;
        },
        round: function round(t) {
          var e = this.options.grid;
          return {
            x: e * Math.round(t.x / e),
            y: e * Math.round(t.y / e)
          };
        },
        getCursor: function getCursor(t) {
          return {
            x: (t.targetTouches ? t.targetTouches[0] : t).clientX,
            y: (t.targetTouches ? t.targetTouches[0] : t).clientY
          };
        },
        setCursor: function setCursor(t) {
          this._cursor = t;
        },
        setLimit: function setLimit(t) {
          var e = this,
              o = function o(t, e) {
            return {
              x: t,
              y: e
            };
          };

          if (t instanceof Function) e.limit = t;else if (a(t)) {
            var i = e._dimensions,
                r = t.scrollHeight - i.height,
                u = t.scrollWidth - i.width;

            e.limit = function (t, e) {
              return {
                x: n.limit(t, [0, u]),
                y: n.limit(e, [0, r])
              };
            };
          } else if (t) {
            var f = s(t.x),
                l = s(t.y);
            e.limit = f || l ? function (e, o) {
              return {
                x: f ? n.limit(e, t.x) : e,
                y: l ? n.limit(o, t.y) : o
              };
            } : o;
          } else e.limit = o;
        },
        setPosition: function setPosition() {
          var t = this.element,
              e = t.style;
          n.assign(this._dimensions, {
            left: i(e.left) || t.offsetLeft,
            top: i(e.top) || t.offsetTop
          });
        },
        setZoom: function setZoom() {
          for (var t = this.element, e = 1; t = t.offsetParent;) {
            var n = r(t).zoom;

            if (n && "normal" !== n) {
              e = n;
              break;
            }
          }

          this._dimensions.zoom = e;
        },
        useTarget: function useTarget(t) {
          var e = this.options.filterTarget;
          return !(e instanceof Function) || e(t);
        },
        destroy: function destroy() {
          n.off(this.handle, this.handlers.start), n.off(document, this.handlers.move);
        }
      }), o;
    });
  })(draggable_min);

  var Draggable = draggable_min.exports;

  const CONFIG$1 = {
    settings: {
      // init prompts
      promptKeyword: null,
      randomizePrompts: true,

      // default parameters values
      options: {
        seed: {
          value: -1,
          min: -1,
          max: 10000,
          step: 1,
        },
        steps: {
          value: 40,
          min: 10,
          max: 100,
          step: 1,
        },
        strength: {
          value: 0.65,
          min: 0,
          max: 1,
          step: 0.01,
        },
        guidance: {
          value: 7,
          min: 0,
          max: 25,
          step: 0.01,
        },
        brush_size: {
          value: 96,
          min: 1,
          max: 256,
          step: 1,
        },
        zone_size: {
          value: 512,
          min: 64,
          max: 512,
          step: 64,
        },
        canvas_size: {
          value: 1024,
          min: 64,
          max: 4096,
          step: 1,
        },
        unit: {
          value: 1,
          min: 0,
          max: 1,
          step: 0.01,
        },
      },

      keymap: {
        inference: {
          compute: "c",
          randomize: "r",
        },

        img2img: {
          compute: "v",
          randomize: "t",
        },

        inpainting: {
          compute: "b",
          randomize: "y",
        },
      },
    },
  };

  let pane;
  class UI extends eventemitter3.exports.EventEmitter {
    constructor(panelId = "#SDExplorer") {
      super();

      const panel = document.querySelector(panelId);

      new Draggable(panel, {
        filterTarget: (e) => {
          return e == panel;
        },
      });

      const container = panel.querySelector(".settings-contents");
      pane = new tweakpane.exports.Pane({ container });
      pane.registerPlugin(TextareaPlugin);
      pane.registerPlugin(EssentialsPlugin);

      // tabs default options

      const seed = CONFIG$1.settings.options.seed;
      const steps = CONFIG$1.settings.options.steps;
      const strength = CONFIG$1.settings.options.strength;
      const guidance = CONFIG$1.settings.options.guidance;
      const brush_size = CONFIG$1.settings.options.brush_size;
      const zone_size = CONFIG$1.settings.options.zone_size;
      const canvas_size = CONFIG$1.settings.options.canvas_size;
      const unit = CONFIG$1.settings.options.unit;

      // tabs
      this.tabIndex = 0;
      const tab = pane
        .addTab({
          pages: [
            { title: "inference" },
            { title: "img2img" },
            { title: "inpainting" },
          ],
        })
        .on("select", (e) => {
          this.tabIndex = e.index;
          this.emit("tab_change", e.index);
        });

      // params
      this.clipboard = "";
      this.inference = {
        prompt: "",
        prompt_actions: {
          type: "grid",
          randomize: () => {
            this.emit("randomize", this.inference);
          },
          copy: () => {
            this.clipboard = this.inference.field.value;
          },
          paste: () => {
            this.inference.field.value = this.clipboard;
          },
        },
        seed,
        steps,
        guidance,
        actions: {
          type: "grid",
          compute: () => {
            this.emit("inference", this.inference);
          },
          undo: () => {
            this.emit("undo");
          },
        },
      };

      this.img2img = {
        prompt: "",
        prompt_actions: {
          type: "grid",
          randomize: () => {
            this.emit("randomize", this.img2img);
          },
          copy: () => {
            this.clipboard = this.img2img.field.value;
          },
          paste: () => {
            this.img2img.field.value = this.clipboard;
          },
        },
        seed,
        strength,
        guidance,
        // brush_size,
        // color: "#ff0055ff",
        actions: {
          type: "grid",
          compute: () => {
            this.emit("img2img", this.img2img);
          },
          undo: () => {
            this.emit("undo");
          },
        },
      };

      this.inpainting = {
        prompt: "",
        prompt_actions: {
          type: "grid",
          randomize: () => {
            this.emit("randomize", this.inpainting);
          },
          copy: () => {
            this.clipboard = this.inpainting.field.value;
          },
          paste: () => {
            this.inpainting.field.value = this.clipboard;
          },
        },
        seed,
        strength,
        guidance,
        actions: {
          type: "grid",
          compute: () => {
            this.emit("inpainting", this.inpainting);
          },
          undo: () => {
            this.emit("undo");
          },
        },
        brush_size,
        softness: unit,
        alpha: unit,
        clear: () => {
          this.emit("clear_drawpad");
        },
        mode: {
          type: "radio",
          draw: () => {
            this.emit("draw_mode", "draw");
          },
          erase: () => {
            this.emit("draw_mode", "erase");
          },
        },
      };

      //   populate panel
      this.addMenu(this.inference, tab.pages[0]);
      this.addMenu(this.img2img, tab.pages[1]);
      this.addMenu(this.inpainting, tab.pages[2]);

      //zone settings
      this.zone = {
        width: zone_size,
        height: zone_size,
      };
      pane.addSeparator();
      const zone = pane.addFolder({ title: "zone", expanded: true });
      this.addMenu(this.zone, zone);

      //canvas settings
      this.canvas = {
        width: canvas_size,
        height: canvas_size,
        color: "rgba(214,214,214,1)",
        grain: unit,
        actions: {
          type: "grid",
          clear: () => {
            this.emit("clear");
          },
          save: () => {
            this.emit("save");
          },
        },
      };
      this.canvas.grain.value = 0.0;
      pane.addSeparator();
      const canvas = pane.addFolder({ title: "canvas" });
      this.addMenu(this.canvas, canvas);
      this.inference.field.value = Prompter.next();
      this.img2img.field.value = Prompter.next();
      this.inpainting.field.value = Prompter.next();
      {
        Prompter.randomize();
        this.inference.field.value = Prompter.random();
        this.img2img.field.value = Prompter.random();
        this.inpainting.field.value = Prompter.random();
      }

      // maximize all controls width ( hacky hacky...)
      const els = document.querySelectorAll(".tp-lblv_v");
      for (let i = 0; i < els.length; i++) {
        els[i].style.flexGrow = 2;
      }

      pane.refresh();
      this.addKeyboardShortcuts();
    }

    getConfig(object) {
      let cfg = Object.assign({}, object);
      cfg = Object.assign(cfg, this.zone);
      cfg.prompt = object.field.value.trim();
      //clean up
      for (let key in cfg) {
        if (typeof cfg[key] === "function" || typeof cfg[key] === "object") {
          delete cfg[key];
        }
      }
      return cfg;
    }

    getShortcut(folder, key) {
      let shortcut = "";
      if (
        CONFIG$1.settings.keymap[folder.title] != undefined &&
        CONFIG$1.settings.keymap[folder.title][key] != undefined
      ) {
        shortcut = " (" + CONFIG$1.settings.keymap[folder.title][key] + ")";
      }
      return shortcut;
    }

    addMenu(object, folder) {
      // console.log("create menu for ", folder);

      // expose the sliders (to the drawingPad for instance)
      const bindings = {};
      for (let key in object) {
        if (object[key] == "") {
          const cfg = {
            view: "textarea",
            lineCount: 6,
            placeholder: "hic sunt dracones...",
          };
          let field = folder.addInput(object, key, cfg);

          //
          // store a path to the input textarea !!! ( holy shit )
          object.field = field.controller_.valueController.view.inputElement;
          //
          //
        } else if (typeof object[key] === "function") {
          const btn = folder.addButton({
            title: key + this.getShortcut(folder, key),
            label: "",
          });
          btn.on("click", () => {
            object[key]();
          });
        } else if (key === "color") {
          const color = folder.addInput(object, "color", {
            // picker: "inline",
            // expanded: true,
          });
          bindings[key] = color;
        } else {
          switch (object[key].type) {
            case "grid":
              //buttons list
              delete object[key].type;
              this.buttonGrid(folder, object[key]);
              break;
            case "radio":
              //radio nbuttons
              delete object[key].type;
              this.buttonGrid(folder, object[key]);
              // this.radioButtons(object, key, folder, object[key]);
              break;
            default:
              let props = object[key];
              object[key] = object[key].value;
              const field = folder.addInput(object, key, props);
              bindings[key] = field;
              break;
          }
        }
      }
      object.bindings = bindings;
      return folder;
    }

    buttonGrid(folder, params) {
      const names = [];
      const methods = [];
      for (let key in params) {
        let shortcut = this.getShortcut(folder, key);
        names.push(key + shortcut);
        methods.push(params[key]);
      }
      folder
        .addBlade({
          view: "buttongrid",
          size: [names.length, 1],
          cells: (i, j) => ({
            title: names[i],
          }),
          label: "",
        })
        .on("click", (ev) => {
          methods[ev.index[0]]();
        });
    }

    radioButtons(object, key, parent, params) {
      const names = [];
      const values = [];
      let i = 0;
      const methods = [];
      for (let key in params) {
        names.push(key);
        methods.push(params[key]);
        values.push(i++);
      }
      object[key] = 1;
      const group = parent
        .addInput(object, key, {
          view: "radiogrid",
          groupName: key,
          size: [names.length, 1],
          cells: (i, j) => ({
            title: names[i],
            value: values[i],
          }),
          label: key,
        })
        .on("change", (ev) => {
          console.log("click", ev.value);
          methods[ev.value]();
        });
      group.value = 0;
      return group;
    }

    //keyboard
    addKeyboardShortcuts() {
      window.addEventListener("keydown", (e) => {
        //prevents shortcuts when editing text
        const f0 = this.inference.field === document.activeElement;
        const f1 = this.img2img.field === document.activeElement;
        const f2 = this.inpainting.field === document.activeElement;
        const focus = f0 || f1 || f2;

        if (focus) return;
        switch (e.key) {
          case "z":
            if (e.ctrlKey) this.emit("undo");
            break;

          case CONFIG$1.settings.keymap.inference.compute:
            this.emit("inference", this.inference);
            break;
          case CONFIG$1.settings.keymap.inference.randomize:
            this.emit("randomize", this.inference);
            break;

          case CONFIG$1.settings.keymap.img2img.compute:
            this.emit("img2img", this.img2img);
            break;
          case CONFIG$1.settings.keymap.img2img.randomize:
            this.emit("randomize", this.img2img);
            break;

          case CONFIG$1.settings.keymap.inpainting.compute:
            this.emit("inpainting", this.inpainting);
            break;
          case CONFIG$1.settings.keymap.inpainting.randomize:
            this.emit("randomize", this.inpainting);
            break;
        }
      });
    }
  }

  let throbber, drag, zone$1;
  class Zone {
    constructor(ui) {
      throbber = document.getElementById("throbber");
      drag = document.getElementById("drag");
      this.draggable = new Draggable(drag, {
        // TODO update limits on resize
        limit: {
          x: [256, 4096],
          y: [256 + 12, 4096],
        },
        filterTarget: (e) => {
          return e == drag || ui.tabIndex != 2;
        },
      });
      zone$1 = document.getElementById("zone");
      this.element = zone$1;
    }

    get rect() {
      const r = zone$1.getBoundingClientRect();
      r.x += window.scrollX;
      r.y += window.scrollY;
      return r;
    }

    showThrobber() {
      throbber.classList.remove("hidden");
    }

    hideThrobber() {
      throbber.classList.add("hidden");
    }
    set width(v) {
      drag.style.width = v + "px";
      zone$1.style.width = v + "px";
    }
    set height(v) {
      drag.style.height = v + "px";
      zone$1.style.height = v + "px";
    }
    resize(w, h) {
      this.width = w;
      this.height = h;
      // this.draggable.limit = {
      //   x: [0, w - 24],
      //   y: [12, h - 24],
      // };
    }
  }

  var FileSaver_min = {exports: {}};

  (function (module, exports) {
    (function (a, b) {
      b();
    })(commonjsGlobal, function () {

      function b(a, b) {
        return "undefined" == typeof b ? b = {
          autoBom: !1
        } : "object" != _typeof$1(b) && (console.warn("Deprecated: Expected third argument to be a object"), b = {
          autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], {
          type: a.type
        }) : a;
      }

      function c(a, b, c) {
        var d = new XMLHttpRequest();
        d.open("GET", a), d.responseType = "blob", d.onload = function () {
          g(d.response, b, c);
        }, d.onerror = function () {
          console.error("could not download file");
        }, d.send();
      }

      function d(a) {
        var b = new XMLHttpRequest();
        b.open("HEAD", a, !1);

        try {
          b.send();
        } catch (a) {}

        return 200 <= b.status && 299 >= b.status;
      }

      function e(a) {
        try {
          a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
          var b = document.createEvent("MouseEvents");
          b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
      }

      var f = "object" == (typeof window === "undefined" ? "undefined" : _typeof$1(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof$1(self)) && self.self === self ? self : "object" == _typeof$1(commonjsGlobal) && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0,
          a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
          g = f.saveAs || ("object" != (typeof window === "undefined" ? "undefined" : _typeof$1(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype && !a ? function (b, g, h) {
        var i = f.URL || f.webkitURL,
            j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
          i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function () {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
          var i = document.createElement("a");
          i.href = f, i.target = "_blank", setTimeout(function () {
            e(i);
          });
        }
      } : function (b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type,
            i = /constructor/i.test(f.HTMLElement) || f.safari,
            j = /CriOS\/[\d]+/.test(navigator.userAgent);

        if ((j || h && i || a) && "undefined" != typeof FileReader) {
          var k = new FileReader();
          k.onloadend = function () {
            var a = k.result;
            a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
          }, k.readAsDataURL(b);
        } else {
          var l = f.URL || f.webkitURL,
              m = l.createObjectURL(b);
          g ? g.location = m : location.href = m, g = null, setTimeout(function () {
            l.revokeObjectURL(m);
          }, 4E4);
        }
      });
      f.saveAs = g.saveAs = g, (module.exports = g);
    });
  })(FileSaver_min);

  var saveAs = FileSaver_min.exports;

  let canvas, socket, zone, ui, history, drawPad;

  let locked = false;
  const JPG_QUALITY = 0.9;

  class SDExplorer {
    constructor(width, height) {
      // socket
      socket = lookup();

      // control panel
      ui = new UI();

      //background canvas
      canvas = new Canvas(width, height);

      //default source is the working canvas
      this.source = canvas.element;

      //draggable area
      zone = new Zone(ui);

      // draw area for inpainting
      drawPad = new DrawingPad(ui.inpainting);
      zone.element.appendChild(drawPad.canvas);

      // undo (/redo?)
      history = new History(canvas, ui);

      // logic

      // init socket
      socket.connect("http://localhost:8080");
      socket.on("init", function (data) {
        console.log(
          "%c" + data.message,
          "color:pink; font-size:24px; font-family:Comic-Sans;"
        );
      });

      // draws the image to canvas whenever a function is finished
      socket.on("image_ready", (data) => {
        const image = new Image();
        image.onload = () => {
          let rect = zone.rect;
          //draw to canvas
          canvas.drawImageAt(image, rect.x, rect.y);
          //push to history
          history.pushState(image, rect);
        };
        image.setAttribute("src", data.value);
        zone.hideThrobber();
        locked = false;
      });

      // manage tab change
      ui.on("tab_change", (index) => {
        switch (index) {
          case 0:
          case 1:
            drawPad.hide();
            break;
          case 2:
            drawPad.show();
            break;
          default:
            return;
        }
      });

      // randomizze a prompt
      ui.on("randomize", (object) => {
        const field = object.field;
        field.value = Prompter.next();
      });

      // check if we can proceed
      const isReady = (object) => {
        const config = ui.getConfig(object);
        if (config.prompt.trim() === "") return false;
        if (locked) return false;
        locked = true;
        return true;
      };

      // call an inference
      ui.on("inference", (object) => {
        if (!isReady(object)) return;
        socket.emit("inference", ui.getConfig(object));
        zone.showThrobber();
      });

      // call an image 2 image
      ui.on("img2img", (object) => {
        if (!isReady(object)) return;

        //save the cropped image and call the img2img function:
        // crop and convert to Blob
        const crop = canvas.crop(this.source, zone.rect);
        crop.toBlob(
          (blob) => {
            // tell node to save to disk
            socket.emit("save_image", "img2img/i2i-tmp.jpg", blob);
            //once it's saved, call the img2img
            socket.once("on_image_saved", () => {
              socket.emit("image_image", ui.getConfig(object));
              zone.showThrobber();
            });
          },
          "image/jpeg",
          JPG_QUALITY
        );
      });

      // call an inpainting
      ui.on("inpainting", (object) => {
        if (!isReady(object)) return;

        //save the cropped image and call the img2img function:
        // crop and convert to Blob
        const crop = canvas.crop(this.source, zone.rect);
        crop.toBlob(
          (blob) => {
            // tell node to save to disk
            socket.emit("save_image", "inpainting/inp-tmp.jpg", blob);
            // when the source is saved,
            socket.once("on_image_saved", () => {
              //  save the mask
              drawPad.canvas.toBlob(
                (blob) => {
                  // tell node to save to disk
                  socket.emit("save_image", "inpainting/inp-msk.jpg", blob);
                  //
                  //once the mask is saved, call the inpainting
                  socket.once("on_image_saved", () => {
                    // call inpainting
                    socket.emit("inpainting", ui.getConfig(object));
                    zone.showThrobber();
                    //clear the mask
                    drawPad.clear();
                  });
                },
                "image/jpeg",
                JPG_QUALITY
              );
            });
          },
          "image/jpeg",
          JPG_QUALITY
        );
      });

      //zone settings

      //resize
      const resize_zone = () => {
        const w = ui.zone.width;
        const h = ui.zone.height;
        zone.resize(w, h);
        drawPad.resize(w, h);
      };
      ui.zone.bindings.width.on("change", resize_zone);
      ui.zone.bindings.height.on("change", resize_zone);
      // clear
      ui.on("clear_drawpad", drawPad.clear.bind(drawPad));

      // canvas settings

      //resize
      ui.canvas.width = canvas.width;
      ui.canvas.height = canvas.height;
      ui.canvas.bindings.width.on("change", (e) => {
        if (e.last) {
          canvas.setSize(e.value, canvas.height);
        }
      });
      ui.canvas.bindings.height.on("change", (e) => {
        if (e.last) {
          canvas.setSize(canvas.width, e.value);
        }
      });
      ui.canvas.bindings.color.on("change", (e) => {
        canvas.setClearColor(e.value);
      });
      canvas.setClearColor(ui.canvas.color);
      ui.canvas.bindings.grain.on("change", (e) => {
        if (e.last) canvas.grain = e.value;
      });
      canvas.grain = ui.canvas.grain;

      //clear canvas
      ui.on("clear", () => {
        canvas.clear();
      });

      // save canvas
      ui.on("save", () => {
        canvas.element.toBlob(function (blob) {
          saveAs(blob, "composition-" + Date.now() + ".png");
        });
      });
    }

    //accessors
    //source canvas to process img2img & inpainting
    get source() {
      return this._source;
    }
    set source(v) {
      this._source = v;
    }
    get canvas() {
      return canvas.element;
    }
    get context() {
      return canvas.context;
    }
    get history() {
      return history;
    }
    get ui() {
      return ui;
    }
  }

  const CONFIG = {
    sphereDetail: 2,
    radius: 15,
    turns: 1,
    count: 100,
    speed: 0,
    axialSpeed: -0.5,
    section: { width: 4, height: 4, countPerSide: 6 },
    size: { default: 1, min: 1, max: 1 },
    hollow: false,

    color: true,
    //row = le numro de la 'section'
    //uid = l'identifiant unique d'une bille
    //retourne: array.push( R, G, B);
    colorRule: (row, uid, array) => {
      let grey = 0.75;
      if (uid % 4 == 0) {
        array.push(0, 0, 0);
      } else {
        //ajoute une bille rouge de temps  autres
        if (Math.random() > 0.99) {
          array.push(1, 0, 0);
        } else {
          array.push(grey, grey, grey);
        }
      }
    },

    //material
    roughness: 0.65,
    metalness: 0.35,
    envMapIntensity: 0.35,
  };

  var _FN;/**
   * @license
   * Copyright 2010-2022 Three.js Authors
   * SPDX-License-Identifier: MIT
   */var REVISION='144';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};var TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var PCFShadowMap=1;var PCFSoftShadowMap=2;var VSMShadowMap=3;var FrontSide=0;var BackSide=1;var DoubleSide=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var CineonToneMapping=3;var ACESFilmicToneMapping=4;var CustomToneMapping=5;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var CubeUVReflectionMapping=306;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipmapNearestFilter=1004;var NearestMipmapLinearFilter=1005;var LinearFilter=1006;var LinearMipmapNearestFilter=1007;var LinearMipmapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;// @deprecated since r137
  var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var DepthFormat=1026;var DepthStencilFormat=1027;var RedFormat=1028;var RedIntegerFormat=1029;var RGFormat=1030;var RGIntegerFormat=1031;var RGBAIntegerFormat=1033;var RGB_S3TC_DXT1_Format=33776;var RGBA_S3TC_DXT1_Format=33777;var RGBA_S3TC_DXT3_Format=33778;var RGBA_S3TC_DXT5_Format=33779;var RGB_PVRTC_4BPPV1_Format=35840;var RGB_PVRTC_2BPPV1_Format=35841;var RGBA_PVRTC_4BPPV1_Format=35842;var RGBA_PVRTC_2BPPV1_Format=35843;var RGB_ETC1_Format=36196;var RGB_ETC2_Format=37492;var RGBA_ETC2_EAC_Format=37496;var RGBA_ASTC_4x4_Format=37808;var RGBA_ASTC_5x4_Format=37809;var RGBA_ASTC_5x5_Format=37810;var RGBA_ASTC_6x5_Format=37811;var RGBA_ASTC_6x6_Format=37812;var RGBA_ASTC_8x5_Format=37813;var RGBA_ASTC_8x6_Format=37814;var RGBA_ASTC_8x8_Format=37815;var RGBA_ASTC_10x5_Format=37816;var RGBA_ASTC_10x6_Format=37817;var RGBA_ASTC_10x8_Format=37818;var RGBA_ASTC_10x10_Format=37819;var RGBA_ASTC_12x10_Format=37820;var RGBA_ASTC_12x12_Format=37821;var RGBA_BPTC_Format=36492;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var LinearEncoding=3000;var sRGBEncoding=3001;var BasicDepthPacking=3200;var RGBADepthPacking=3201;var TangentSpaceNormalMap=0;var ObjectSpaceNormalMap=1;// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
  var SRGBColorSpace='srgb';var LinearSRGBColorSpace='srgb-linear';var KeepStencilOp=7680;var AlwaysStencilFunc=519;var StaticDrawUsage=35044;var GLSL3='300 es';var _SRGBAFormat=1035;// fallback for WebGL 1
  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */var EventDispatcher=/*#__PURE__*/function(){function EventDispatcher(){_classCallCheck(this,EventDispatcher);}_createClass(EventDispatcher,[{key:"addEventListener",value:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}}},{key:"hasEventListener",value:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;}},{key:"removeEventListener",value:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}}},{key:"dispatchEvent",value:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
  var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}event.target=null;}}}]);return EventDispatcher;}();var _lut=['00','01','02','03','04','05','06','07','08','09','0a','0b','0c','0d','0e','0f','10','11','12','13','14','15','16','17','18','19','1a','1b','1c','1d','1e','1f','20','21','22','23','24','25','26','27','28','29','2a','2b','2c','2d','2e','2f','30','31','32','33','34','35','36','37','38','39','3a','3b','3c','3d','3e','3f','40','41','42','43','44','45','46','47','48','49','4a','4b','4c','4d','4e','4f','50','51','52','53','54','55','56','57','58','59','5a','5b','5c','5d','5e','5f','60','61','62','63','64','65','66','67','68','69','6a','6b','6c','6d','6e','6f','70','71','72','73','74','75','76','77','78','79','7a','7b','7c','7d','7e','7f','80','81','82','83','84','85','86','87','88','89','8a','8b','8c','8d','8e','8f','90','91','92','93','94','95','96','97','98','99','9a','9b','9c','9d','9e','9f','a0','a1','a2','a3','a4','a5','a6','a7','a8','a9','aa','ab','ac','ad','ae','af','b0','b1','b2','b3','b4','b5','b6','b7','b8','b9','ba','bb','bc','bd','be','bf','c0','c1','c2','c3','c4','c5','c6','c7','c8','c9','ca','cb','cc','cd','ce','cf','d0','d1','d2','d3','d4','d5','d6','d7','d8','d9','da','db','dc','dd','de','df','e0','e1','e2','e3','e4','e5','e6','e7','e8','e9','ea','eb','ec','ed','ee','ef','f0','f1','f2','f3','f4','f5','f6','f7','f8','f9','fa','fb','fc','fd','fe','ff'];var DEG2RAD=Math.PI/180;var RAD2DEG=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  function generateUUID(){var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;var uuid=_lut[d0&0xff]+_lut[d0>>8&0xff]+_lut[d0>>16&0xff]+_lut[d0>>24&0xff]+'-'+_lut[d1&0xff]+_lut[d1>>8&0xff]+'-'+_lut[d1>>16&0x0f|0x40]+_lut[d1>>24&0xff]+'-'+_lut[d2&0x3f|0x80]+_lut[d2>>8&0xff]+'-'+_lut[d2>>16&0xff]+_lut[d2>>24&0xff]+_lut[d3&0xff]+_lut[d3>>8&0xff]+_lut[d3>>16&0xff]+_lut[d3>>24&0xff];// .toLowerCase() here flattens concatenated strings to save heap memory space.
  return uuid.toLowerCase();}function clamp(value,min,max){return Math.max(min,Math.min(max,value));}// compute euclidean modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo(n,m){return (n%m+m)%m;}// Linear mapping from range <a1, a2> to range <b1, b2>
  function lerp(x,y,t){return (1-t)*x+t*y;}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function isPowerOfTwo(value){return (value&value-1)===0&&value!==0;}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}function denormalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint16Array:return value/65535.0;case Uint8Array:return value/255.0;case Int16Array:return Math.max(value/32767.0,-1.0);case Int8Array:return Math.max(value/127.0,-1.0);default:throw new Error('Invalid component type.');}}function normalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint16Array:return Math.round(value*65535.0);case Uint8Array:return Math.round(value*255.0);case Int16Array:return Math.round(value*32767.0);case Int8Array:return Math.round(value*127.0);default:throw new Error('Invalid component type.');}}var Vector2=/*#__PURE__*/function(_Symbol$iterator){function Vector2(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Vector2);Vector2.prototype.isVector2=true;this.x=x;this.y=y;}_createClass(Vector2,[{key:"width",get:function get(){return this.x;},set:function set(value){this.x=value;}},{key:"height",get:function get(){return this.y;},set:function set(value){this.y=value;}},{key:"set",value:function set(x,y){this.x=x;this.y=y;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;return this;}},{key:"add",value:function add(v){this.x+=v.x;this.y+=v.y;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;}},{key:"sub",value:function sub(v){this.x-=v.x;this.y-=v.y;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;}},{key:"multiply",value:function multiply(v){this.x*=v.x;this.y*=v.y;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;}},{key:"divide",value:function divide(v){this.x/=v.x;this.y/=v.y;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"applyMatrix3",value:function applyMatrix3(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y;}},{key:"cross",value:function cross(v){return this.x*v.y-this.y*v.x;}},{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"angle",value:function angle(){// computes the angle in radians with respect to the positive x-axis
  var angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;}},{key:"distanceTo",value:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}},{key:"distanceToSquared",value:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;}},{key:"manhattanDistanceTo",value:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this;}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);return this;}},{key:"rotateAround",value:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();return this;}},{key:_Symbol$iterator,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.x;case 2:_context2.next=4;return this.y;case 4:case"end":return _context2.stop();}}},value,this);})}]);return Vector2;}(Symbol.iterator);var Matrix3=/*#__PURE__*/function(){function Matrix3(){_classCallCheck(this,Matrix3);Matrix3.prototype.isMatrix3=true;this.elements=[1,0,0,0,1,0,0,0,1];}_createClass(Matrix3,[{key:"set",value:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;}},{key:"identity",value:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;}},{key:"copy",value:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;}},{key:"extractBasis",value:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;}},{key:"setFromMatrix4",value:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;}},{key:"multiply",value:function multiply(m){return this.multiplyMatrices(this,m);}},{key:"premultiply",value:function premultiply(m){return this.multiplyMatrices(m,this);}},{key:"multiplyMatrices",value:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;}},{key:"determinant",value:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;}},{key:"invert",value:function invert(){var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;}},{key:"transpose",value:function transpose(){var tmp;var m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;}},{key:"getNormalMatrix",value:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose();}},{key:"transposeIntoArray",value:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;}},{key:"setUvTransform",value:function setUvTransform(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);return this;}},{key:"scale",value:function scale(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;}},{key:"rotate",value:function rotate(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;}},{key:"translate",value:function translate(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;}},{key:"equals",value:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}},{key:"clone",value:function clone(){return new this.constructor().fromArray(this.elements);}}]);return Matrix3;}();function arrayNeedsUint32(array){// assumes larger values usually on last
  for(var i=array.length-1;i>=0;--i){if(array[i]>=65535)return true;// account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }return false;}function createElementNS(name){return document.createElementNS('http://www.w3.org/1999/xhtml',name);}function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}// JavaScript RGB-to-RGB transforms, defined as
  // FN[InputColorSpace][OutputColorSpace] callback functions.
  var FN=(_FN={},_defineProperty(_FN,SRGBColorSpace,_defineProperty({},LinearSRGBColorSpace,SRGBToLinear)),_defineProperty(_FN,LinearSRGBColorSpace,_defineProperty({},SRGBColorSpace,LinearToSRGB)),_FN);var ColorManagement={legacyMode:true,get workingColorSpace(){return LinearSRGBColorSpace;},set workingColorSpace(colorSpace){console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');},convert:function convert(color,sourceColorSpace,targetColorSpace){if(this.legacyMode||sourceColorSpace===targetColorSpace||!sourceColorSpace||!targetColorSpace){return color;}if(FN[sourceColorSpace]&&FN[sourceColorSpace][targetColorSpace]!==undefined){var fn=FN[sourceColorSpace][targetColorSpace];color.r=fn(color.r);color.g=fn(color.g);color.b=fn(color.b);return color;}throw new Error('Unsupported color space conversion.');},fromWorkingColorSpace:function fromWorkingColorSpace(color,targetColorSpace){return this.convert(color,this.workingColorSpace,targetColorSpace);},toWorkingColorSpace:function toWorkingColorSpace(color,sourceColorSpace){return this.convert(color,sourceColorSpace,this.workingColorSpace);}};var _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};var _rgb={r:0,g:0,b:0};var _hslA={h:0,s:0,l:0};var _hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}function toComponents(source,target){target.r=source.r;target.g=source.g;target.b=source.b;return target;}var Color$1=/*#__PURE__*/function(_Symbol$iterator2){function Color(r,g,b){_classCallCheck(this,Color);this.isColor=true;this.r=1;this.g=1;this.b=1;if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
  return this.set(r);}return this.setRGB(r,g,b);}_createClass(Color,[{key:"set",value:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;}},{key:"setScalar",value:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;}},{key:"setHex",value:function setHex(hex){var colorSpace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:SRGBColorSpace;hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}},{key:"setRGB",value:function setRGB(r,g,b){var colorSpace=arguments.length>3&&arguments[3]!==undefined?arguments[3]:LinearSRGBColorSpace;this.r=r;this.g=g;this.b=b;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}},{key:"setHSL",value:function setHSL(h,s,l){var colorSpace=arguments.length>3&&arguments[3]!==undefined?arguments[3]:LinearSRGBColorSpace;// h,s,l ranges are in 0.0 - 1.0
  h=euclideanModulo(h,1);s=clamp(s,0,1);l=clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else {var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}},{key:"setStyle",value:function setStyle(style){var colorSpace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:SRGBColorSpace;function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)){// rgb / hsl
  var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
  this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;ColorManagement.toWorkingColorSpace(this,colorSpace);handleAlpha(color[4]);return this;}if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;ColorManagement.toWorkingColorSpace(this,colorSpace);handleAlpha(color[4]);return this;}break;case'hsl':case'hsla':if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  var h=parseFloat(color[1])/360;var s=parseFloat(color[2])/100;var l=parseFloat(color[3])/100;handleAlpha(color[4]);return this.setHSL(h,s,l,colorSpace);}break;}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){// hex color
  var hex=m[1];var size=hex.length;if(size===3){// #ff0
  this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}else if(size===6){// #ff0000
  this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;ColorManagement.toWorkingColorSpace(this,colorSpace);return this;}}if(style&&style.length>0){return this.setColorName(style,colorSpace);}return this;}},{key:"setColorName",value:function setColorName(style){var colorSpace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:SRGBColorSpace;// color keywords
  var hex=_colorKeywords[style.toLowerCase()];if(hex!==undefined){// red
  this.setHex(hex,colorSpace);}else {// unknown color
  console.warn('THREE.Color: Unknown color '+style);}return this;}},{key:"clone",value:function clone(){return new this.constructor(this.r,this.g,this.b);}},{key:"copy",value:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;}},{key:"copySRGBToLinear",value:function copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;}},{key:"copyLinearToSRGB",value:function copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;}},{key:"convertSRGBToLinear",value:function convertSRGBToLinear(){this.copySRGBToLinear(this);return this;}},{key:"convertLinearToSRGB",value:function convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;}},{key:"getHex",value:function getHex(){var colorSpace=arguments.length>0&&arguments[0]!==undefined?arguments[0]:SRGBColorSpace;ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);return clamp(_rgb.r*255,0,255)<<16^clamp(_rgb.g*255,0,255)<<8^clamp(_rgb.b*255,0,255)<<0;}},{key:"getHexString",value:function getHexString(){var colorSpace=arguments.length>0&&arguments[0]!==undefined?arguments[0]:SRGBColorSpace;return ('000000'+this.getHex(colorSpace).toString(16)).slice(-6);}},{key:"getHSL",value:function getHSL(target){var colorSpace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:LinearSRGBColorSpace;// h,s,l ranges are in 0.0 - 1.0
  ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);var r=_rgb.r,g=_rgb.g,b=_rgb.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else {var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;}},{key:"getRGB",value:function getRGB(target){var colorSpace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:LinearSRGBColorSpace;ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);target.r=_rgb.r;target.g=_rgb.g;target.b=_rgb.b;return target;}},{key:"getStyle",value:function getStyle(){var colorSpace=arguments.length>0&&arguments[0]!==undefined?arguments[0]:SRGBColorSpace;ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);if(colorSpace!==SRGBColorSpace){// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
  return "color(".concat(colorSpace," ").concat(_rgb.r," ").concat(_rgb.g," ").concat(_rgb.b,")");}return "rgb(".concat(_rgb.r*255|0,",").concat(_rgb.g*255|0,",").concat(_rgb.b*255|0,")");}},{key:"offsetHSL",value:function offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this;}},{key:"add",value:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;}},{key:"addColors",value:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;}},{key:"addScalar",value:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;}},{key:"sub",value:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;}},{key:"multiply",value:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;}},{key:"lerp",value:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;}},{key:"lerpColors",value:function lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this;}},{key:"lerpHSL",value:function lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);var h=lerp(_hslA.h,_hslB.h,alpha);var s=lerp(_hslA.s,_hslB.s,alpha);var l=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;}},{key:"equals",value:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);return this;}},{key:"toJSON",value:function toJSON(){return this.getHex();}},{key:_Symbol$iterator2,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.r;case 2:_context3.next=4;return this.g;case 4:_context3.next=6;return this.b;case 6:case"end":return _context3.stop();}}},value,this);})}]);return Color;}(Symbol.iterator);Color$1.NAMES=_colorKeywords;var _canvas;var ImageUtils=/*#__PURE__*/function(){function ImageUtils(){_classCallCheck(this,ImageUtils);}_createClass(ImageUtils,null,[{key:"getDataURL",value:function getDataURL(image){if(/^data:/i.test(image.src)){return image.src;}if(typeof HTMLCanvasElement=='undefined'){return image.src;}var canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else {if(_canvas===undefined)_canvas=createElementNS('canvas');_canvas.width=image.width;_canvas.height=image.height;var context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else {context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',image);return canvas.toDataURL('image/jpeg',0.6);}else {return canvas.toDataURL('image/png');}}},{key:"sRGBToLinear",value:function sRGBToLinear(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){var canvas=createElementNS('canvas');canvas.width=image.width;canvas.height=image.height;var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height);var imageData=context.getImageData(0,0,image.width,image.height);var data=imageData.data;for(var i=0;i<data.length;i++){data[i]=SRGBToLinear(data[i]/255)*255;}context.putImageData(imageData,0,0);return canvas;}else if(image.data){var _data=image.data.slice(0);for(var _i=0;_i<_data.length;_i++){if(_data instanceof Uint8Array||_data instanceof Uint8ClampedArray){_data[_i]=Math.floor(SRGBToLinear(_data[_i]/255)*255);}else {// assuming float
  _data[_i]=SRGBToLinear(_data[_i]);}}return {data:_data,width:image.width,height:image.height};}else {console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');return image;}}}]);return ImageUtils;}();var Source=/*#__PURE__*/function(){function Source(){var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;_classCallCheck(this,Source);this.isSource=true;this.uuid=generateUUID();this.data=data;this.version=0;}_createClass(Source,[{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}},{key:"toJSON",value:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.images[this.uuid]!==undefined){return meta.images[this.uuid];}var output={uuid:this.uuid,url:''};var data=this.data;if(data!==null){var url;if(Array.isArray(data)){// cube texture
  url=[];for(var i=0,l=data.length;i<l;i++){if(data[i].isDataTexture){url.push(serializeImage(data[i].image));}else {url.push(serializeImage(data[i]));}}}else {// texture
  url=serializeImage(data);}output.url=url;}if(!isRootObject){meta.images[this.uuid]=output;}return output;}}]);return Source;}();function serializeImage(image){if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){// default images
  return ImageUtils.getDataURL(image);}else {if(image.data){// images of DataTexture
  return {data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name};}else {console.warn('THREE.Texture: Unable to serialize Texture.');return {};}}}var textureId=0;var Texture=/*#__PURE__*/function(_EventDispatcher){_inherits(Texture,_EventDispatcher);var _super=_createSuper(Texture);function Texture(){var _this2;var image=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Texture.DEFAULT_IMAGE;var mapping=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Texture.DEFAULT_MAPPING;var wrapS=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ClampToEdgeWrapping;var wrapT=arguments.length>3&&arguments[3]!==undefined?arguments[3]:ClampToEdgeWrapping;var magFilter=arguments.length>4&&arguments[4]!==undefined?arguments[4]:LinearFilter;var minFilter=arguments.length>5&&arguments[5]!==undefined?arguments[5]:LinearMipmapLinearFilter;var format=arguments.length>6&&arguments[6]!==undefined?arguments[6]:RGBAFormat;var type=arguments.length>7&&arguments[7]!==undefined?arguments[7]:UnsignedByteType;var anisotropy=arguments.length>8&&arguments[8]!==undefined?arguments[8]:1;var encoding=arguments.length>9&&arguments[9]!==undefined?arguments[9]:LinearEncoding;_classCallCheck(this,Texture);_this2=_super.call(this);_this2.isTexture=true;Object.defineProperty(_assertThisInitialized(_this2),'id',{value:textureId++});_this2.uuid=generateUUID();_this2.name='';_this2.source=new Source(image);_this2.mipmaps=[];_this2.mapping=mapping;_this2.wrapS=wrapS;_this2.wrapT=wrapT;_this2.magFilter=magFilter;_this2.minFilter=minFilter;_this2.anisotropy=anisotropy;_this2.format=format;_this2.internalFormat=null;_this2.type=type;_this2.offset=new Vector2(0,0);_this2.repeat=new Vector2(1,1);_this2.center=new Vector2(0,0);_this2.rotation=0;_this2.matrixAutoUpdate=true;_this2.matrix=new Matrix3();_this2.generateMipmaps=true;_this2.premultiplyAlpha=false;_this2.flipY=true;_this2.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  _this2.encoding=encoding;_this2.userData={};_this2.version=0;_this2.onUpdate=null;_this2.isRenderTargetTexture=false;// indicates whether a texture belongs to a render target or not
  _this2.needsPMREMUpdate=false;// indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
  return _this2;}_createClass(Texture,[{key:"image",get:function get(){return this.source.data;},set:function set(value){this.source.data=value;}},{key:"updateMatrix",value:function updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.name=source.name;this.source=source.source;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;this.userData=JSON.parse(JSON.stringify(source.userData));this.needsUpdate=true;return this;}},{key:"toJSON",value:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(JSON.stringify(this.userData)!=='{}')output.userData=this.userData;if(!isRootObject){meta.textures[this.uuid]=output;}return output;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}},{key:"transformUv",value:function transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else {uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else {uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}},{key:"needsUpdate",set:function set(value){if(value===true){this.version++;this.source.needsUpdate=true;}}}]);return Texture;}(EventDispatcher);Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;var Vector4=/*#__PURE__*/function(_Symbol$iterator3){function Vector4(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,Vector4);Vector4.prototype.isVector4=true;this.x=x;this.y=y;this.z=z;this.w=w;}_createClass(Vector4,[{key:"width",get:function get(){return this.z;},set:function set(value){this.z=value;}},{key:"height",get:function get(){return this.w;},set:function set(value){this.w=value;}},{key:"set",value:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setZ",value:function setZ(z){this.z=z;return this;}},{key:"setW",value:function setW(w){this.w=w;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;}},{key:"add",value:function add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;}},{key:"sub",value:function sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;}},{key:"multiply",value:function multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;}},{key:"applyMatrix4",value:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"setAxisAngleFromQuaternion",value:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
  // q is assumed to be normalized
  this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else {this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;}},{key:"setAxisAngleFromRotationMatrix",value:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var angle,x,y,z;// variables for result
  var epsilon=0.01,// margin to allow for rounding errors
  epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
  te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
  // first check for identity matrix which must have +1 for all terms
  // in leading diagonal and zero in other terms
  if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
  this.set(1,0,0,0);return this;// zero angle, arbitrary axis
  }// otherwise this singularity is angle = 180
  angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
  if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else {x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
  if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else {y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else {// m33 is the largest diagonal term so base result on this
  if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else {z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
  }// as we have reached here there are no singularities so we can handle normally
  var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
  if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
  // caught by singularity test above, but I've left it in just in case
  this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;}},{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this;}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();this.w=Math.random();return this;}},{key:_Symbol$iterator3,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.x;case 2:_context4.next=4;return this.y;case 4:_context4.next=6;return this.z;case 6:_context4.next=8;return this.w;case 8:case"end":return _context4.stop();}}},value,this);})}]);return Vector4;}(Symbol.iterator);/*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */var WebGLRenderTarget=/*#__PURE__*/function(_EventDispatcher2){_inherits(WebGLRenderTarget,_EventDispatcher2);var _super2=_createSuper(WebGLRenderTarget);function WebGLRenderTarget(width,height){var _this3;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,WebGLRenderTarget);_this3=_super2.call(this);_this3.isWebGLRenderTarget=true;_this3.width=width;_this3.height=height;_this3.depth=1;_this3.scissor=new Vector4(0,0,width,height);_this3.scissorTest=false;_this3.viewport=new Vector4(0,0,width,height);var image={width:width,height:height,depth:1};_this3.texture=new Texture(image,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);_this3.texture.isRenderTargetTexture=true;_this3.texture.flipY=false;_this3.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;_this3.texture.internalFormat=options.internalFormat!==undefined?options.internalFormat:null;_this3.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;_this3.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;_this3.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:false;_this3.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;_this3.samples=options.samples!==undefined?options.samples:0;return _this3;}_createClass(WebGLRenderTarget,[{key:"setSize",value:function setSize(width,height){var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;this.texture.image.width=width;this.texture.image.height=height;this.texture.image.depth=depth;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.texture.isRenderTargetTexture=true;// ensure image object is not shared, see #20328
  var image=Object.assign({},source.texture.image);this.texture.source=new Source(image);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;if(source.depthTexture!==null)this.depthTexture=source.depthTexture.clone();this.samples=source.samples;return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}}]);return WebGLRenderTarget;}(EventDispatcher);var DataArrayTexture=/*#__PURE__*/function(_Texture){_inherits(DataArrayTexture,_Texture);var _super3=_createSuper(DataArrayTexture);function DataArrayTexture(){var _this4;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,DataArrayTexture);_this4=_super3.call(this,null);_this4.isDataArrayTexture=true;_this4.image={data:data,width:width,height:height,depth:depth};_this4.magFilter=NearestFilter;_this4.minFilter=NearestFilter;_this4.wrapR=ClampToEdgeWrapping;_this4.generateMipmaps=false;_this4.flipY=false;_this4.unpackAlignment=1;return _this4;}return _createClass(DataArrayTexture);}(Texture);var Data3DTexture=/*#__PURE__*/function(_Texture2){_inherits(Data3DTexture,_Texture2);var _super5=_createSuper(Data3DTexture);function Data3DTexture(){var _this6;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var width=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var height=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var depth=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,Data3DTexture);// We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  _this6=_super5.call(this,null);_this6.isData3DTexture=true;_this6.image={data:data,width:width,height:height,depth:depth};_this6.magFilter=NearestFilter;_this6.minFilter=NearestFilter;_this6.wrapR=ClampToEdgeWrapping;_this6.generateMipmaps=false;_this6.flipY=false;_this6.unpackAlignment=1;return _this6;}return _createClass(Data3DTexture);}(Texture);var Quaternion=/*#__PURE__*/function(_Symbol$iterator4){function Quaternion(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var w=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,Quaternion);this.isQuaternion=true;this._x=x;this._y=y;this._z=z;this._w=w;}_createClass(Quaternion,[{key:"x",get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},{key:"y",get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},{key:"z",get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},{key:"w",get:function get(){return this._w;},set:function set(value){this._w=value;this._onChangeCallback();}},{key:"set",value:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;}},{key:"clone",value:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);}},{key:"copy",value:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;}},{key:"setFromEuler",value:function setFromEuler(euler,update){var x=euler._x,y=euler._y,z=euler._z,order=euler._order;// http://www.mathworks.com/matlabcentral/fileexchange/
  // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  //	content/SpinCalc.m
  var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);switch(order){case'XYZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'YXZ':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'ZXY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'ZYX':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;case'YZX':this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;break;case'XZY':this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: '+order);}if(update!==false)this._onChangeCallback();return this;}},{key:"setFromAxisAngle",value:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
  // assumes axis is normalized
  var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;}},{key:"setFromRotationMatrix",value:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){var s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){var _s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/_s;this._x=0.25*_s;this._y=(m12+m21)/_s;this._z=(m13+m31)/_s;}else if(m22>m33){var _s2=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/_s2;this._x=(m12+m21)/_s2;this._y=0.25*_s2;this._z=(m23+m32)/_s2;}else {var _s3=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/_s3;this._x=(m13+m31)/_s3;this._y=(m23+m32)/_s3;this._z=0.25*_s3;}this._onChangeCallback();return this;}},{key:"setFromUnitVectors",value:function setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
  var r=vFrom.dot(vTo)+1;if(r<Number.EPSILON){// vFrom and vTo point in opposite directions
  r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else {this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else {// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
  this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();}},{key:"angleTo",value:function angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)));}},{key:"rotateTowards",value:function rotateTowards(q,step){var angle=this.angleTo(q);if(angle===0)return this;var t=Math.min(1,step/angle);this.slerp(q,t);return this;}},{key:"identity",value:function identity(){return this.set(0,0,0,1);}},{key:"invert",value:function invert(){// quaternion is assumed to have unit length
  return this.conjugate();}},{key:"conjugate",value:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;}},{key:"dot",value:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;}},{key:"lengthSq",value:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;}},{key:"length",value:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);}},{key:"normalize",value:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else {l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;}},{key:"multiply",value:function multiply(q){return this.multiplyQuaternions(this,q);}},{key:"premultiply",value:function premultiply(q){return this.multiplyQuaternions(q,this);}},{key:"multiplyQuaternions",value:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
  var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;}},{key:"slerp",value:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
  var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else {this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){var s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();this._onChangeCallback();return this;}var sinHalfTheta=Math.sqrt(sqrSinHalfTheta);var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;}},{key:"slerpQuaternions",value:function slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t);}},{key:"random",value:function random(){// Derived from http://planning.cs.uiuc.edu/node198.html
  // Note, this source uses w, x, y, z ordering,
  // so we swap the order below.
  var u1=Math.random();var sqrt1u1=Math.sqrt(1-u1);var sqrtu1=Math.sqrt(u1);var u2=2*Math.PI*Math.random();var u3=2*Math.PI*Math.random();return this.set(sqrt1u1*Math.cos(u2),sqrtu1*Math.sin(u3),sqrtu1*Math.cos(u3),sqrt1u1*Math.sin(u2));}},{key:"equals",value:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this;}},{key:"_onChange",value:function _onChange(callback){this._onChangeCallback=callback;return this;}},{key:"_onChangeCallback",value:function _onChangeCallback(){}},{key:_Symbol$iterator4,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return this._x;case 2:_context5.next=4;return this._y;case 4:_context5.next=6;return this._z;case 6:_context5.next=8;return this._w;case 8:case"end":return _context5.stop();}}},value,this);})}],[{key:"slerpFlat",value:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
  var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];var x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t===0){dst[dstOffset+0]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;return;}if(t===1){dst[dstOffset+0]=x1;dst[dstOffset+1]=y1;dst[dstOffset+2]=z1;dst[dstOffset+3]=w1;return;}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t;var cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
  if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
  if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}},{key:"multiplyQuaternionsFlat",value:function multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){var x0=src0[srcOffset0];var y0=src0[srcOffset0+1];var z0=src0[srcOffset0+2];var w0=src0[srcOffset0+3];var x1=src1[srcOffset1];var y1=src1[srcOffset1+1];var z1=src1[srcOffset1+2];var w1=src1[srcOffset1+3];dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1;dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1;dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1;dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1;return dst;}}]);return Quaternion;}(Symbol.iterator);var Vector3=/*#__PURE__*/function(_Symbol$iterator5){function Vector3(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_classCallCheck(this,Vector3);Vector3.prototype.isVector3=true;this.x=x;this.y=y;this.z=z;}_createClass(Vector3,[{key:"set",value:function set(x,y,z){if(z===undefined)z=this.z;// sprite.scale.set(x,y)
  this.x=x;this.y=y;this.z=z;return this;}},{key:"setScalar",value:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;}},{key:"setX",value:function setX(x){this.x=x;return this;}},{key:"setY",value:function setY(y){this.y=y;return this;}},{key:"setZ",value:function setZ(z){this.z=z;return this;}},{key:"setComponent",value:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;}},{key:"getComponent",value:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}}},{key:"clone",value:function clone(){return new this.constructor(this.x,this.y,this.z);}},{key:"copy",value:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;}},{key:"add",value:function add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}},{key:"addScalar",value:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;}},{key:"addVectors",value:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;}},{key:"addScaledVector",value:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;}},{key:"sub",value:function sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}},{key:"subScalar",value:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;}},{key:"subVectors",value:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;}},{key:"multiply",value:function multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;}},{key:"multiplyScalar",value:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;}},{key:"multiplyVectors",value:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;}},{key:"applyEuler",value:function applyEuler(euler){return this.applyQuaternion(_quaternion$4.setFromEuler(euler));}},{key:"applyAxisAngle",value:function applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle));}},{key:"applyMatrix3",value:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;}},{key:"applyNormalMatrix",value:function applyNormalMatrix(m){return this.applyMatrix3(m).normalize();}},{key:"applyMatrix4",value:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;}},{key:"applyQuaternion",value:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
  var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
  this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;}},{key:"project",value:function project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);}},{key:"unproject",value:function unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);}},{key:"transformDirection",value:function transformDirection(m){// input: THREE.Matrix4 affine matrix
  // vector interpreted as a direction
  var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();}},{key:"divide",value:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;}},{key:"divideScalar",value:function divideScalar(scalar){return this.multiplyScalar(1/scalar);}},{key:"min",value:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;}},{key:"max",value:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;}},{key:"clamp",value:function clamp(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;}},{key:"clampScalar",value:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this;}},{key:"clampLength",value:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));}},{key:"floor",value:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;}},{key:"ceil",value:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;}},{key:"round",value:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;}},{key:"roundToZero",value:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;}},{key:"negate",value:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}},{key:"dot",value:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;}// TODO lengthSquared?
  },{key:"lengthSq",value:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;}},{key:"length",value:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);}},{key:"manhattanLength",value:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);}},{key:"normalize",value:function normalize(){return this.divideScalar(this.length()||1);}},{key:"setLength",value:function setLength(length){return this.normalize().multiplyScalar(length);}},{key:"lerp",value:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;}},{key:"lerpVectors",value:function lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this;}},{key:"cross",value:function cross(v){return this.crossVectors(this,v);}},{key:"crossVectors",value:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;}},{key:"projectOnVector",value:function projectOnVector(v){var denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);var scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);}},{key:"projectOnPlane",value:function projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);return this.sub(_vector$c);}},{key:"reflect",value:function reflect(normal){// reflect incident vector off plane orthogonal to normal
  // normal is assumed to have unit length
  return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)));}},{key:"angleTo",value:function angleTo(v){var denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;var theta=this.dot(v)/denominator;// clamp, to handle numerical problems
  return Math.acos(clamp(theta,-1,1));}},{key:"distanceTo",value:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));}},{key:"distanceToSquared",value:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;}},{key:"manhattanDistanceTo",value:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);}},{key:"setFromSpherical",value:function setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);}},{key:"setFromSphericalCoords",value:function setFromSphericalCoords(radius,phi,theta){var sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;}},{key:"setFromCylindrical",value:function setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);}},{key:"setFromCylindricalCoords",value:function setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;}},{key:"setFromMatrixPosition",value:function setFromMatrixPosition(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;}},{key:"setFromMatrixScale",value:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;}},{key:"setFromMatrixColumn",value:function setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);}},{key:"setFromMatrix3Column",value:function setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);}},{key:"setFromEuler",value:function setFromEuler(e){this.x=e._x;this.y=e._y;this.z=e._z;return this;}},{key:"equals",value:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;}},{key:"fromBufferAttribute",value:function fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}},{key:"random",value:function random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this;}},{key:"randomDirection",value:function randomDirection(){// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
  var u=(Math.random()-0.5)*2;var t=Math.random()*Math.PI*2;var f=Math.sqrt(1-Math.pow(u,2));this.x=f*Math.cos(t);this.y=f*Math.sin(t);this.z=u;return this;}},{key:_Symbol$iterator5,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return this.x;case 2:_context6.next=4;return this.y;case 4:_context6.next=6;return this.z;case 6:case"end":return _context6.stop();}}},value,this);})}]);return Vector3;}(Symbol.iterator);var _vector$c=/*@__PURE__*/new Vector3();var _quaternion$4=/*@__PURE__*/new Quaternion();var Box3=/*#__PURE__*/function(){function Box3(){var min=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(+Infinity,+Infinity,+Infinity);var max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(-Infinity,-Infinity,-Infinity);_classCallCheck(this,Box3);this.isBox3=true;this.min=min;this.max=max;}_createClass(Box3,[{key:"set",value:function set(min,max){this.min.copy(min);this.max.copy(max);return this;}},{key:"setFromArray",value:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}},{key:"setFromBufferAttribute",value:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;}},{key:"setFromPoints",value:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;}},{key:"setFromCenterAndSize",value:function setFromCenterAndSize(center,size){var halfSize=_vector$b.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;}},{key:"setFromObject",value:function setFromObject(object){var precise=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;this.makeEmpty();return this.expandByObject(object,precise);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;}},{key:"makeEmpty",value:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;}},{key:"isEmpty",value:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;}},{key:"getCenter",value:function getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);}},{key:"getSize",value:function getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);}},{key:"expandByPoint",value:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;}},{key:"expandByVector",value:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;}},{key:"expandByScalar",value:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;}},{key:"expandByObject",value:function expandByObject(object){var precise=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// Computes the world-axis-aligned bounding box of an object (including its children),
  // accounting for both the object's, and children's, world transforms
  object.updateWorldMatrix(false,false);var geometry=object.geometry;if(geometry!==undefined){if(precise&&geometry.attributes!=undefined&&geometry.attributes.position!==undefined){var position=geometry.attributes.position;for(var i=0,l=position.count;i<l;i++){_vector$b.fromBufferAttribute(position,i).applyMatrix4(object.matrixWorld);this.expandByPoint(_vector$b);}}else {if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box$3.copy(geometry.boundingBox);_box$3.applyMatrix4(object.matrixWorld);this.union(_box$3);}}var children=object.children;for(var _i2=0,_l=children.length;_i2<_l;_i2++){this.expandByObject(children[_i2],precise);}return this;}},{key:"containsPoint",value:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;}},{key:"containsBox",value:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;}},{key:"getParameter",value:function getParameter(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));}},{key:"intersectsBox",value:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;}},{key:"intersectsSphere",value:function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
  this.clampPoint(sphere.center,_vector$b);// If that point is inside the sphere, the AABB and sphere intersect.
  return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;}},{key:"intersectsPlane",value:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
  // are on the same side (back or front) of the plane, then there is no intersection.
  var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else {min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else {min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else {min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;}},{key:"intersectsTriangle",value:function intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
  this.getCenter(_center);_extents.subVectors(this.max,_center);// translate triangle to aabb origin
  _v0$2.subVectors(triangle.a,_center);_v1$7.subVectors(triangle.b,_center);_v2$3.subVectors(triangle.c,_center);// compute edge vectors for triangle
  _f0.subVectors(_v1$7,_v0$2);_f1.subVectors(_v2$3,_v1$7);_f2.subVectors(_v0$2,_v2$3);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  var axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// test 3 face normals from the aabb
  axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents)){return false;}// finally testing the face normal of the triangle
  // use already existing triangle edge vectors here
  _triangleNormal.crossVectors(_f0,_f1);axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(axes,_v0$2,_v1$7,_v2$3,_extents);}},{key:"clampPoint",value:function clampPoint(point,target){return target.copy(point).clamp(this.min,this.max);}},{key:"distanceToPoint",value:function distanceToPoint(point){var clampedPoint=_vector$b.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();}},{key:"getBoundingSphere",value:function getBoundingSphere(target){this.getCenter(target.center);target.radius=this.getSize(_vector$b).length()*0.5;return target;}},{key:"intersect",value:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  if(this.isEmpty())this.makeEmpty();return this;}},{key:"union",value:function union(box){this.min.min(box.min);this.max.max(box.max);return this;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){// transform of empty box is an empty box.
  if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  _points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
  _points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
  _points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
  _points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
  _points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
  _points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
  _points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
  _points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
  this.setFromPoints(_points);return this;}},{key:"translate",value:function translate(offset){this.min.add(offset);this.max.add(offset);return this;}},{key:"equals",value:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}}]);return Box3;}();var _points=[/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3(),/*@__PURE__*/new Vector3()];var _vector$b=/*@__PURE__*/new Vector3();var _box$3=/*@__PURE__*/new Box3();// triangle centered vertices
  var _v0$2=/*@__PURE__*/new Vector3();var _v1$7=/*@__PURE__*/new Vector3();var _v2$3=/*@__PURE__*/new Vector3();// triangle edge vectors
  var _f0=/*@__PURE__*/new Vector3();var _f1=/*@__PURE__*/new Vector3();var _f2=/*@__PURE__*/new Vector3();var _center=/*@__PURE__*/new Vector3();var _extents=/*@__PURE__*/new Vector3();var _triangleNormal=/*@__PURE__*/new Vector3();var _testAxis=/*@__PURE__*/new Vector3();function satForAxes(axes,v0,v1,v2,extents){for(var i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);// project the aabb onto the separating axis
  var r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z);// project all 3 vertices of the triangle onto the separating axis
  var p0=v0.dot(_testAxis);var p1=v1.dot(_testAxis);var p2=v2.dot(_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
  if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
  // the axis is separating and we can exit
  return false;}}return true;}var _box$2=/*@__PURE__*/new Box3();var _v1$6=/*@__PURE__*/new Vector3();var _toFarthestPoint=/*@__PURE__*/new Vector3();var _toPoint=/*@__PURE__*/new Vector3();var Sphere=/*#__PURE__*/function(){function Sphere(){var center=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var radius=arguments.length>1&&arguments[1]!==undefined?arguments[1]:-1;_classCallCheck(this,Sphere);this.center=center;this.radius=radius;}_createClass(Sphere,[{key:"set",value:function set(center,radius){this.center.copy(center);this.radius=radius;return this;}},{key:"setFromPoints",value:function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else {_box$2.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;}},{key:"copy",value:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;}},{key:"isEmpty",value:function isEmpty(){return this.radius<0;}},{key:"makeEmpty",value:function makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this;}},{key:"containsPoint",value:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;}},{key:"distanceToPoint",value:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;}},{key:"intersectsSphere",value:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsSphere(this);}},{key:"intersectsPlane",value:function intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;}},{key:"clampPoint",value:function clampPoint(point,target){var deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;}},{key:"getBoundingBox",value:function getBoundingBox(target){if(this.isEmpty()){// Empty sphere produces empty bounding box
  target.makeEmpty();return target;}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;}},{key:"translate",value:function translate(offset){this.center.add(offset);return this;}},{key:"expandByPoint",value:function expandByPoint(point){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
  _toPoint.subVectors(point,this.center);var lengthSq=_toPoint.lengthSq();if(lengthSq>this.radius*this.radius){var length=Math.sqrt(lengthSq);var missingRadiusHalf=(length-this.radius)*0.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
  // and the other half to position. This gives a tighter enclosure, instead of if
  // the whole missing distance were just added to radius.
  this.center.add(_toPoint.multiplyScalar(missingRadiusHalf/length));this.radius+=missingRadiusHalf;}return this;}},{key:"union",value:function union(sphere){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
  // To enclose another sphere into this sphere, we only need to enclose two points:
  // 1) Enclose the farthest point on the other sphere into this sphere.
  // 2) Enclose the opposite point of the farthest point into this sphere.
  if(this.center.equals(sphere.center)===true){_toFarthestPoint.set(0,0,1).multiplyScalar(sphere.radius);}else {_toFarthestPoint.subVectors(sphere.center,this.center).normalize().multiplyScalar(sphere.radius);}this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));return this;}},{key:"equals",value:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Sphere;}();var _vector$a=/*@__PURE__*/new Vector3();var _segCenter=/*@__PURE__*/new Vector3();var _segDir=/*@__PURE__*/new Vector3();var _diff=/*@__PURE__*/new Vector3();var _edge1=/*@__PURE__*/new Vector3();var _edge2=/*@__PURE__*/new Vector3();var _normal$1=/*@__PURE__*/new Vector3();var Ray=/*#__PURE__*/function(){function Ray(){var origin=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var direction=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3(0,0,-1);_classCallCheck(this,Ray);this.origin=origin;this.direction=direction;}_createClass(Ray,[{key:"set",value:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;}},{key:"copy",value:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;}},{key:"at",value:function at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin);}},{key:"lookAt",value:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;}},{key:"recast",value:function recast(t){this.origin.copy(this.at(t,_vector$a));return this;}},{key:"closestPointToPoint",value:function closestPointToPoint(point,target){target.subVectors(point,this.origin);var directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);}},{key:"distanceToPoint",value:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));}},{key:"distanceSqToPoint",value:function distanceSqToPoint(point){var directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);// point behind the ray
  if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$a.distanceToSquared(point);}},{key:"distanceSqToSegment",value:function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
  // It returns the min distance between the ray and the segment
  // defined by v0 and v1
  // It can also set two optional targets :
  // - The closest point on the ray
  // - The closest point on the segment
  _segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(_segDir);var b0=_diff.dot(this.direction);var b1=-_diff.dot(_segDir);var c=_diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
  s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
  // Minimum at interior points of ray and segment.
  var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else {// region 1
  s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {// region 5
  s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else {if(s1<=-extDet){// region 4
  s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
  s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else {// region 2
  s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else {// Ray and segment are parallel.
  s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);}return sqrDist;}},{key:"intersectSphere",value:function intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,this.origin);var tca=_vector$a.dot(this.direction);var d2=_vector$a.dot(_vector$a)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
  var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
  var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
  if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
  // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  // in order to always return an intersect point that is in front of the ray.
  if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
  return this.at(t0,target);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;}},{key:"distanceToPlane",value:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
  if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
  return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
  return t>=0?t:null;}},{key:"intersectPlane",value:function intersectPlane(plane,target){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);}},{key:"intersectsPlane",value:function intersectsPlane(plane){// check if the ray lies on the plane first
  var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
  return false;}},{key:"intersectBox",value:function intersectBox(box,target){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else {tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else {tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
  // (result of 0 * Infinity). x !== x returns true if x is NaN
  if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else {tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
  if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);}},{key:"intersectsBox",value:function intersectsBox(box){return this.intersectBox(box,_vector$a)!==null;}},{key:"intersectTriangle",value:function intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
  // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
  _edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  var DdN=this.direction.dot(_normal$1);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else {return null;}_diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
  if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
  if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
  if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
  var QdN=-sign*_diff.dot(_normal$1);// t < 0, no intersection
  if(QdN<0){return null;}// Ray intersects triangle.
  return this.at(QdN/DdN,target);}},{key:"applyMatrix4",value:function applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;}},{key:"equals",value:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Ray;}();var Matrix4=/*#__PURE__*/function(){function Matrix4(){_classCallCheck(this,Matrix4);Matrix4.prototype.isMatrix4=true;this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}_createClass(Matrix4,[{key:"set",value:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;}},{key:"identity",value:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;}},{key:"clone",value:function clone(){return new Matrix4().fromArray(this.elements);}},{key:"copy",value:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;}},{key:"copyPosition",value:function copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;}},{key:"setFromMatrix3",value:function setFromMatrix3(m){var me=m.elements;this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1);return this;}},{key:"extractBasis",value:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;}},{key:"makeBasis",value:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;}},{key:"extractRotation",value:function extractRotation(m){// this method does not support reflection matrices
  var te=this.elements;var me=m.elements;var scaleX=1/_v1$5.setFromMatrixColumn(m,0).length();var scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();var scaleZ=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}},{key:"makeRotationFromEuler",value:function makeRotationFromEuler(euler){var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var _ce=c*e,_cf=c*f,_de=d*e,_df=d*f;te[0]=_ce-_df*b;te[4]=-a*f;te[8]=_de+_cf*b;te[1]=_cf+_de*b;te[5]=a*e;te[9]=_df-_ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var _ae=a*e,_af=a*f,_be=b*e,_bf=b*f;te[0]=c*e;te[4]=_be*d-_af;te[8]=_ae*d+_bf;te[1]=c*f;te[5]=_bf*d+_ae;te[9]=_af*d-_be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var _ac=a*c,_ad=a*d,_bc=b*c,_bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=_ac*f+_bd;te[5]=a*e;te[9]=_ad*f-_bc;te[2]=_bc*f-_ad;te[6]=b*e;te[10]=_bd*f+_ac;}// bottom row
  te[3]=0;te[7]=0;te[11]=0;// last column
  te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;}},{key:"makeRotationFromQuaternion",value:function makeRotationFromQuaternion(q){return this.compose(_zero,q,_one);}},{key:"lookAt",value:function lookAt(eye,target,up){var te=this.elements;_z.subVectors(eye,target);if(_z.lengthSq()===0){// eye and target are in the same position
  _z.z=1;}_z.normalize();_x.crossVectors(up,_z);if(_x.lengthSq()===0){// up and z are parallel
  if(Math.abs(up.z)===1){_z.x+=0.0001;}else {_z.z+=0.0001;}_z.normalize();_x.crossVectors(up,_z);}_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this;}},{key:"multiply",value:function multiply(m){return this.multiplyMatrices(this,m);}},{key:"premultiply",value:function premultiply(m){return this.multiplyMatrices(m,this);}},{key:"multiplyMatrices",value:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;}},{key:"multiplyScalar",value:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;}},{key:"determinant",value:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
  //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
  return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);}},{key:"transpose",value:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;}},{key:"setPosition",value:function setPosition(x,y,z){var te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else {te[12]=x;te[13]=y;te[14]=z;}return this;}},{key:"invert",value:function invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  var te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;}},{key:"scale",value:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;}},{key:"getMaxScaleOnAxis",value:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));}},{key:"makeTranslation",value:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;}},{key:"makeRotationX",value:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;}},{key:"makeRotationY",value:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;}},{key:"makeRotationZ",value:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;}},{key:"makeRotationAxis",value:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
  var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;}},{key:"makeScale",value:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;}},{key:"makeShear",value:function makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this;}},{key:"compose",value:function compose(position,quaternion,scale){var te=this.elements;var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;var sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;}},{key:"decompose",value:function decompose(position,quaternion,scale){var te=this.elements;var sx=_v1$5.set(te[0],te[1],te[2]).length();var sy=_v1$5.set(te[4],te[5],te[6]).length();var sz=_v1$5.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
  var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
  _m1$2.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;_m1$2.elements[0]*=invSX;_m1$2.elements[1]*=invSX;_m1$2.elements[2]*=invSX;_m1$2.elements[4]*=invSY;_m1$2.elements[5]*=invSY;_m1$2.elements[6]*=invSY;_m1$2.elements[8]*=invSZ;_m1$2.elements[9]*=invSZ;_m1$2.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2);scale.x=sx;scale.y=sy;scale.z=sz;return this;}},{key:"makePerspective",value:function makePerspective(left,right,top,bottom,near,far){var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;}},{key:"makeOrthographic",value:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;}},{key:"equals",value:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;}},{key:"fromArray",value:function fromArray(array){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}}]);return Matrix4;}();var _v1$5=/*@__PURE__*/new Vector3();var _m1$2=/*@__PURE__*/new Matrix4();var _zero=/*@__PURE__*/new Vector3(0,0,0);var _one=/*@__PURE__*/new Vector3(1,1,1);var _x=/*@__PURE__*/new Vector3();var _y=/*@__PURE__*/new Vector3();var _z=/*@__PURE__*/new Vector3();var _matrix$1=/*@__PURE__*/new Matrix4();var _quaternion$3=/*@__PURE__*/new Quaternion();var Euler=/*#__PURE__*/function(_Symbol$iterator6){function Euler(){var x=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var y=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var z=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Euler.DefaultOrder;_classCallCheck(this,Euler);this.isEuler=true;this._x=x;this._y=y;this._z=z;this._order=order;}_createClass(Euler,[{key:"x",get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},{key:"y",get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},{key:"z",get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},{key:"order",get:function get(){return this._order;},set:function set(value){this._order=value;this._onChangeCallback();}},{key:"set",value:function set(x,y,z){var order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:this._order;this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this;}},{key:"clone",value:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);}},{key:"copy",value:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;}},{key:"setFromRotationMatrix",value:function setFromRotationMatrix(m){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;var update=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];switch(order){case'XYZ':this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else {this._x=Math.atan2(m32,m22);this._z=0;}break;case'YXZ':this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else {this._y=Math.atan2(-m31,m11);this._z=0;}break;case'ZXY':this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else {this._y=0;this._z=Math.atan2(m21,m11);}break;case'ZYX':this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else {this._x=0;this._z=Math.atan2(-m12,m22);}break;case'YZX':this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else {this._x=0;this._y=Math.atan2(m13,m33);}break;case'XZY':this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else {this._x=Math.atan2(-m23,m33);this._y=0;}break;default:console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: '+order);}this._order=order;if(update===true)this._onChangeCallback();return this;}},{key:"setFromQuaternion",value:function setFromQuaternion(q,order,update){_matrix$1.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$1,order,update);}},{key:"setFromVector3",value:function setFromVector3(v){var order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._order;return this.set(v.x,v.y,v.z,order);}},{key:"reorder",value:function reorder(newOrder){// WARNING: this discards revolution information -bhouston
  _quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,newOrder);}},{key:"equals",value:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;}},{key:"fromArray",value:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;}},{key:"toArray",value:function toArray(){var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;}},{key:"_onChange",value:function _onChange(callback){this._onChangeCallback=callback;return this;}},{key:"_onChangeCallback",value:function _onChangeCallback(){}},{key:_Symbol$iterator6,value:/*#__PURE__*/_regeneratorRuntime().mark(function value(){return _regeneratorRuntime().wrap(function value$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.next=2;return this._x;case 2:_context7.next=4;return this._y;case 4:_context7.next=6;return this._z;case 6:_context7.next=8;return this._order;case 8:case"end":return _context7.stop();}}},value,this);})// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
  },{key:"toVector3",value:function toVector3(){console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead');}}]);return Euler;}(Symbol.iterator);Euler.DefaultOrder='XYZ';Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];var Layers=/*#__PURE__*/function(){function Layers(){_classCallCheck(this,Layers);this.mask=1|0;}_createClass(Layers,[{key:"set",value:function set(channel){this.mask=(1<<channel|0)>>>0;}},{key:"enable",value:function enable(channel){this.mask|=1<<channel|0;}},{key:"enableAll",value:function enableAll(){this.mask=0xffffffff|0;}},{key:"toggle",value:function toggle(channel){this.mask^=1<<channel|0;}},{key:"disable",value:function disable(channel){this.mask&=~(1<<channel|0);}},{key:"disableAll",value:function disableAll(){this.mask=0;}},{key:"test",value:function test(layers){return (this.mask&layers.mask)!==0;}},{key:"isEnabled",value:function isEnabled(channel){return (this.mask&(1<<channel|0))!==0;}}]);return Layers;}();var _object3DId=0;var _v1$4=/*@__PURE__*/new Vector3();var _q1=/*@__PURE__*/new Quaternion();var _m1$1=/*@__PURE__*/new Matrix4();var _target=/*@__PURE__*/new Vector3();var _position$3=/*@__PURE__*/new Vector3();var _scale$2=/*@__PURE__*/new Vector3();var _quaternion$2=/*@__PURE__*/new Quaternion();var _xAxis=/*@__PURE__*/new Vector3(1,0,0);var _yAxis=/*@__PURE__*/new Vector3(0,1,0);var _zAxis=/*@__PURE__*/new Vector3(0,0,1);var _addedEvent={type:'added'};var _removedEvent={type:'removed'};var Object3D=/*#__PURE__*/function(_EventDispatcher3){_inherits(Object3D,_EventDispatcher3);var _super8=_createSuper(Object3D);function Object3D(){var _this9;_classCallCheck(this,Object3D);_this9=_super8.call(this);_this9.isObject3D=true;Object.defineProperty(_assertThisInitialized(_this9),'id',{value:_object3DId++});_this9.uuid=generateUUID();_this9.name='';_this9.type='Object3D';_this9.parent=null;_this9.children=[];_this9.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);Object.defineProperties(_assertThisInitialized(_this9),{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});_this9.matrix=new Matrix4();_this9.matrixWorld=new Matrix4();_this9.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;_this9.matrixWorldNeedsUpdate=false;_this9.matrixWorldAutoUpdate=Object3D.DefaultMatrixWorldAutoUpdate;// checked by the renderer
  _this9.layers=new Layers();_this9.visible=true;_this9.castShadow=false;_this9.receiveShadow=false;_this9.frustumCulled=true;_this9.renderOrder=0;_this9.animations=[];_this9.userData={};return _this9;}_createClass(Object3D,[{key:"onBeforeRender",value:function/* renderer, scene, camera, geometry, material, group */onBeforeRender(){}},{key:"onAfterRender",value:function/* renderer, scene, camera, geometry, material, group */onAfterRender(){}},{key:"applyMatrix4",value:function applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);}},{key:"applyQuaternion",value:function applyQuaternion(q){this.quaternion.premultiply(q);return this;}},{key:"setRotationFromAxisAngle",value:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
  this.quaternion.setFromAxisAngle(axis,angle);}},{key:"setRotationFromEuler",value:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);}},{key:"setRotationFromMatrix",value:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  this.quaternion.setFromRotationMatrix(m);}},{key:"setRotationFromQuaternion",value:function setRotationFromQuaternion(q){// assumes q is normalized
  this.quaternion.copy(q);}},{key:"rotateOnAxis",value:function rotateOnAxis(axis,angle){// rotate object on axis in object space
  // axis is assumed to be normalized
  _q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this;}},{key:"rotateOnWorldAxis",value:function rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
  // axis is assumed to be normalized
  // method assumes no rotated parent
  _q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this;}},{key:"rotateX",value:function rotateX(angle){return this.rotateOnAxis(_xAxis,angle);}},{key:"rotateY",value:function rotateY(angle){return this.rotateOnAxis(_yAxis,angle);}},{key:"rotateZ",value:function rotateZ(angle){return this.rotateOnAxis(_zAxis,angle);}},{key:"translateOnAxis",value:function translateOnAxis(axis,distance){// translate object by distance along axis in object space
  // axis is assumed to be normalized
  _v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this;}},{key:"translateX",value:function translateX(distance){return this.translateOnAxis(_xAxis,distance);}},{key:"translateY",value:function translateY(distance){return this.translateOnAxis(_yAxis,distance);}},{key:"translateZ",value:function translateZ(distance){return this.translateOnAxis(_zAxis,distance);}},{key:"localToWorld",value:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);}},{key:"worldToLocal",value:function worldToLocal(vector){return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());}},{key:"lookAt",value:function lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
  if(x.isVector3){_target.copy(x);}else {_target.set(x,y,z);}var parent=this.parent;this.updateWorldMatrix(true,false);_position$3.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1.lookAt(_position$3,_target,this.up);}else {_m1$1.lookAt(_target,_position$3,this.up);}this.quaternion.setFromRotationMatrix(_m1$1);if(parent){_m1$1.extractRotation(parent.matrixWorld);_q1.setFromRotationMatrix(_m1$1);this.quaternion.premultiply(_q1.invert());}}},{key:"add",value:function add(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error('THREE.Object3D.add: object can\'t be added as a child of itself.',object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent);}else {console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.',object);}return this;}},{key:"remove",value:function remove(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent);}return this;}},{key:"removeFromParent",value:function removeFromParent(){var parent=this.parent;if(parent!==null){parent.remove(this);}return this;}},{key:"clear",value:function clear(){for(var i=0;i<this.children.length;i++){var object=this.children[i];object.parent=null;object.dispatchEvent(_removedEvent);}this.children.length=0;return this;}},{key:"attach",value:function attach(object){// adds object as a child of this, while maintaining the object's world transform
  // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
  this.updateWorldMatrix(true,false);_m1$1.copy(this.matrixWorld).invert();if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1);this.add(object);object.updateWorldMatrix(false,true);return this;}},{key:"getObjectById",value:function getObjectById(id){return this.getObjectByProperty('id',id);}},{key:"getObjectByName",value:function getObjectByName(name){return this.getObjectByProperty('name',name);}},{key:"getObjectByProperty",value:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;}},{key:"getWorldPosition",value:function getWorldPosition(target){this.updateWorldMatrix(true,false);return target.setFromMatrixPosition(this.matrixWorld);}},{key:"getWorldQuaternion",value:function getWorldQuaternion(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,target,_scale$2);return target;}},{key:"getWorldScale",value:function getWorldScale(target){this.updateWorldMatrix(true,false);this.matrixWorld.decompose(_position$3,_quaternion$2,target);return target;}},{key:"getWorldDirection",value:function getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();}},{key:"raycast",value:function/* raycaster, intersects */raycast(){}},{key:"traverse",value:function traverse(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}}},{key:"traverseVisible",value:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}}},{key:"traverseAncestors",value:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}}},{key:"updateMatrix",value:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;}},{key:"updateMatrixWorld",value:function updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
  var children=this.children;for(var i=0,l=children.length;i<l;i++){var child=children[i];if(child.matrixWorldAutoUpdate===true||force===true){child.updateMatrixWorld(force);}}}},{key:"updateWorldMatrix",value:function updateWorldMatrix(updateParents,updateChildren){var parent=this.parent;if(updateParents===true&&parent!==null&&parent.matrixWorldAutoUpdate===true){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.parent===null){this.matrixWorld.copy(this.matrix);}else {this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}// update children
  if(updateChildren===true){var children=this.children;for(var i=0,l=children.length;i<l;i++){var child=children[i];if(child.matrixWorldAutoUpdate===true){child.updateWorldMatrix(false,true);}}}}},{key:"toJSON",value:function toJSON(meta){// meta is a string when called from JSON.stringify
  var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
  // not providing it implies that this is the root object
  // being serialized.
  if(isRootObject){// initialize meta obj
  meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
  var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
  if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();if(this.instanceColor!==null)object.instanceColor=this.instanceColor.toJSON();}//
  function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isScene){if(this.background){if(this.background.isColor){object.background=this.background.toJSON();}else if(this.background.isTexture){object.background=this.background.toJSON(meta).uuid;}}if(this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==true){object.environment=this.environment.toJSON(meta).uuid;}}else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){var shapes=parameters.shapes;if(Array.isArray(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];serialize(meta.shapes,shape);}}else {serialize(meta.shapes,shapes);}}}if(this.isSkinnedMesh){object.bindMode=this.bindMode;object.bindMatrix=this.bindMatrix.toArray();if(this.skeleton!==undefined){serialize(meta.skeletons,this.skeleton);object.skeleton=this.skeleton.uuid;}}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var _i3=0,_l2=this.material.length;_i3<_l2;_i3++){uuids.push(serialize(meta.materials,this.material[_i3]));}object.material=uuids;}else {object.material=serialize(meta.materials,this.material);}}//
  if(this.children.length>0){object.children=[];for(var _i4=0;_i4<this.children.length;_i4++){object.children.push(this.children[_i4].toJSON(meta).object);}}//
  if(this.animations.length>0){object.animations=[];for(var _i5=0;_i5<this.animations.length;_i5++){var animation=this.animations[_i5];object.animations.push(serialize(meta.animations,animation));}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);var _shapes=extractFromCache(meta.shapes);var skeletons=extractFromCache(meta.skeletons);var animations=extractFromCache(meta.animations);var nodes=extractFromCache(meta.nodes);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(_shapes.length>0)output.shapes=_shapes;if(skeletons.length>0)output.skeletons=skeletons;if(animations.length>0)output.animations=animations;if(nodes.length>0)output.nodes=nodes;}output.object=object;return output;// extract data from the cache hash
  // remove metadata on each item
  // and return as array
  function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}}},{key:"clone",value:function clone(recursive){return new this.constructor().copy(this,recursive);}},{key:"copy",value:function copy(source){var recursive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}}]);return Object3D;}(EventDispatcher);Object3D.DefaultUp=/*@__PURE__*/new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.DefaultMatrixWorldAutoUpdate=true;var _v0$1=/*@__PURE__*/new Vector3();var _v1$3=/*@__PURE__*/new Vector3();var _v2$2=/*@__PURE__*/new Vector3();var _v3$1=/*@__PURE__*/new Vector3();var _vab=/*@__PURE__*/new Vector3();var _vac=/*@__PURE__*/new Vector3();var _vbc=/*@__PURE__*/new Vector3();var _vap=/*@__PURE__*/new Vector3();var _vbp=/*@__PURE__*/new Vector3();var _vcp=/*@__PURE__*/new Vector3();var Triangle=/*#__PURE__*/function(){function Triangle(){var a=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3();var b=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var c=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Vector3();_classCallCheck(this,Triangle);this.a=a;this.b=b;this.c=c;}_createClass(Triangle,[{key:"set",value:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;}},{key:"setFromPointsAndIndices",value:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;}},{key:"setFromAttributeAndIndices",value:function setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;}},{key:"getArea",value:function getArea(){_v0$1.subVectors(this.c,this.b);_v1$3.subVectors(this.a,this.b);return _v0$1.cross(_v1$3).length()*0.5;}},{key:"getMidpoint",value:function getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);}},{key:"getNormal",value:function getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);}},{key:"getPlane",value:function getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c);}},{key:"getBarycoord",value:function getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);}},{key:"getUV",value:function getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);}},{key:"containsPoint",value:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);}},{key:"isFrontFacing",value:function isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsTriangle(this);}},{key:"closestPointToPoint",value:function closestPointToPoint(p,target){var a=this.a,b=this.b,c=this.c;var v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  // under the accompanying license; see chapter 5.1.5 for detailed explanation.
  // basically, we're distinguishing which of the voronoi regions of the triangle
  // the point lies in with the minimum amount of redundant computation.
  _vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap);var d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
  return target.copy(a);}_vbp.subVectors(p,b);var d3=_vab.dot(_vbp);var d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
  return target.copy(b);}var vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
  return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);var d5=_vab.dot(_vcp);var d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
  return target.copy(c);}var vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
  return target.copy(a).addScaledVector(_vac,w);}var va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
  return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
  }// face region
  var denom=1/(va+vb+vc);// u = va * denom
  v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);}},{key:"equals",value:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}}],[{key:"getNormal",value:function getNormal(a,b,c,target){target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);var targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);}// static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  },{key:"getBarycoord",value:function getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$2.subVectors(point,a);var dot00=_v0$1.dot(_v0$1);var dot01=_v0$1.dot(_v1$3);var dot02=_v0$1.dot(_v2$2);var dot11=_v1$3.dot(_v1$3);var dot12=_v1$3.dot(_v2$2);var denom=dot00*dot11-dot01*dot01;// collinear or singular triangle
  if(denom===0){// arbitrary location outside of triangle?
  // not sure if this is the best idea, maybe should be returning undefined
  return target.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
  return target.set(1-u-v,v,u);}},{key:"containsPoint",value:function containsPoint(point,a,b,c){this.getBarycoord(point,a,b,c,_v3$1);return _v3$1.x>=0&&_v3$1.y>=0&&_v3$1.x+_v3$1.y<=1;}},{key:"getUV",value:function getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3$1);target.set(0,0);target.addScaledVector(uv1,_v3$1.x);target.addScaledVector(uv2,_v3$1.y);target.addScaledVector(uv3,_v3$1.z);return target;}},{key:"isFrontFacing",value:function isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);// strictly front facing
  return _v0$1.cross(_v1$3).dot(direction)<0?true:false;}}]);return Triangle;}();var materialId=0;var Material=/*#__PURE__*/function(_EventDispatcher4){_inherits(Material,_EventDispatcher4);var _super9=_createSuper(Material);function Material(){var _this10;_classCallCheck(this,Material);_this10=_super9.call(this);_this10.isMaterial=true;Object.defineProperty(_assertThisInitialized(_this10),'id',{value:materialId++});_this10.uuid=generateUUID();_this10.name='';_this10.type='Material';_this10.blending=NormalBlending;_this10.side=FrontSide;_this10.vertexColors=false;_this10.opacity=1;_this10.transparent=false;_this10.blendSrc=SrcAlphaFactor;_this10.blendDst=OneMinusSrcAlphaFactor;_this10.blendEquation=AddEquation;_this10.blendSrcAlpha=null;_this10.blendDstAlpha=null;_this10.blendEquationAlpha=null;_this10.depthFunc=LessEqualDepth;_this10.depthTest=true;_this10.depthWrite=true;_this10.stencilWriteMask=0xff;_this10.stencilFunc=AlwaysStencilFunc;_this10.stencilRef=0;_this10.stencilFuncMask=0xff;_this10.stencilFail=KeepStencilOp;_this10.stencilZFail=KeepStencilOp;_this10.stencilZPass=KeepStencilOp;_this10.stencilWrite=false;_this10.clippingPlanes=null;_this10.clipIntersection=false;_this10.clipShadows=false;_this10.shadowSide=null;_this10.colorWrite=true;_this10.precision=null;// override the renderer's default precision for this material
  _this10.polygonOffset=false;_this10.polygonOffsetFactor=0;_this10.polygonOffsetUnits=0;_this10.dithering=false;_this10.alphaToCoverage=false;_this10.premultipliedAlpha=false;_this10.visible=true;_this10.toneMapped=true;_this10.userData={};_this10.version=0;_this10._alphaTest=0;return _this10;}_createClass(Material,[{key:"alphaTest",get:function get(){return this._alphaTest;},set:function set(value){if(this._alphaTest>0!==value>0){this.version++;}this._alphaTest=value;}},{key:"onBuild",value:function/* shaderobject, renderer */onBuild(){}},{key:"onBeforeRender",value:function/* renderer, scene, camera, geometry, object, group */onBeforeRender(){}},{key:"onBeforeCompile",value:function/* shaderobject, renderer */onBeforeCompile(){}},{key:"customProgramCacheKey",value:function customProgramCacheKey(){return this.onBeforeCompile.toString();}},{key:"setValues",value:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn('THREE.Material: \''+key+'\' parameter is undefined.');continue;}var currentValue=this[key];if(currentValue===undefined){console.warn('THREE.'+this.type+': \''+key+'\' is not a property of this material.');continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else {this[key]=newValue;}}}},{key:"toJSON",value:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(isRootObject){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen!==undefined)data.sheen=this.sheen;if(this.sheenColor&&this.sheenColor.isColor)data.sheenColor=this.sheenColor.getHex();if(this.sheenRoughness!==undefined)data.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.specularIntensity!==undefined)data.specularIntensity=this.specularIntensity;if(this.specularColor&&this.specularColor.isColor)data.specularColor=this.specularColor.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.iridescence!==undefined)data.iridescence=this.iridescence;if(this.iridescenceIOR!==undefined)data.iridescenceIOR=this.iridescenceIOR;if(this.iridescenceThicknessRange!==undefined)data.iridescenceThicknessRange=this.iridescenceThicknessRange;if(this.iridescenceMap&&this.iridescenceMap.isTexture){data.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid;}if(this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture){data.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid;}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture){data.lightMap=this.lightMap.toJSON(meta).uuid;data.lightMapIntensity=this.lightMapIntensity;}if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid;if(this.specularColorMap&&this.specularColorMap.isTexture)data.specularColorMap=this.specularColorMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;if(this.combine!==undefined)data.combine=this.combine;}if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==undefined)data.reflectivity=this.reflectivity;if(this.refractionRatio!==undefined)data.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.transmission!==undefined)data.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)data.transmissionMap=this.transmissionMap.toJSON(meta).uuid;if(this.thickness!==undefined)data.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)data.thicknessMap=this.thicknessMap.toJSON(meta).uuid;if(this.attenuationDistance!==undefined)data.attenuationDistance=this.attenuationDistance;if(this.attenuationColor!==undefined)data.attenuationColor=this.attenuationColor.getHex();if(this.size!==undefined)data.size=this.size;if(this.shadowSide!==null)data.shadowSide=this.shadowSide;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;data.colorWrite=this.colorWrite;data.stencilWrite=this.stencilWrite;data.stencilWriteMask=this.stencilWriteMask;data.stencilFunc=this.stencilFunc;data.stencilRef=this.stencilRef;data.stencilFuncMask=this.stencilFuncMask;data.stencilFail=this.stencilFail;data.stencilZFail=this.stencilZFail;data.stencilZPass=this.stencilZPass;// rotation (SpriteMaterial)
  if(this.rotation!==undefined&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth!==undefined&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.alphaToCoverage===true)data.alphaToCoverage=this.alphaToCoverage;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if(this.fog===false)data.fog=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
  function extractFromCache(cache){var values=[];for(var key in cache){var _data2=cache[key];delete _data2.metadata;values.push(_data2);}return values;}if(isRootObject){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){this.name=source.name;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;var srcPlanes=source.clippingPlanes;var dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}}]);return Material;}(EventDispatcher);var MeshBasicMaterial=/*#__PURE__*/function(_Material){_inherits(MeshBasicMaterial,_Material);var _super10=_createSuper(MeshBasicMaterial);function MeshBasicMaterial(parameters){var _this11;_classCallCheck(this,MeshBasicMaterial);_this11=_super10.call(this);_this11.isMeshBasicMaterial=true;_this11.type='MeshBasicMaterial';_this11.color=new Color$1(0xffffff);// emissive
  _this11.map=null;_this11.lightMap=null;_this11.lightMapIntensity=1.0;_this11.aoMap=null;_this11.aoMapIntensity=1.0;_this11.specularMap=null;_this11.alphaMap=null;_this11.envMap=null;_this11.combine=MultiplyOperation;_this11.reflectivity=1;_this11.refractionRatio=0.98;_this11.wireframe=false;_this11.wireframeLinewidth=1;_this11.wireframeLinecap='round';_this11.wireframeLinejoin='round';_this11.fog=true;_this11.setValues(parameters);return _this11;}_createClass(MeshBasicMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshBasicMaterial.prototype),"copy",this).call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.fog=source.fog;return this;}}]);return MeshBasicMaterial;}(Material);var _vector$9=/*@__PURE__*/new Vector3();var _vector2$1=/*@__PURE__*/new Vector2();var BufferAttribute=/*#__PURE__*/function(){function BufferAttribute(array,itemSize,normalized){_classCallCheck(this,BufferAttribute);if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.isBufferAttribute=true;this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}_createClass(BufferAttribute,[{key:"onUploadCallback",value:function onUploadCallback(){}},{key:"needsUpdate",set:function set(value){if(value===true)this.version++;}},{key:"setUsage",value:function setUsage(value){this.usage=value;return this;}},{key:"copy",value:function copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this;}},{key:"copyAt",value:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;}},{key:"copyArray",value:function copyArray(array){this.array.set(array);return this;}},{key:"applyMatrix3",value:function applyMatrix3(m){if(this.itemSize===2){for(var i=0,l=this.count;i<l;i++){_vector2$1.fromBufferAttribute(this,i);_vector2$1.applyMatrix3(m);this.setXY(i,_vector2$1.x,_vector2$1.y);}}else if(this.itemSize===3){for(var _i6=0,_l3=this.count;_i6<_l3;_i6++){_vector$9.fromBufferAttribute(this,_i6);_vector$9.applyMatrix3(m);this.setXYZ(_i6,_vector$9.x,_vector$9.y,_vector$9.z);}}return this;}},{key:"applyMatrix4",value:function applyMatrix4(m){for(var i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyMatrix4(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"applyNormalMatrix",value:function applyNormalMatrix(m){for(var i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.applyNormalMatrix(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"transformDirection",value:function transformDirection(m){for(var i=0,l=this.count;i<l;i++){_vector$9.fromBufferAttribute(this,i);_vector$9.transformDirection(m);this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);}return this;}},{key:"set",value:function set(value){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// Matching BufferAttribute constructor, do not normalize the array.
  this.array.set(value,offset);return this;}},{key:"getX",value:function getX(index){var x=this.array[index*this.itemSize];if(this.normalized)x=denormalize(x,this.array);return x;}},{key:"setX",value:function setX(index,x){if(this.normalized)x=normalize(x,this.array);this.array[index*this.itemSize]=x;return this;}},{key:"getY",value:function getY(index){var y=this.array[index*this.itemSize+1];if(this.normalized)y=denormalize(y,this.array);return y;}},{key:"setY",value:function setY(index,y){if(this.normalized)y=normalize(y,this.array);this.array[index*this.itemSize+1]=y;return this;}},{key:"getZ",value:function getZ(index){var z=this.array[index*this.itemSize+2];if(this.normalized)z=denormalize(z,this.array);return z;}},{key:"setZ",value:function setZ(index,z){if(this.normalized)z=normalize(z,this.array);this.array[index*this.itemSize+2]=z;return this;}},{key:"getW",value:function getW(index){var w=this.array[index*this.itemSize+3];if(this.normalized)w=denormalize(w,this.array);return w;}},{key:"setW",value:function setW(index,w){if(this.normalized)w=normalize(w,this.array);this.array[index*this.itemSize+3]=w;return this;}},{key:"setXY",value:function setXY(index,x,y){index*=this.itemSize;if(this.normalized){x=normalize(x,this.array);y=normalize(y,this.array);}this.array[index+0]=x;this.array[index+1]=y;return this;}},{key:"setXYZ",value:function setXYZ(index,x,y,z){index*=this.itemSize;if(this.normalized){x=normalize(x,this.array);y=normalize(y,this.array);z=normalize(z,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;}},{key:"setXYZW",value:function setXYZW(index,x,y,z,w){index*=this.itemSize;if(this.normalized){x=normalize(x,this.array);y=normalize(y,this.array);z=normalize(z,this.array);w=normalize(w,this.array);}this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;}},{key:"onUpload",value:function onUpload(callback){this.onUploadCallback=callback;return this;}},{key:"clone",value:function clone(){return new this.constructor(this.array,this.itemSize).copy(this);}},{key:"toJSON",value:function toJSON(){var data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};if(this.name!=='')data.name=this.name;if(this.usage!==StaticDrawUsage)data.usage=this.usage;if(this.updateRange.offset!==0||this.updateRange.count!==-1)data.updateRange=this.updateRange;return data;}// @deprecated
  },{key:"copyColorsArray",value:function copyColorsArray(){console.error('THREE.BufferAttribute: copyColorsArray() was removed in r144.');}},{key:"copyVector2sArray",value:function copyVector2sArray(){console.error('THREE.BufferAttribute: copyVector2sArray() was removed in r144.');}},{key:"copyVector3sArray",value:function copyVector3sArray(){console.error('THREE.BufferAttribute: copyVector3sArray() was removed in r144.');}},{key:"copyVector4sArray",value:function copyVector4sArray(){console.error('THREE.BufferAttribute: copyVector4sArray() was removed in r144.');}}]);return BufferAttribute;}();//
  var Uint16BufferAttribute=/*#__PURE__*/function(_BufferAttribute5){_inherits(Uint16BufferAttribute,_BufferAttribute5);var _super15=_createSuper(Uint16BufferAttribute);function Uint16BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Uint16BufferAttribute);return _super15.call(this,new Uint16Array(array),itemSize,normalized);}return _createClass(Uint16BufferAttribute);}(BufferAttribute);var Uint32BufferAttribute=/*#__PURE__*/function(_BufferAttribute7){_inherits(Uint32BufferAttribute,_BufferAttribute7);var _super17=_createSuper(Uint32BufferAttribute);function Uint32BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Uint32BufferAttribute);return _super17.call(this,new Uint32Array(array),itemSize,normalized);}return _createClass(Uint32BufferAttribute);}(BufferAttribute);var Float32BufferAttribute=/*#__PURE__*/function(_BufferAttribute9){_inherits(Float32BufferAttribute,_BufferAttribute9);var _super19=_createSuper(Float32BufferAttribute);function Float32BufferAttribute(array,itemSize,normalized){_classCallCheck(this,Float32BufferAttribute);return _super19.call(this,new Float32Array(array),itemSize,normalized);}return _createClass(Float32BufferAttribute);}(BufferAttribute);var _id$1=0;var _m1=/*@__PURE__*/new Matrix4();var _obj=/*@__PURE__*/new Object3D();var _offset=/*@__PURE__*/new Vector3();var _box$1=/*@__PURE__*/new Box3();var _boxMorphTargets=/*@__PURE__*/new Box3();var _vector$8=/*@__PURE__*/new Vector3();var BufferGeometry=/*#__PURE__*/function(_EventDispatcher5){_inherits(BufferGeometry,_EventDispatcher5);var _super21=_createSuper(BufferGeometry);function BufferGeometry(){var _this13;_classCallCheck(this,BufferGeometry);_this13=_super21.call(this);_this13.isBufferGeometry=true;Object.defineProperty(_assertThisInitialized(_this13),'id',{value:_id$1++});_this13.uuid=generateUUID();_this13.name='';_this13.type='BufferGeometry';_this13.index=null;_this13.attributes={};_this13.morphAttributes={};_this13.morphTargetsRelative=false;_this13.groups=[];_this13.boundingBox=null;_this13.boundingSphere=null;_this13.drawRange={start:0,count:Infinity};_this13.userData={};return _this13;}_createClass(BufferGeometry,[{key:"getIndex",value:function getIndex(){return this.index;}},{key:"setIndex",value:function setIndex(index){if(Array.isArray(index)){this.index=new(arrayNeedsUint32(index)?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else {this.index=index;}return this;}},{key:"getAttribute",value:function getAttribute(name){return this.attributes[name];}},{key:"setAttribute",value:function setAttribute(name,attribute){this.attributes[name]=attribute;return this;}},{key:"deleteAttribute",value:function deleteAttribute(name){delete this.attributes[name];return this;}},{key:"hasAttribute",value:function hasAttribute(name){return this.attributes[name]!==undefined;}},{key:"addGroup",value:function addGroup(start,count){var materialIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;this.groups.push({start:start,count:count,materialIndex:materialIndex});}},{key:"clearGroups",value:function clearGroups(){this.groups=[];}},{key:"setDrawRange",value:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;}},{key:"applyMatrix4",value:function applyMatrix4(matrix){var position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}var tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;}},{key:"applyQuaternion",value:function applyQuaternion(q){_m1.makeRotationFromQuaternion(q);this.applyMatrix4(_m1);return this;}},{key:"rotateX",value:function rotateX(angle){// rotate geometry around world x-axis
  _m1.makeRotationX(angle);this.applyMatrix4(_m1);return this;}},{key:"rotateY",value:function rotateY(angle){// rotate geometry around world y-axis
  _m1.makeRotationY(angle);this.applyMatrix4(_m1);return this;}},{key:"rotateZ",value:function rotateZ(angle){// rotate geometry around world z-axis
  _m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this;}},{key:"translate",value:function translate(x,y,z){// translate geometry
  _m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this;}},{key:"scale",value:function scale(x,y,z){// scale geometry
  _m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this;}},{key:"lookAt",value:function lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this;}},{key:"center",value:function center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this;}},{key:"setFromPoints",value:function setFromPoints(points){var position=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute(position,3));return this;}},{key:"computeBoundingBox",value:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(+Infinity,+Infinity,+Infinity));return;}if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var i=0,il=morphAttributesPosition.length;i<il;i++){var morphAttribute=morphAttributesPosition[i];_box$1.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(this.boundingBox.min,_box$1.min);this.boundingBox.expandByPoint(_vector$8);_vector$8.addVectors(this.boundingBox.max,_box$1.max);this.boundingBox.expandByPoint(_vector$8);}else {this.boundingBox.expandByPoint(_box$1.min);this.boundingBox.expandByPoint(_box$1.max);}}}}else {this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}}},{key:"computeBoundingSphere",value:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this);this.boundingSphere.set(new Vector3(),Infinity);return;}if(position){// first, find the center of the bounding sphere
  var center=this.boundingSphere.center;_box$1.setFromBufferAttribute(position);// process morph attributes if present
  if(morphAttributesPosition){for(var i=0,il=morphAttributesPosition.length;i<il;i++){var morphAttribute=morphAttributesPosition[i];_boxMorphTargets.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$8.addVectors(_box$1.min,_boxMorphTargets.min);_box$1.expandByPoint(_vector$8);_vector$8.addVectors(_box$1.max,_boxMorphTargets.max);_box$1.expandByPoint(_vector$8);}else {_box$1.expandByPoint(_boxMorphTargets.min);_box$1.expandByPoint(_boxMorphTargets.max);}}}_box$1.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
  // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
  var maxRadiusSq=0;for(var _i7=0,_il=position.count;_i7<_il;_i7++){_vector$8.fromBufferAttribute(position,_i7);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}// process morph attributes if present
  if(morphAttributesPosition){for(var _i8=0,_il2=morphAttributesPosition.length;_i8<_il2;_i8++){var _morphAttribute=morphAttributesPosition[_i8];var morphTargetsRelative=this.morphTargetsRelative;for(var j=0,jl=_morphAttribute.count;j<jl;j++){_vector$8.fromBufferAttribute(_morphAttribute,j);if(morphTargetsRelative){_offset.fromBufferAttribute(position,j);_vector$8.add(_offset);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}}},{key:"computeTangents",value:function computeTangents(){var index=this.index;var attributes=this.attributes;// based on http://www.terathon.com/code/tangent.html
  // (per vertex tangents)
  if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');return;}var indices=index.array;var positions=attributes.position.array;var normals=attributes.normal.array;var uvs=attributes.uv.array;var nVertices=positions.length/3;if(this.hasAttribute('tangent')===false){this.setAttribute('tangent',new BufferAttribute(new Float32Array(4*nVertices),4));}var tangents=this.getAttribute('tangent').array;var tan1=[],tan2=[];for(var i=0;i<nVertices;i++){tan1[i]=new Vector3();tan2[i]=new Vector3();}var vA=new Vector3(),vB=new Vector3(),vC=new Vector3(),uvA=new Vector2(),uvB=new Vector2(),uvC=new Vector2(),sdir=new Vector3(),tdir=new Vector3();function handleTriangle(a,b,c){vA.fromArray(positions,a*3);vB.fromArray(positions,b*3);vC.fromArray(positions,c*3);uvA.fromArray(uvs,a*2);uvB.fromArray(uvs,b*2);uvC.fromArray(uvs,c*2);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);var r=1.0/(uvB.x*uvC.y-uvC.x*uvB.y);// silently ignore degenerate uv triangles having coincident or colinear vertices
  if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir);}var groups=this.groups;if(groups.length===0){groups=[{start:0,count:indices.length}];}for(var _i9=0,il=groups.length;_i9<il;++_i9){var group=groups[_i9];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){handleTriangle(indices[j+0],indices[j+1],indices[j+2]);}}var tmp=new Vector3(),tmp2=new Vector3();var n=new Vector3(),n2=new Vector3();function handleVertex(v){n.fromArray(normals,v*3);n2.copy(n);var t=tan1[v];// Gram-Schmidt orthogonalize
  tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();// Calculate handedness
  tmp2.crossVectors(n2,t);var test=tmp2.dot(tan2[v]);var w=test<0.0?-1.0:1.0;tangents[v*4]=tmp.x;tangents[v*4+1]=tmp.y;tangents[v*4+2]=tmp.z;tangents[v*4+3]=w;}for(var _i10=0,_il3=groups.length;_i10<_il3;++_i10){var _group=groups[_i10];var _start2=_group.start;var _count=_group.count;for(var _j=_start2,_jl=_start2+_count;_j<_jl;_j+=3){handleVertex(indices[_j+0]);handleVertex(indices[_j+1]);handleVertex(indices[_j+2]);}}}},{key:"computeVertexNormals",value:function computeVertexNormals(){var index=this.index;var positionAttribute=this.getAttribute('position');if(positionAttribute!==undefined){var normalAttribute=this.getAttribute('normal');if(normalAttribute===undefined){normalAttribute=new BufferAttribute(new Float32Array(positionAttribute.count*3),3);this.setAttribute('normal',normalAttribute);}else {// reset existing normals to zero
  for(var i=0,il=normalAttribute.count;i<il;i++){normalAttribute.setXYZ(i,0,0,0);}}var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var nA=new Vector3(),nB=new Vector3(),nC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
  if(index){for(var _i11=0,_il4=index.count;_i11<_il4;_i11+=3){var vA=index.getX(_i11+0);var vB=index.getX(_i11+1);var vC=index.getX(_i11+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z);}}else {// non-indexed elements (unconnected triangle soup)
  for(var _i12=0,_il5=positionAttribute.count;_i12<_il5;_i12+=3){pA.fromBufferAttribute(positionAttribute,_i12+0);pB.fromBufferAttribute(positionAttribute,_i12+1);pC.fromBufferAttribute(positionAttribute,_i12+2);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normalAttribute.setXYZ(_i12+0,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i12+1,cb.x,cb.y,cb.z);normalAttribute.setXYZ(_i12+2,cb.x,cb.y,cb.z);}}this.normalizeNormals();normalAttribute.needsUpdate=true;}}// @deprecated since r144
  },{key:"merge",value:function merge(){console.error('THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.');return this;}},{key:"normalizeNormals",value:function normalizeNormals(){var normals=this.attributes.normal;for(var i=0,il=normals.count;i<il;i++){_vector$8.fromBufferAttribute(normals,i);_vector$8.normalize();normals.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);}}},{key:"toNonIndexed",value:function toNonIndexed(){function convertBufferAttribute(attribute,indices){var array=attribute.array;var itemSize=attribute.itemSize;var normalized=attribute.normalized;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){if(attribute.isInterleavedBufferAttribute){index=indices[i]*attribute.data.stride+attribute.offset;}else {index=indices[i]*itemSize;}for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute(array2,itemSize,normalized);}//
  if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;// attributes
  for(var name in attributes){var attribute=attributes[name];var newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
  var morphAttributes=this.morphAttributes;for(var _name in morphAttributes){var morphArray=[];var morphAttribute=morphAttributes[_name];// morphAttribute: array of Float32BufferAttributes
  for(var i=0,il=morphAttribute.length;i<il;i++){var _attribute=morphAttribute[i];var _newAttribute=convertBufferAttribute(_attribute,indices);morphArray.push(_newAttribute);}geometry2.morphAttributes[_name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
  var groups=this.groups;for(var _i13=0,l=groups.length;_i13<l;_i13++){var group=groups[_i13];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;}},{key:"toJSON",value:function toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(Object.keys(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}// for simplicity the code assumes attributes are not shared across geometries, see #15811
  data.data={attributes:{}};var index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}var attributes=this.attributes;for(var _key in attributes){var attribute=attributes[_key];data.data.attributes[_key]=attribute.toJSON(data.data);}var morphAttributes={};var hasMorphAttributes=false;for(var _key2 in this.morphAttributes){var attributeArray=this.morphAttributes[_key2];var array=[];for(var i=0,il=attributeArray.length;i<il;i++){var _attribute2=attributeArray[i];array.push(_attribute2.toJSON(data.data));}if(array.length>0){morphAttributes[_key2]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"copy",value:function copy(source){// reset
  this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// used for storing cloned, shared data
  var data={};// name
  this.name=source.name;// index
  var index=source.index;if(index!==null){this.setIndex(index.clone(data));}// attributes
  var attributes=source.attributes;for(var name in attributes){var attribute=attributes[name];this.setAttribute(name,attribute.clone(data));}// morph attributes
  var morphAttributes=source.morphAttributes;for(var _name2 in morphAttributes){var array=[];var morphAttribute=morphAttributes[_name2];// morphAttribute: array of Float32BufferAttributes
  for(var i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone(data));}this.morphAttributes[_name2]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
  var groups=source.groups;for(var _i14=0,_l4=groups.length;_i14<_l4;_i14++){var group=groups[_i14];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
  var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
  var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
  this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
  this.userData=source.userData;// geometry generator parameters
  if(source.parameters!==undefined)this.parameters=Object.assign({},source.parameters);return this;}},{key:"dispose",value:function dispose(){this.dispatchEvent({type:'dispose'});}}]);return BufferGeometry;}(EventDispatcher);var _inverseMatrix$2=/*@__PURE__*/new Matrix4();var _ray$2=/*@__PURE__*/new Ray();var _sphere$3=/*@__PURE__*/new Sphere();var _vA$1=/*@__PURE__*/new Vector3();var _vB$1=/*@__PURE__*/new Vector3();var _vC$1=/*@__PURE__*/new Vector3();var _tempA=/*@__PURE__*/new Vector3();var _tempB=/*@__PURE__*/new Vector3();var _tempC=/*@__PURE__*/new Vector3();var _morphA=/*@__PURE__*/new Vector3();var _morphB=/*@__PURE__*/new Vector3();var _morphC=/*@__PURE__*/new Vector3();var _uvA$1=/*@__PURE__*/new Vector2();var _uvB$1=/*@__PURE__*/new Vector2();var _uvC$1=/*@__PURE__*/new Vector2();var _intersectionPoint=/*@__PURE__*/new Vector3();var _intersectionPointWorld=/*@__PURE__*/new Vector3();var Mesh=/*#__PURE__*/function(_Object3D){_inherits(Mesh,_Object3D);var _super22=_createSuper(Mesh);function Mesh(){var _this14;var geometry=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new BufferGeometry();var material=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new MeshBasicMaterial();_classCallCheck(this,Mesh);_this14=_super22.call(this);_this14.isMesh=true;_this14.type='Mesh';_this14.geometry=geometry;_this14.material=material;_this14.updateMorphTargets();return _this14;}_createClass(Mesh,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Mesh.prototype),"copy",this).call(this,source,recursive);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}this.material=source.material;this.geometry=source.geometry;return this;}},{key:"updateMorphTargets",value:function updateMorphTargets(){var geometry=this.geometry;var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphAttribute.length;m<ml;m++){var name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}},{key:"raycast",value:function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere);_sphere$3.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(_sphere$3)===false)return;//
  _inverseMatrix$2.copy(matrixWorld).invert();_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);// Check boundingBox before continuing
  if(geometry.boundingBox!==null){if(_ray$2.intersectsBox(geometry.boundingBox)===false)return;}var intersection;var index=geometry.index;var position=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position;var morphTargetsRelative=geometry.morphTargetsRelative;var uv=geometry.attributes.uv;var uv2=geometry.attributes.uv2;var groups=geometry.groups;var drawRange=geometry.drawRange;if(index!==null){// indexed buffer geometry
  if(Array.isArray(material)){for(var i=0,il=groups.length;i<il;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];var start=Math.max(group.start,drawRange.start);var end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(var j=start,jl=end;j<jl;j+=3){var a=index.getX(j);var b=index.getX(j+1);var c=index.getX(j+2);intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
  intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else {var _start3=Math.max(0,drawRange.start);var _end2=Math.min(index.count,drawRange.start+drawRange.count);for(var _i15=_start3,_il6=_end2;_i15<_il6;_i15+=3){var _a=index.getX(_i15);var _b=index.getX(_i15+1);var _c=index.getX(_i15+2);intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a,_b,_c);if(intersection){intersection.faceIndex=Math.floor(_i15/3);// triangle number in indexed buffer semantics
  intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
  if(Array.isArray(material)){for(var _i16=0,_il7=groups.length;_i16<_il7;_i16++){var _group2=groups[_i16];var _groupMaterial=material[_group2.materialIndex];var _start4=Math.max(_group2.start,drawRange.start);var _end3=Math.min(position.count,Math.min(_group2.start+_group2.count,drawRange.start+drawRange.count));for(var _j2=_start4,_jl2=_end3;_j2<_jl2;_j2+=3){var _a2=_j2;var _b2=_j2+1;var _c2=_j2+2;intersection=checkBufferGeometryIntersection(this,_groupMaterial,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a2,_b2,_c2);if(intersection){intersection.faceIndex=Math.floor(_j2/3);// triangle number in non-indexed buffer semantics
  intersection.face.materialIndex=_group2.materialIndex;intersects.push(intersection);}}}}else {var _start5=Math.max(0,drawRange.start);var _end4=Math.min(position.count,drawRange.start+drawRange.count);for(var _i17=_start5,_il8=_end4;_i17<_il8;_i17+=3){var _a3=_i17;var _b3=_i17+1;var _c3=_i17+2;intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,position,morphPosition,morphTargetsRelative,uv,uv2,_a3,_b3,_c3);if(intersection){intersection.faceIndex=Math.floor(_i17/3);// triangle number in non-indexed buffer semantics
  intersects.push(intersection);}}}}}}]);return Mesh;}(Object3D);function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else {intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA$1.fromBufferAttribute(position,a);_vB$1.fromBufferAttribute(position,b);_vC$1.fromBufferAttribute(position,c);var morphInfluences=object.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(var i=0,il=morphPosition.length;i<il;i++){var influence=morphInfluences[i];var morphAttribute=morphPosition[i];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,a);_tempB.fromBufferAttribute(morphAttribute,b);_tempC.fromBufferAttribute(morphAttribute,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence);}else {_morphA.addScaledVector(_tempA.sub(_vA$1),influence);_morphB.addScaledVector(_tempB.sub(_vB$1),influence);_morphC.addScaledVector(_tempC.sub(_vC$1),influence);}}_vA$1.add(_morphA);_vB$1.add(_morphB);_vC$1.add(_morphC);}if(object.isSkinnedMesh){object.boneTransform(a,_vA$1);object.boneTransform(b,_vB$1);object.boneTransform(c,_vC$1);}var intersection=checkIntersection(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){if(uv){_uvA$1.fromBufferAttribute(uv,a);_uvB$1.fromBufferAttribute(uv,b);_uvC$1.fromBufferAttribute(uv,c);intersection.uv=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}if(uv2){_uvA$1.fromBufferAttribute(uv2,a);_uvB$1.fromBufferAttribute(uv2,b);_uvC$1.fromBufferAttribute(uv2,c);intersection.uv2=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2());}var face={a:a,b:b,c:c,normal:new Vector3(),materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal);intersection.face=face;}return intersection;}var BoxGeometry=/*#__PURE__*/function(_BufferGeometry){_inherits(BoxGeometry,_BufferGeometry);var _super23=_createSuper(BoxGeometry);function BoxGeometry(){var _this15;var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var depth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var widthSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var heightSegments=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;var depthSegments=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;_classCallCheck(this,BoxGeometry);_this15=_super23.call(this);_this15.type='BoxGeometry';_this15.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=_assertThisInitialized(_this15);// segments
  widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
  buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
  buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
  buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
  buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
  buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
  buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
  // build geometry
  _this15.setIndex(indices);_this15.setAttribute('position',new Float32BufferAttribute(vertices,3));_this15.setAttribute('normal',new Float32BufferAttribute(normals,3));_this15.setAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var vector=new Vector3();// generate vertices, normals and uvs
  for(var iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(var ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
  vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
  vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
  vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
  normals.push(vector.x,vector.y,vector.z);// uvs
  uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
  vertexCounter+=1;}}// indices
  // 1. you need three indices to draw a single face
  // 2. a single segment consists of two faces
  // 3. so we need to generate six (2*3) indices per segment
  for(var _iy=0;_iy<gridY;_iy++){for(var _ix=0;_ix<gridX;_ix++){var a=numberOfVertices+_ix+gridX1*_iy;var b=numberOfVertices+_ix+gridX1*(_iy+1);var c=numberOfVertices+(_ix+1)+gridX1*(_iy+1);var d=numberOfVertices+(_ix+1)+gridX1*_iy;// faces
  indices.push(a,b,d);indices.push(b,c,d);// increase counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
  groupStart+=groupCount;// update total number of vertices
  numberOfVertices+=vertexCounter;}return _this15;}_createClass(BoxGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);}}]);return BoxGeometry;}(BufferGeometry);/**
   * Uniform Utilities
   */function cloneUniforms(src){var dst={};for(var u in src){dst[u]={};for(var p in src[u]){var property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)){dst[u][p]=property.clone();}else if(Array.isArray(property)){dst[u][p]=property.slice();}else {dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var _tmp=cloneUniforms(uniforms[u]);for(var p in _tmp){merged[p]=_tmp[p];}}return merged;}function cloneUniformsGroups(src){var dst=[];for(var u=0;u<src.length;u++){dst.push(src[u].clone());}return dst;}// Legacy
  var UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";var ShaderMaterial=/*#__PURE__*/function(_Material2){_inherits(ShaderMaterial,_Material2);var _super24=_createSuper(ShaderMaterial);function ShaderMaterial(parameters){var _this16;_classCallCheck(this,ShaderMaterial);_this16=_super24.call(this);_this16.isShaderMaterial=true;_this16.type='ShaderMaterial';_this16.defines={};_this16.uniforms={};_this16.uniformsGroups=[];_this16.vertexShader=default_vertex;_this16.fragmentShader=default_fragment;_this16.linewidth=1;_this16.wireframe=false;_this16.wireframeLinewidth=1;_this16.fog=false;// set to use scene fog
  _this16.lights=false;// set to use scene lights
  _this16.clipping=false;// set to use user-defined clipping planes
  _this16.extensions={derivatives:false,// set to use derivatives
  fragDepth:false,// set to use fragment depth values
  drawBuffers:false,// set to use draw buffers
  shaderTextureLOD:false// set to use shader texture LOD
  };// When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  _this16.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};_this16.index0AttributeName=undefined;_this16.uniformsNeedUpdate=false;_this16.glslVersion=null;if(parameters!==undefined){_this16.setValues(parameters);}return _this16;}_createClass(ShaderMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(ShaderMaterial.prototype),"copy",this).call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.uniformsGroups=cloneUniformsGroups(source.uniformsGroups);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.fog=source.fog;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(ShaderMaterial.prototype),"toJSON",this).call(this,meta);data.glslVersion=this.glslVersion;data.uniforms={};for(var name in this.uniforms){var uniform=this.uniforms[name];var _value=uniform.value;if(_value&&_value.isTexture){data.uniforms[name]={type:'t',value:_value.toJSON(meta).uuid};}else if(_value&&_value.isColor){data.uniforms[name]={type:'c',value:_value.getHex()};}else if(_value&&_value.isVector2){data.uniforms[name]={type:'v2',value:_value.toArray()};}else if(_value&&_value.isVector3){data.uniforms[name]={type:'v3',value:_value.toArray()};}else if(_value&&_value.isVector4){data.uniforms[name]={type:'v4',value:_value.toArray()};}else if(_value&&_value.isMatrix3){data.uniforms[name]={type:'m3',value:_value.toArray()};}else if(_value&&_value.isMatrix4){data.uniforms[name]={type:'m4',value:_value.toArray()};}else {data.uniforms[name]={value:_value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
  }}if(Object.keys(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;var extensions={};for(var key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if(Object.keys(extensions).length>0)data.extensions=extensions;return data;}}]);return ShaderMaterial;}(Material);var Camera=/*#__PURE__*/function(_Object3D2){_inherits(Camera,_Object3D2);var _super25=_createSuper(Camera);function Camera(){var _this17;_classCallCheck(this,Camera);_this17=_super25.call(this);_this17.isCamera=true;_this17.type='Camera';_this17.matrixWorldInverse=new Matrix4();_this17.projectionMatrix=new Matrix4();_this17.projectionMatrixInverse=new Matrix4();return _this17;}_createClass(Camera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Camera.prototype),"copy",this).call(this,source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this;}},{key:"getWorldDirection",value:function getWorldDirection(target){this.updateWorldMatrix(true,false);var e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize();}},{key:"updateMatrixWorld",value:function updateMatrixWorld(force){_get(_getPrototypeOf(Camera.prototype),"updateMatrixWorld",this).call(this,force);this.matrixWorldInverse.copy(this.matrixWorld).invert();}},{key:"updateWorldMatrix",value:function updateWorldMatrix(updateParents,updateChildren){_get(_getPrototypeOf(Camera.prototype),"updateWorldMatrix",this).call(this,updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert();}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Camera;}(Object3D);var PerspectiveCamera=/*#__PURE__*/function(_Camera){_inherits(PerspectiveCamera,_Camera);var _super26=_createSuper(PerspectiveCamera);function PerspectiveCamera(){var _this18;var fov=arguments.length>0&&arguments[0]!==undefined?arguments[0]:50;var aspect=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:2000;_classCallCheck(this,PerspectiveCamera);_this18=_super26.call(this);_this18.isPerspectiveCamera=true;_this18.type='PerspectiveCamera';_this18.fov=fov;_this18.zoom=1;_this18.near=near;_this18.far=far;_this18.focus=10;_this18.aspect=aspect;_this18.view=null;_this18.filmGauge=35;// width of the film (default in millimeters)
  _this18.filmOffset=0;// horizontal film offset (same unit as gauge)
  _this18.updateProjectionMatrix();return _this18;}_createClass(PerspectiveCamera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(PerspectiveCamera.prototype),"copy",this).call(this,source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;}/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */},{key:"setFocalLength",value:function setFocalLength(focalLength){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();}/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */},{key:"getFocalLength",value:function getFocalLength(){var vExtentSlope=Math.tan(DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;}},{key:"getEffectiveFOV",value:function getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*0.5*this.fov)/this.zoom);}},{key:"getFilmWidth",value:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
  return this.filmGauge*Math.min(this.aspect,1);}},{key:"getFilmHeight",value:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
  return this.filmGauge/Math.max(this.aspect,1);}/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   const w = 1920;
  	 *   const h = 1080;
  	 *   const fullWidth = w * 3;
  	 *   const fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */},{key:"setViewOffset",value:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}},{key:"clearViewOffset",value:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}},{key:"updateProjectionMatrix",value:function updateProjectionMatrix(){var near=this.near;var top=near*Math.tan(DEG2RAD*0.5*this.fov)/this.zoom;var height=2*top;var width=this.aspect*height;var left=-0.5*width;var view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(PerspectiveCamera.prototype),"toJSON",this).call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}}]);return PerspectiveCamera;}(Camera);var fov=90,aspect=1;var CubeCamera=/*#__PURE__*/function(_Object3D3){_inherits(CubeCamera,_Object3D3);var _super27=_createSuper(CubeCamera);function CubeCamera(near,far,renderTarget){var _this19;_classCallCheck(this,CubeCamera);_this19=_super27.call(this);_this19.type='CubeCamera';_this19.renderTarget=renderTarget;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.layers=_this19.layers;cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));_this19.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.layers=_this19.layers;cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));_this19.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.layers=_this19.layers;cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));_this19.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.layers=_this19.layers;cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));_this19.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.layers=_this19.layers;cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));_this19.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.layers=_this19.layers;cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));_this19.add(cameraNZ);return _this19;}_createClass(CubeCamera,[{key:"update",value:function update(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var _this$children=_slicedToArray(this.children,6),cameraPX=_this$children[0],cameraNX=_this$children[1],cameraPY=_this$children[2],cameraNY=_this$children[3],cameraPZ=_this$children[4],cameraNZ=_this$children[5];var currentRenderTarget=renderer.getRenderTarget();var currentToneMapping=renderer.toneMapping;var currentXrEnabled=renderer.xr.enabled;renderer.toneMapping=NoToneMapping;renderer.xr.enabled=false;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);renderer.toneMapping=currentToneMapping;renderer.xr.enabled=currentXrEnabled;renderTarget.texture.needsPMREMUpdate=true;}}]);return CubeCamera;}(Object3D);var CubeTexture=/*#__PURE__*/function(_Texture3){_inherits(CubeTexture,_Texture3);var _super28=_createSuper(CubeTexture);function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){var _this20;_classCallCheck(this,CubeTexture);images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;_this20=_super28.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);_this20.isCubeTexture=true;_this20.flipY=false;return _this20;}_createClass(CubeTexture,[{key:"images",get:function get(){return this.image;},set:function set(value){this.image=value;}}]);return CubeTexture;}(Texture);var WebGLCubeRenderTarget=/*#__PURE__*/function(_WebGLRenderTarget4){_inherits(WebGLCubeRenderTarget,_WebGLRenderTarget4);var _super29=_createSuper(WebGLCubeRenderTarget);function WebGLCubeRenderTarget(size){var _this21;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,WebGLCubeRenderTarget);_this21=_super29.call(this,size,size,options);_this21.isWebGLCubeRenderTarget=true;var image={width:size,height:size,depth:1};var images=[image,image,image,image,image,image];_this21.texture=new CubeTexture(images,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
  // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
  _this21.texture.isRenderTargetTexture=true;_this21.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;_this21.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;return _this21;}_createClass(WebGLCubeRenderTarget,[{key:"fromEquirectangularTexture",value:function fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.encoding=texture.encoding;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;var shader={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:/* glsl */"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"};var geometry=new BoxGeometry(5,5,5);var material=new ShaderMaterial({name:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;var mesh=new Mesh(geometry,material);var currentMinFilter=texture.minFilter;// Avoid blurred poles
  if(texture.minFilter===LinearMipmapLinearFilter)texture.minFilter=LinearFilter;var camera=new CubeCamera(1,10,this);camera.update(renderer,mesh);texture.minFilter=currentMinFilter;mesh.geometry.dispose();mesh.material.dispose();return this;}},{key:"clear",value:function clear(renderer,color,depth,stencil){var currentRenderTarget=renderer.getRenderTarget();for(var i=0;i<6;i++){renderer.setRenderTarget(this,i);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);}}]);return WebGLCubeRenderTarget;}(WebGLRenderTarget);var _vector1=/*@__PURE__*/new Vector3();var _vector2=/*@__PURE__*/new Vector3();var _normalMatrix=/*@__PURE__*/new Matrix3();var Plane=/*#__PURE__*/function(){function Plane(){var normal=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector3(1,0,0);var constant=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Plane);this.isPlane=true;// normal is assumed to be normalized
  this.normal=normal;this.constant=constant;}_createClass(Plane,[{key:"set",value:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;}},{key:"setComponents",value:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;}},{key:"setFromNormalAndCoplanarPoint",value:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}},{key:"setFromCoplanarPoints",value:function setFromCoplanarPoints(a,b,c){var normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
  this.setFromNormalAndCoplanarPoint(normal,a);return this;}},{key:"copy",value:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}},{key:"normalize",value:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
  var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;}},{key:"negate",value:function negate(){this.constant*=-1;this.normal.negate();return this;}},{key:"distanceToPoint",value:function distanceToPoint(point){return this.normal.dot(point)+this.constant;}},{key:"distanceToSphere",value:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;}},{key:"projectPoint",value:function projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);}},{key:"intersectLine",value:function intersectLine(line,target){var direction=line.delta(_vector1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
  if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
  return null;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return null;}return target.copy(direction).multiplyScalar(t).add(line.start);}},{key:"intersectsLine",value:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
  var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;}},{key:"intersectsBox",value:function intersectsBox(box){return box.intersectsPlane(this);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){return sphere.intersectsPlane(this);}},{key:"coplanarPoint",value:function coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant);}},{key:"applyMatrix4",value:function applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;}},{key:"translate",value:function translate(offset){this.constant-=offset.dot(this.normal);return this;}},{key:"equals",value:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Plane;}();var _sphere$2=/*@__PURE__*/new Sphere();var _vector$7=/*@__PURE__*/new Vector3();var Frustum=/*#__PURE__*/function(){function Frustum(){var p0=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Plane();var p1=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Plane();var p2=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new Plane();var p3=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Plane();var p4=arguments.length>4&&arguments[4]!==undefined?arguments[4]:new Plane();var p5=arguments.length>5&&arguments[5]!==undefined?arguments[5]:new Plane();_classCallCheck(this,Frustum);this.planes=[p0,p1,p2,p3,p4,p5];}_createClass(Frustum,[{key:"set",value:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;}},{key:"copy",value:function copy(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;}},{key:"setFromProjectionMatrix",value:function setFromProjectionMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;}},{key:"intersectsObject",value:function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere$2);}},{key:"intersectsSprite",value:function intersectsSprite(sprite){_sphere$2.center.set(0,0,0);_sphere$2.radius=0.7071067811865476;_sphere$2.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$2);}},{key:"intersectsSphere",value:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;}},{key:"intersectsBox",value:function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];// corner at max distance
  _vector$7.x=plane.normal.x>0?box.max.x:box.min.x;_vector$7.y=plane.normal.y>0?box.max.y:box.min.y;_vector$7.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$7)<0){return false;}}return true;}},{key:"containsPoint",value:function containsPoint(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Frustum;}();function WebGLAnimation(){var context=null;var isAnimating=false;var animationLoop=null;var requestId=null;function onAnimationFrame(time,frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame);}return {start:function start(){if(isAnimating===true)return;if(animationLoop===null)return;requestId=context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function stop(){context.cancelAnimationFrame(requestId);isAnimating=false;},setAnimationLoop:function setAnimationLoop(callback){animationLoop=callback;},setContext:function setContext(value){context=value;}};}function WebGLAttributes(gl,capabilities){var isWebGL2=capabilities.isWebGL2;var buffers=new WeakMap();function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.usage;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type;if(array instanceof Float32Array){type=5126;}else if(array instanceof Uint16Array){if(attribute.isFloat16BufferAttribute){if(isWebGL2){type=5131;}else {throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');}}else {type=5123;}}else if(array instanceof Int16Array){type=5122;}else if(array instanceof Uint32Array){type=5125;}else if(array instanceof Int32Array){type=5124;}else if(array instanceof Int8Array){type=5120;}else if(array instanceof Uint8Array){type=5121;}else if(array instanceof Uint8ClampedArray){type=5121;}else {throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: '+array);}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(updateRange.count===-1){// Not using update ranges
  gl.bufferSubData(bufferType,0,array);}else {if(isWebGL2){gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count);}else {gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));}updateRange.count=-1;// reset range
  }}//
  function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers["delete"](attribute);}}function update(attribute,bufferType){if(attribute.isGLBufferAttribute){var cached=buffers.get(attribute);if(!cached||cached.version<attribute.version){buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});}return;}if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}var PlaneGeometry=/*#__PURE__*/function(_BufferGeometry2){_inherits(PlaneGeometry,_BufferGeometry2);var _super30=_createSuper(PlaneGeometry);function PlaneGeometry(){var _this22;var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var widthSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var heightSegments=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,PlaneGeometry);_this22=_super30.call(this);_this22.type='PlaneGeometry';_this22.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments);var gridY=Math.floor(heightSegments);var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;//
  var indices=[];var vertices=[];var normals=[];var uvs=[];for(var iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(var ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}for(var _iy2=0;_iy2<gridY;_iy2++){for(var _ix2=0;_ix2<gridX;_ix2++){var a=_ix2+gridX1*_iy2;var b=_ix2+gridX1*(_iy2+1);var c=_ix2+1+gridX1*(_iy2+1);var d=_ix2+1+gridX1*_iy2;indices.push(a,b,d);indices.push(b,c,d);}}_this22.setIndex(indices);_this22.setAttribute('position',new Float32BufferAttribute(vertices,3));_this22.setAttribute('normal',new Float32BufferAttribute(normals,3));_this22.setAttribute('uv',new Float32BufferAttribute(uvs,2));return _this22;}_createClass(PlaneGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments);}}]);return PlaneGeometry;}(BufferGeometry);var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";var alphatest_pars_fragment="#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="vec3 transformed = vec3( position );";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";var iridescence_fragment="#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";var color_vertex="#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";var common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var encodings_pars_fragment="vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_fragment="LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";var lights_lambert_pars_fragment="varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var map_fragment="#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphcolor_vertex="#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";var normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var normal_fragment_maps="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";var normal_pars_fragment="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_pars_vertex="#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";var normal_vertex="#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var iridescence_pars_fragment="#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";var output_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var shadowmap_pars_vertex="#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";var transmission_fragment="#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";var transmission_pars_fragment="#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";var uv_pars_fragment="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var uv_vertex="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";var vertex$g="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";var fragment$g="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";var fragment$f="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$e="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";var fragment$e="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";var vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";var fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";var vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";var fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$a="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$9="#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$9="#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";var fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";var fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";var vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";var fragment$5="#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";var fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var vertex$2="#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,alphatest_pars_fragment:alphatest_pars_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,iridescence_fragment:iridescence_fragment,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_fragment:lights_lambert_fragment,lights_lambert_pars_fragment:lights_lambert_pars_fragment,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphcolor_vertex:morphcolor_vertex,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normal_pars_fragment:normal_pars_fragment,normal_pars_vertex:normal_pars_vertex,normal_vertex:normal_vertex,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,iridescence_pars_fragment:iridescence_pars_fragment,output_fragment:output_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,transmission_fragment:transmission_fragment,transmission_pars_fragment:transmission_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,background_vert:vertex$g,background_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1};/**
   * Uniforms library for shared webgl shaders
   */var UniformsLib={common:{diffuse:{value:/*@__PURE__*/new Color$1(0xffffff)},opacity:{value:1.0},map:{value:null},uvTransform:{value:/*@__PURE__*/new Matrix3()},uv2Transform:{value:/*@__PURE__*/new Matrix3()},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},// basic, lambert, phong
  ior:{value:1.5},// physical
  refractionRatio:{value:0.98}// basic, lambert, phong
  },aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:/*@__PURE__*/new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:/*@__PURE__*/new Color$1(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:/*@__PURE__*/new Color$1(0xffffff)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:/*@__PURE__*/new Matrix3()}},sprite:{diffuse:{value:/*@__PURE__*/new Color$1(0xffffff)},opacity:{value:1.0},center:{value:/*@__PURE__*/new Vector2(0.5,0.5)},rotation:{value:0.0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:/*@__PURE__*/new Matrix3()}}};var ShaderLib={basic:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color$1(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color$1(0x000000)},specular:{value:/*@__PURE__*/new Color$1(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color$1(0x000000)},roughness:{value:1.0},metalness:{value:0.0},envMapIntensity:{value:1}// temporary
  }]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:/*@__PURE__*/new Color$1(0x000000)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:/*@__PURE__*/new Matrix3()},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},cube:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.envmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:/*@__PURE__*/new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:/*@__PURE__*/mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:/*@__PURE__*/new Color$1(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:/*@__PURE__*/mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:/*@__PURE__*/new Vector2(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:/*@__PURE__*/new Color$1(0x000000)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:/*@__PURE__*/new Vector2()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:/*@__PURE__*/new Color$1(0x000000)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:/*@__PURE__*/new Color$1(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};function WebGLBackground(renderer,cubemaps,state,objects,alpha,premultipliedAlpha){var clearColor=new Color$1(0x000000);var clearAlpha=alpha===true?0:1;var planeMesh;var boxMesh;var currentBackground=null;var currentBackgroundVersion=0;var currentTonemapping=null;function render(renderList,scene){var forceClear=false;var background=scene.isScene===true?scene.background:null;if(background&&background.isTexture){background=cubemaps.get(background);}// Ignore background in AR
  // TODO: Reconsider this.
  var xr=renderer.xr;var session=xr.getSession&&xr.getSession();if(session&&session.environmentBlendMode==='additive'){background=null;}if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.cube.uniforms),vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// add "envMap" material property so the renderer can evaluate it like for built-in materials
  Object.defineProperty(boxMesh.material,'envMap',{get:function get(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===false?-1:1;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}boxMesh.layers.enableAll();// push to the pre-sorted opaque render list
  renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// add "map" material property so the renderer can evaluate it like for built-in materials
  Object.defineProperty(planeMesh.material,'map',{get:function get(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}planeMesh.layers.enableAll();// push to the pre-sorted opaque render list
  renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return {getClearColor:function getClearColor(){return clearColor;},setClearColor:function setClearColor(color){var alpha=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha);},getClearAlpha:function getClearAlpha(){return clearAlpha;},setClearAlpha:function setClearAlpha(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}function WebGLBindingStates(gl,extensions,attributes,capabilities){var maxVertexAttributes=gl.getParameter(34921);var extension=capabilities.isWebGL2?null:extensions.get('OES_vertex_array_object');var vaoAvailable=capabilities.isWebGL2||extension!==null;var bindingStates={};var defaultState=createBindingState(null);var currentState=defaultState;var forceUpdate=false;function setup(object,material,program,geometry,index){var updateBuffers=false;if(vaoAvailable){var state=getBindingState(geometry,program,material);if(currentState!==state){currentState=state;bindVertexArrayObject(currentState.object);}updateBuffers=needsUpdate(object,geometry,program,index);if(updateBuffers)saveCache(object,geometry,program,index);}else {var wireframe=material.wireframe===true;if(currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==wireframe){currentState.geometry=geometry.id;currentState.program=program.id;currentState.wireframe=wireframe;updateBuffers=true;}}if(index!==null){attributes.update(index,34963);}if(updateBuffers||forceUpdate){forceUpdate=false;setupVertexAttributes(object,material,program,geometry);if(index!==null){gl.bindBuffer(34963,attributes.get(index).buffer);}}}function createVertexArrayObject(){if(capabilities.isWebGL2)return gl.createVertexArray();return extension.createVertexArrayOES();}function bindVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.bindVertexArray(vao);return extension.bindVertexArrayOES(vao);}function deleteVertexArrayObject(vao){if(capabilities.isWebGL2)return gl.deleteVertexArray(vao);return extension.deleteVertexArrayOES(vao);}function getBindingState(geometry,program,material){var wireframe=material.wireframe===true;var programMap=bindingStates[geometry.id];if(programMap===undefined){programMap={};bindingStates[geometry.id]=programMap;}var stateMap=programMap[program.id];if(stateMap===undefined){stateMap={};programMap[program.id]=stateMap;}var state=stateMap[wireframe];if(state===undefined){state=createBindingState(createVertexArrayObject());stateMap[wireframe]=state;}return state;}function createBindingState(vao){var newAttributes=[];var enabledAttributes=[];var attributeDivisors=[];for(var i=0;i<maxVertexAttributes;i++){newAttributes[i]=0;enabledAttributes[i]=0;attributeDivisors[i]=0;}return {// for backward compatibility on non-VAO support browser
  geometry:null,program:null,wireframe:false,newAttributes:newAttributes,enabledAttributes:enabledAttributes,attributeDivisors:attributeDivisors,object:vao,attributes:{},index:null};}function needsUpdate(object,geometry,program,index){var cachedAttributes=currentState.attributes;var geometryAttributes=geometry.attributes;var attributesNum=0;var programAttributes=program.getAttributes();for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute.location>=0){var cachedAttribute=cachedAttributes[name];var geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(cachedAttribute===undefined)return true;if(cachedAttribute.attribute!==geometryAttribute)return true;if(geometryAttribute&&cachedAttribute.data!==geometryAttribute.data)return true;attributesNum++;}}if(currentState.attributesNum!==attributesNum)return true;if(currentState.index!==index)return true;return false;}function saveCache(object,geometry,program,index){var cache={};var attributes=geometry.attributes;var attributesNum=0;var programAttributes=program.getAttributes();for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute.location>=0){var attribute=attributes[name];if(attribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)attribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)attribute=object.instanceColor;}var data={};data.attribute=attribute;if(attribute&&attribute.data){data.data=attribute.data;}cache[name]=data;attributesNum++;}}currentState.attributes=cache;currentState.attributesNum=attributesNum;currentState.index=index;}function initAttributes(){var newAttributes=currentState.newAttributes;for(var i=0,il=newAttributes.length;i<il;i++){newAttributes[i]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;var attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var _extension=capabilities.isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');_extension[capabilities.isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){var newAttributes=currentState.newAttributes;var enabledAttributes=currentState.enabledAttributes;for(var i=0,il=enabledAttributes.length;i<il;i++){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function vertexAttribPointer(index,size,type,normalized,stride,offset){if(capabilities.isWebGL2===true&&(type===5124||type===5125)){gl.vertexAttribIPointer(index,size,type,stride,offset);}else {gl.vertexAttribPointer(index,size,type,normalized,stride,offset);}}function setupVertexAttributes(object,material,program,geometry){if(capabilities.isWebGL2===false&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)){if(extensions.get('ANGLE_instanced_arrays')===null)return;}initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute.location>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute===undefined){if(name==='instanceMatrix'&&object.instanceMatrix)geometryAttribute=object.instanceMatrix;if(name==='instanceColor'&&object.instanceColor)geometryAttribute=object.instanceColor;}if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
  if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data.isInstancedInterleavedBuffer){for(var i=0;i<programAttribute.locationSize;i++){enableAttributeAndDivisor(programAttribute.location+i,data.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=data.meshPerAttribute*data.count;}}else {for(var _i18=0;_i18<programAttribute.locationSize;_i18++){enableAttribute(programAttribute.location+_i18);}}gl.bindBuffer(34962,buffer);for(var _i19=0;_i19<programAttribute.locationSize;_i19++){vertexAttribPointer(programAttribute.location+_i19,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*_i19)*bytesPerElement);}}else {if(geometryAttribute.isInstancedBufferAttribute){for(var _i20=0;_i20<programAttribute.locationSize;_i20++){enableAttributeAndDivisor(programAttribute.location+_i20,geometryAttribute.meshPerAttribute);}if(object.isInstancedMesh!==true&&geometry._maxInstanceCount===undefined){geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else {for(var _i21=0;_i21<programAttribute.locationSize;_i21++){enableAttribute(programAttribute.location+_i21);}}gl.bindBuffer(34962,buffer);for(var _i22=0;_i22<programAttribute.locationSize;_i22++){vertexAttribPointer(programAttribute.location+_i22,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*_i22*bytesPerElement);}}}else if(materialDefaultAttributeValues!==undefined){var _value2=materialDefaultAttributeValues[name];if(_value2!==undefined){switch(_value2.length){case 2:gl.vertexAttrib2fv(programAttribute.location,_value2);break;case 3:gl.vertexAttrib3fv(programAttribute.location,_value2);break;case 4:gl.vertexAttrib4fv(programAttribute.location,_value2);break;default:gl.vertexAttrib1fv(programAttribute.location,_value2);}}}}}disableUnusedAttributes();}function dispose(){reset();for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometryId];}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===undefined)return;var programMap=bindingStates[geometry.id];for(var programId in programMap){var stateMap=programMap[programId];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[programId];}delete bindingStates[geometry.id];}function releaseStatesOfProgram(program){for(var geometryId in bindingStates){var programMap=bindingStates[geometryId];if(programMap[program.id]===undefined)continue;var stateMap=programMap[program.id];for(var wireframe in stateMap){deleteVertexArrayObject(stateMap[wireframe].object);delete stateMap[wireframe];}delete programMap[program.id];}}function reset(){resetDefaultState();forceUpdate=true;if(currentState===defaultState)return;currentState=defaultState;bindVertexArrayObject(currentState.object);}// for backward-compatibility
  function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=false;}return {setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes};}function WebGLBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawArraysInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawArraysInstancedANGLE';if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else {maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&gl.getShaderPrecisionFormat(35632,36338).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&gl.getShaderPrecisionFormat(35632,36337).precision>0){return 'mediump';}}return 'lowp';}var isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!=='undefined'&&gl instanceof WebGL2ComputeRenderingContext;var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var drawBuffers=isWebGL2||extensions.has('WEBGL_draw_buffers');var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(34930);var maxVertexTextures=gl.getParameter(35660);var maxTextureSize=gl.getParameter(3379);var maxCubemapSize=gl.getParameter(34076);var maxAttributes=gl.getParameter(34921);var maxVertexUniforms=gl.getParameter(36347);var maxVaryings=gl.getParameter(36348);var maxFragmentUniforms=gl.getParameter(36349);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=isWebGL2||extensions.has('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;var maxSamples=isWebGL2?gl.getParameter(36183):0;return {isWebGL2:isWebGL2,drawBuffers:drawBuffers,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures,maxSamples:maxSamples};}function WebGLClipping(properties){var scope=this;var globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false;var plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
  // run another frame in order to reset the state:
  numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(material,camera,useCache){var planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows;var materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
  if(renderingShadows){// there's no global clipping
  projectPlanes(null);}else {resetGlobalState();}}else {var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;var dstArray=materialProperties.clippingState||null;uniform.value=dstArray;// ensure unique state
  dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}materialProperties.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0;var dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}function WebGLCubeMaps(renderer){var cubemaps=new WeakMap();function mapTextureMapping(texture,mapping){if(mapping===EquirectangularReflectionMapping){texture.mapping=CubeReflectionMapping;}else if(mapping===EquirectangularRefractionMapping){texture.mapping=CubeRefractionMapping;}return texture;}function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===false){var mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping){if(cubemaps.has(texture)){var cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping);}else {var image=texture.image;if(image&&image.height>0){var renderTarget=new WebGLCubeRenderTarget(image.height/2);renderTarget.fromEquirectangularTexture(renderer,texture);cubemaps.set(texture,renderTarget);texture.addEventListener('dispose',onTextureDispose);return mapTextureMapping(renderTarget.texture,texture.mapping);}else {// image not yet ready. try the conversion next frame
  return null;}}}}return texture;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemap=cubemaps.get(texture);if(cubemap!==undefined){cubemaps["delete"](texture);cubemap.dispose();}}function dispose(){cubemaps=new WeakMap();}return {get:get,dispose:dispose};}var OrthographicCamera=/*#__PURE__*/function(_Camera2){_inherits(OrthographicCamera,_Camera2);var _super31=_createSuper(OrthographicCamera);function OrthographicCamera(){var _this23;var left=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;var right=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;var top=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var bottom=arguments.length>3&&arguments[3]!==undefined?arguments[3]:-1;var near=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0.1;var far=arguments.length>5&&arguments[5]!==undefined?arguments[5]:2000;_classCallCheck(this,OrthographicCamera);_this23=_super31.call(this);_this23.isOrthographicCamera=true;_this23.type='OrthographicCamera';_this23.zoom=1;_this23.view=null;_this23.left=left;_this23.right=right;_this23.top=top;_this23.bottom=bottom;_this23.near=near;_this23.far=far;_this23.updateProjectionMatrix();return _this23;}_createClass(OrthographicCamera,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(OrthographicCamera.prototype),"copy",this).call(this,source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;}},{key:"setViewOffset",value:function setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();}},{key:"clearViewOffset",value:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();}},{key:"updateProjectionMatrix",value:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;var scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert();}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(OrthographicCamera.prototype),"toJSON",this).call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}}]);return OrthographicCamera;}(Camera);var LOD_MIN=4;// The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  var EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];// The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  var MAX_SAMPLES=20;var _flatCamera=/*@__PURE__*/new OrthographicCamera();var _clearColor=/*@__PURE__*/new Color$1();var _oldTarget=null;// Golden Ratio
  var PHI=(1+Math.sqrt(5))/2;var INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  var _axisDirections=[/*@__PURE__*/new Vector3(1,1,1),/*@__PURE__*/new Vector3(-1,1,1),/*@__PURE__*/new Vector3(1,1,-1),/*@__PURE__*/new Vector3(-1,1,-1),/*@__PURE__*/new Vector3(0,PHI,INV_PHI),/*@__PURE__*/new Vector3(0,PHI,-INV_PHI),/*@__PURE__*/new Vector3(INV_PHI,0,PHI),/*@__PURE__*/new Vector3(-INV_PHI,0,PHI),/*@__PURE__*/new Vector3(PHI,INV_PHI,0),/*@__PURE__*/new Vector3(-PHI,INV_PHI,0)];/**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */var PMREMGenerator=/*#__PURE__*/function(){function PMREMGenerator(renderer){_classCallCheck(this,PMREMGenerator);this._renderer=renderer;this._pingPongRenderTarget=null;this._lodMax=0;this._cubeSize=0;this._lodPlanes=[];this._sizeLods=[];this._sigmas=[];this._blurMaterial=null;this._cubemapMaterial=null;this._equirectMaterial=null;this._compileMaterial(this._blurMaterial);}/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
  	 * is placed at the origin).
  	 */_createClass(PMREMGenerator,[{key:"fromScene",value:function fromScene(scene){var sigma=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;_oldTarget=this._renderer.getRenderTarget();this._setSize(256);var cubeUVRenderTarget=this._allocateTargets();cubeUVRenderTarget.depthBuffer=true;this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){this._blur(cubeUVRenderTarget,0,0,sigma);}this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */},{key:"fromEquirectangular",value:function fromEquirectangular(equirectangular){var renderTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;return this._fromTexture(equirectangular,renderTarget);}/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 */},{key:"fromCubemap",value:function fromCubemap(cubemap){var renderTarget=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;return this._fromTexture(cubemap,renderTarget);}/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */},{key:"compileCubemapShader",value:function compileCubemapShader(){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();this._compileMaterial(this._cubemapMaterial);}}/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */},{key:"compileEquirectangularShader",value:function compileEquirectangularShader(){if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();this._compileMaterial(this._equirectMaterial);}}/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */},{key:"dispose",value:function dispose(){this._dispose();if(this._cubemapMaterial!==null)this._cubemapMaterial.dispose();if(this._equirectMaterial!==null)this._equirectMaterial.dispose();}// private interface
  },{key:"_setSize",value:function _setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize));this._cubeSize=Math.pow(2,this._lodMax);}},{key:"_dispose",value:function _dispose(){if(this._blurMaterial!==null)this._blurMaterial.dispose();if(this._pingPongRenderTarget!==null)this._pingPongRenderTarget.dispose();for(var i=0;i<this._lodPlanes.length;i++){this._lodPlanes[i].dispose();}}},{key:"_cleanup",value:function _cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=false;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height);}},{key:"_fromTexture",value:function _fromTexture(texture,renderTarget){if(texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping){this._setSize(texture.image.length===0?16:texture.image[0].width||texture.image[0].image.width);}else {// Equirectangular
  this._setSize(texture.image.width/4);}_oldTarget=this._renderer.getRenderTarget();var cubeUVRenderTarget=renderTarget||this._allocateTargets();this._textureToCubeUV(texture,cubeUVRenderTarget);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;}},{key:"_allocateTargets",value:function _allocateTargets(){var width=3*Math.max(this._cubeSize,16*7);var height=4*this._cubeSize;var params={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:false,type:HalfFloatType,format:RGBAFormat,encoding:LinearEncoding,depthBuffer:false};var cubeUVRenderTarget=_createRenderTarget(width,height,params);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==width){if(this._pingPongRenderTarget!==null){this._dispose();}this._pingPongRenderTarget=_createRenderTarget(width,height,params);var _lodMax=this._lodMax;var _createPlanes2=_createPlanes(_lodMax);this._sizeLods=_createPlanes2.sizeLods;this._lodPlanes=_createPlanes2.lodPlanes;this._sigmas=_createPlanes2.sigmas;this._blurMaterial=_getBlurShader(_lodMax,width,height);}return cubeUVRenderTarget;}},{key:"_compileMaterial",value:function _compileMaterial(material){var tmpMesh=new Mesh(this._lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera);}},{key:"_sceneToCubeUV",value:function _sceneToCubeUV(scene,near,far,cubeUVRenderTarget){var fov=90;var aspect=1;var cubeCamera=new PerspectiveCamera(fov,aspect,near,far);var upSign=[1,-1,1,1,1,1];var forwardSign=[1,1,1,-1,-1,-1];var renderer=this._renderer;var originalAutoClear=renderer.autoClear;var toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=NoToneMapping;renderer.autoClear=false;var backgroundMaterial=new MeshBasicMaterial({name:'PMREM.Background',side:BackSide,depthWrite:false,depthTest:false});var backgroundBox=new Mesh(new BoxGeometry(),backgroundMaterial);var useSolidColor=false;var background=scene.background;if(background){if(background.isColor){backgroundMaterial.color.copy(background);scene.background=null;useSolidColor=true;}}else {backgroundMaterial.color.copy(_clearColor);useSolidColor=true;}for(var i=0;i<6;i++){var col=i%3;if(col===0){cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(forwardSign[i],0,0);}else if(col===1){cubeCamera.up.set(0,0,upSign[i]);cubeCamera.lookAt(0,forwardSign[i],0);}else {cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(0,0,forwardSign[i]);}var size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,i>2?size:0,size,size);renderer.setRenderTarget(cubeUVRenderTarget);if(useSolidColor){renderer.render(backgroundBox,cubeCamera);}renderer.render(scene,cubeCamera);}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background;}},{key:"_textureToCubeUV",value:function _textureToCubeUV(texture,cubeUVRenderTarget){var renderer=this._renderer;var isCubeTexture=texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping;if(isCubeTexture){if(this._cubemapMaterial===null){this._cubemapMaterial=_getCubemapMaterial();}this._cubemapMaterial.uniforms.flipEnvMap.value=texture.isRenderTargetTexture===false?-1:1;}else {if(this._equirectMaterial===null){this._equirectMaterial=_getEquirectMaterial();}}var material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;var mesh=new Mesh(this._lodPlanes[0],material);var uniforms=material.uniforms;uniforms['envMap'].value=texture;var size=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*size,2*size);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera);}},{key:"_applyPMREM",value:function _applyPMREM(cubeUVRenderTarget){var renderer=this._renderer;var autoClear=renderer.autoClear;renderer.autoClear=false;for(var i=1;i<this._lodPlanes.length;i++){var sigma=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]);var poleAxis=_axisDirections[(i-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,i-1,i,sigma,poleAxis);}renderer.autoClear=autoClear;}/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 */},{key:"_blur",value:function _blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){var pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}},{key:"_halfBlur",value:function _halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){var renderer=this._renderer;var blurMaterial=this._blurMaterial;if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
  var STANDARD_DEVIATIONS=3;var blurMesh=new Mesh(this._lodPlanes[lodOut],blurMaterial);var blurUniforms=blurMaterial.uniforms;var pixels=this._sizeLods[lodIn]-1;var radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);var sigmaPixels=sigmaRadians/radiansPerPixel;var samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn("sigmaRadians, ".concat(sigmaRadians,", is too large and will clip, as it requested ").concat(samples," samples when the maximum is set to ").concat(MAX_SAMPLES));}var weights=[];var sum=0;for(var i=0;i<MAX_SAMPLES;++i){var _x2=i/sigmaPixels;var weight=Math.exp(-_x2*_x2/2);weights.push(weight);if(i===0){sum+=weight;}else if(i<samples){sum+=2*weight;}}for(var _i23=0;_i23<weights.length;_i23++){weights[_i23]=weights[_i23]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}var _lodMax=this._lodMax;blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=_lodMax-lodIn;var outputSize=this._sizeLods[lodOut];var x=3*outputSize*(lodOut>_lodMax-LOD_MIN?lodOut-_lodMax+LOD_MIN:0);var y=4*(this._cubeSize-outputSize);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera);}}]);return PMREMGenerator;}();function _createPlanes(lodMax){var lodPlanes=[];var sizeLods=[];var sigmas=[];var lod=lodMax;var totalLods=lodMax-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(var i=0;i<totalLods;i++){var sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);var sigma=1.0/sizeLod;if(i>lodMax-LOD_MIN){sigma=EXTRA_LOD_SIGMA[i-lodMax+LOD_MIN-1];}else if(i===0){sigma=0;}sigmas.push(sigma);var texelSize=1.0/(sizeLod-2);var min=-texelSize;var max=1+texelSize;var uv1=[min,min,max,min,max,max,min,min,max,max,min,max];var cubeFaces=6;var vertices=6;var positionSize=3;var uvSize=2;var faceIndexSize=1;var position=new Float32Array(positionSize*vertices*cubeFaces);var uv=new Float32Array(uvSize*vertices*cubeFaces);var faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(var face=0;face<cubeFaces;face++){var x=face%3*2/3-1;var y=face>2?0:-1;var coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);var fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}var planes=new BufferGeometry();planes.setAttribute('position',new BufferAttribute(position,positionSize));planes.setAttribute('uv',new BufferAttribute(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute(faceIndex,faceIndexSize));lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return {lodPlanes:lodPlanes,sizeLods:sizeLods,sigmas:sigmas};}function _createRenderTarget(width,height,params){var cubeUVRenderTarget=new WebGLRenderTarget(width,height,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _getBlurShader(lodMax,width,height){var weights=new Float32Array(MAX_SAMPLES);var poleAxis=new Vector3(0,1,0);var shaderMaterial=new ShaderMaterial({name:'SphericalGaussianBlur',defines:{'n':MAX_SAMPLES,'CUBEUV_TEXEL_WIDTH':1.0/width,'CUBEUV_TEXEL_HEIGHT':1.0/height,'CUBEUV_MAX_MIP':"".concat(lodMax,".0")},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:NoBlending,depthTest:false,depthWrite:false});return shaderMaterial;}function _getEquirectMaterial(){return new ShaderMaterial({name:'EquirectangularToCubeUV',uniforms:{'envMap':{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:NoBlending,depthTest:false,depthWrite:false});}function _getCubemapMaterial(){return new ShaderMaterial({name:'CubemapToCubeUV',uniforms:{'envMap':{value:null},'flipEnvMap':{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:/* glsl */"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:NoBlending,depthTest:false,depthWrite:false});}function _getCommonVertexShader(){return(/* glsl */"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t");}function WebGLCubeUVMaps(renderer){var cubeUVmaps=new WeakMap();var pmremGenerator=null;function get(texture){if(texture&&texture.isTexture){var mapping=texture.mapping;var isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping;var isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;// equirect/cube map to cubeUV conversion
  if(isEquirectMap||isCubeMap){if(texture.isRenderTargetTexture&&texture.needsPMREMUpdate===true){texture.needsPMREMUpdate=false;var renderTarget=cubeUVmaps.get(texture);if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture,renderTarget):pmremGenerator.fromCubemap(texture,renderTarget);cubeUVmaps.set(texture,renderTarget);return renderTarget.texture;}else {if(cubeUVmaps.has(texture)){return cubeUVmaps.get(texture).texture;}else {var image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){if(pmremGenerator===null)pmremGenerator=new PMREMGenerator(renderer);var _renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);cubeUVmaps.set(texture,_renderTarget);texture.addEventListener('dispose',onTextureDispose);return _renderTarget.texture;}else {// image not yet ready. try the conversion next frame
  return null;}}}}}return texture;}function isCubeTextureComplete(image){var count=0;var length=6;for(var i=0;i<length;i++){if(image[i]!==undefined)count++;}return count===length;}function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);var cubemapUV=cubeUVmaps.get(texture);if(cubemapUV!==undefined){cubeUVmaps["delete"](texture);cubemapUV.dispose();}}function dispose(){cubeUVmaps=new WeakMap();if(pmremGenerator!==null){pmremGenerator.dispose();pmremGenerator=null;}}return {get:get,dispose:dispose};}function WebGLExtensions(gl){var extensions={};function getExtension(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}extensions[name]=extension;return extension;}return {has:function has(name){return getExtension(name)!==null;},init:function init(capabilities){if(capabilities.isWebGL2){getExtension('EXT_color_buffer_float');}else {getExtension('WEBGL_depth_texture');getExtension('OES_texture_float');getExtension('OES_texture_half_float');getExtension('OES_texture_half_float_linear');getExtension('OES_standard_derivatives');getExtension('OES_element_index_uint');getExtension('OES_vertex_array_object');getExtension('ANGLE_instanced_arrays');}getExtension('OES_texture_float_linear');getExtension('EXT_color_buffer_half_float');getExtension('WEBGL_multisampled_render_to_texture');},get:function get(name){var extension=getExtension(name);if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}return extension;}};}function WebGLGeometries(gl,attributes,info,bindingStates){var geometries={};var wireframeAttributes=new WeakMap();function onGeometryDispose(event){var geometry=event.target;if(geometry.index!==null){attributes.remove(geometry.index);}for(var name in geometry.attributes){attributes.remove(geometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];var attribute=wireframeAttributes.get(geometry);if(attribute){attributes.remove(attribute);wireframeAttributes["delete"](geometry);}bindingStates.releaseStatesOfGeometry(geometry);if(geometry.isInstancedBufferGeometry===true){delete geometry._maxInstanceCount;}//
  info.memory.geometries--;}function get(object,geometry){if(geometries[geometry.id]===true)return geometry;geometry.addEventListener('dispose',onGeometryDispose);geometries[geometry.id]=true;info.memory.geometries++;return geometry;}function update(geometry){var geometryAttributes=geometry.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
  for(var name in geometryAttributes){attributes.update(geometryAttributes[name],34962);}// morph targets
  var morphAttributes=geometry.morphAttributes;for(var _name3 in morphAttributes){var array=morphAttributes[_name3];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],34962);}}}function updateWireframeAttribute(geometry){var indices=[];var geometryIndex=geometry.index;var geometryPosition=geometry.attributes.position;var version=0;if(geometryIndex!==null){var array=geometryIndex.array;version=geometryIndex.version;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else {var _array=geometryPosition.array;version=geometryPosition.version;for(var _i24=0,_l5=_array.length/3-1;_i24<_l5;_i24+=3){var _a4=_i24+0;var _b4=_i24+1;var _c4=_i24+2;indices.push(_a4,_b4,_b4,_c4,_c4,_a4);}}var attribute=new(arrayNeedsUint32(indices)?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version;// Updating index buffer in VAO now. See WebGLBindingStates
  //
  var previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
  wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){var currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){var geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
  if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else {updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode,1);}function renderInstances(start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawElementsInstanced';}else {extension=extensions.get('ANGLE_instanced_arrays');methodName='drawElementsInstancedANGLE';if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}//
  this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}function WebGLInfo(gl){var memory={geometries:0,textures:0};var render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){render.calls++;switch(mode){case 4:render.triangles+=instanceCount*(count/3);break;case 1:render.lines+=instanceCount*(count/2);break;case 3:render.lines+=instanceCount*(count-1);break;case 2:render.lines+=instanceCount*count;break;case 0:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}function numericalSort(a,b){return a[0]-b[0];}function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function WebGLMorphtargets(gl,capabilities,textures){var influencesList={};var morphInfluences=new Float32Array(8);var morphTextures=new WeakMap();var morph=new Vector4();var workInfluences=[];for(var i=0;i<8;i++){workInfluences[i]=[i,0];}function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;if(capabilities.isWebGL2===true){// instead of using attributes, the WebGL 2 code path encodes morph targets
  // into an array of data textures. Each layer represents a single morph target.
  var morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;var morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;var entry=morphTextures.get(geometry);if(entry===undefined||entry.count!==morphTargetsCount){var disposeTexture=function disposeTexture(){texture.dispose();morphTextures["delete"](geometry);geometry.removeEventListener('dispose',disposeTexture);};if(entry!==undefined)entry.texture.dispose();var hasMorphPosition=geometry.morphAttributes.position!==undefined;var hasMorphNormals=geometry.morphAttributes.normal!==undefined;var hasMorphColors=geometry.morphAttributes.color!==undefined;var morphTargets=geometry.morphAttributes.position||[];var morphNormals=geometry.morphAttributes.normal||[];var morphColors=geometry.morphAttributes.color||[];var vertexDataCount=0;if(hasMorphPosition===true)vertexDataCount=1;if(hasMorphNormals===true)vertexDataCount=2;if(hasMorphColors===true)vertexDataCount=3;var width=geometry.attributes.position.count*vertexDataCount;var height=1;if(width>capabilities.maxTextureSize){height=Math.ceil(width/capabilities.maxTextureSize);width=capabilities.maxTextureSize;}var buffer=new Float32Array(width*height*4*morphTargetsCount);var texture=new DataArrayTexture(buffer,width,height,morphTargetsCount);texture.type=FloatType;texture.needsUpdate=true;// fill buffer
  var vertexDataStride=vertexDataCount*4;for(var _i25=0;_i25<morphTargetsCount;_i25++){var morphTarget=morphTargets[_i25];var morphNormal=morphNormals[_i25];var morphColor=morphColors[_i25];var offset=width*height*4*_i25;for(var j=0;j<morphTarget.count;j++){var stride=j*vertexDataStride;if(hasMorphPosition===true){morph.fromBufferAttribute(morphTarget,j);buffer[offset+stride+0]=morph.x;buffer[offset+stride+1]=morph.y;buffer[offset+stride+2]=morph.z;buffer[offset+stride+3]=0;}if(hasMorphNormals===true){morph.fromBufferAttribute(morphNormal,j);buffer[offset+stride+4]=morph.x;buffer[offset+stride+5]=morph.y;buffer[offset+stride+6]=morph.z;buffer[offset+stride+7]=0;}if(hasMorphColors===true){morph.fromBufferAttribute(morphColor,j);buffer[offset+stride+8]=morph.x;buffer[offset+stride+9]=morph.y;buffer[offset+stride+10]=morph.z;buffer[offset+stride+11]=morphColor.itemSize===4?morph.w:1;}}}entry={count:morphTargetsCount,texture:texture,size:new Vector2(width,height)};morphTextures.set(geometry,entry);geometry.addEventListener('dispose',disposeTexture);}//
  var morphInfluencesSum=0;for(var _i26=0;_i26<objectInfluences.length;_i26++){morphInfluencesSum+=objectInfluences[_i26];}var morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',objectInfluences);program.getUniforms().setValue(gl,'morphTargetsTexture',entry.texture,textures);program.getUniforms().setValue(gl,'morphTargetsTextureSize',entry.size);}else {// When object doesn't have morph target influences defined, we treat it as a 0-length array
  // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
  var length=objectInfluences===undefined?0:objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined||influences.length!==length){// initialise list
  influences=[];for(var _i27=0;_i27<length;_i27++){influences[_i27]=[_i27,0];}influencesList[geometry.id]=influences;}// Collect influences
  for(var _i28=0;_i28<length;_i28++){var influence=influences[_i28];influence[0]=_i28;influence[1]=objectInfluences[_i28];}influences.sort(absNumericalSort);for(var _i29=0;_i29<8;_i29++){if(_i29<length&&influences[_i29][1]){workInfluences[_i29][0]=influences[_i29][0];workInfluences[_i29][1]=influences[_i29][1];}else {workInfluences[_i29][0]=Number.MAX_SAFE_INTEGER;workInfluences[_i29][1]=0;}}workInfluences.sort(numericalSort);var _morphTargets=geometry.morphAttributes.position;var _morphNormals=geometry.morphAttributes.normal;var _morphInfluencesSum=0;for(var _i30=0;_i30<8;_i30++){var _influence=workInfluences[_i30];var index=_influence[0];var _value3=_influence[1];if(index!==Number.MAX_SAFE_INTEGER&&_value3){if(_morphTargets&&geometry.getAttribute('morphTarget'+_i30)!==_morphTargets[index]){geometry.setAttribute('morphTarget'+_i30,_morphTargets[index]);}if(_morphNormals&&geometry.getAttribute('morphNormal'+_i30)!==_morphNormals[index]){geometry.setAttribute('morphNormal'+_i30,_morphNormals[index]);}morphInfluences[_i30]=_value3;_morphInfluencesSum+=_value3;}else {if(_morphTargets&&geometry.hasAttribute('morphTarget'+_i30)===true){geometry.deleteAttribute('morphTarget'+_i30);}if(_morphNormals&&geometry.hasAttribute('morphNormal'+_i30)===true){geometry.deleteAttribute('morphNormal'+_i30);}morphInfluences[_i30]=0;}}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
  // This allows us to switch between absolute morphs and relative morphs without changing shader code
  // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
  var _morphBaseInfluence=geometry.morphTargetsRelative?1:1-_morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',_morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}}return {update:update};}function WebGLObjects(gl,geometries,attributes,info){var updateMap=new WeakMap();function update(object){var frame=info.render.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
  if(updateMap.get(buffergeometry)!==frame){geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){if(object.hasEventListener('dispose',onInstancedMeshDispose)===false){object.addEventListener('dispose',onInstancedMeshDispose);}attributes.update(object.instanceMatrix,34962);if(object.instanceColor!==null){attributes.update(object.instanceColor,34962);}}return buffergeometry;}function dispose(){updateMap=new WeakMap();}function onInstancedMeshDispose(event){var instancedMesh=event.target;instancedMesh.removeEventListener('dispose',onInstancedMeshDispose);attributes.remove(instancedMesh.instanceMatrix);if(instancedMesh.instanceColor!==null)attributes.remove(instancedMesh.instanceColor);}return {update:update,dispose:dispose};}/**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */var emptyTexture=/*@__PURE__*/new Texture();var emptyArrayTexture=/*@__PURE__*/new DataArrayTexture();var empty3dTexture=/*@__PURE__*/new Data3DTexture();var emptyCubeTexture=/*@__PURE__*/new CubeTexture();// --- Utilities ---
  // Array Caches (provide typed arrays for temporary by size)
  var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
  var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);var mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
  function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983
  var n=nBlocks*blockSize;var r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(var i=0,l=a.length;i<l;i++){if(a[i]!==b[i])return false;}return true;}function copyArray(a,b){for(var i=0,l=b.length;i<l;i++){a[i]=b[i];}}// Texture unit allocation
  function allocTexUnits(textures,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i){r[i]=textures.allocateTextureUnit();}return r;}// --- Setters ---
  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.
  // Single scalar
  function setValueV1f(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
  function setValueV2f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else {if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else {if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else {if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or THREE.MatrixN)
  function setValueM2(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else {if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single integer / boolean
  function setValueV1i(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}// Single integer / boolean vector (from flat array)
  function setValueV2i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}function setValueV3i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}function setValueV4i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}// Single unsigned integer
  function setValueV1ui(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Single unsigned integer vector (from flat array)
  function setValueV2ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2uiv(this.addr,v);copyArray(cache,v);}function setValueV3ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3uiv(this.addr,v);copyArray(cache,v);}function setValueV4ui(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4uiv(this.addr,v);copyArray(cache,v);}// Single texture (2D / Cube)
  function setValueT1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2D(v||emptyTexture,unit);}function setValueT3D1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||empty3dTexture,unit);}function setValueT6(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTextureCube(v||emptyCubeTexture,unit);}function setValueT2DArray1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyArrayTexture,unit);}// Helper to pick the right setter for the singular case
  function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
  case 0x8b50:return setValueV2f;// _VEC2
  case 0x8b51:return setValueV3f;// _VEC3
  case 0x8b52:return setValueV4f;// _VEC4
  case 0x8b5a:return setValueM2;// _MAT2
  case 0x8b5b:return setValueM3;// _MAT3
  case 0x8b5c:return setValueM4;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
  case 0x1405:return setValueV1ui;// UINT
  case 0x8dc6:return setValueV2ui;// _VEC2
  case 0x8dc7:return setValueV3ui;// _VEC3
  case 0x8dc8:return setValueV4ui;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1;case 0x8b5f:// SAMPLER_3D
  case 0x8dcb:// INT_SAMPLER_3D
  case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
  return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
  case 0x8dcf:// INT_SAMPLER_2D_ARRAY
  case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
  case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
  return setValueT2DArray1;}}// Array of scalars
  function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Array of vectors (from flat array or array of THREE.VectorN)
  function setValueV2fArray(gl,v){var data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){var data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){var data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (from flat array or array of THREE.MatrixN)
  function setValueM2Array(gl,v){var data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){var data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){var data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of integer / boolean
  function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}// Array of integer / boolean vectors (from flat array)
  function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of unsigned integer
  function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v);}// Array of unsigned integer vectors (from flat array)
  function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v);}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v);}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v);}// Array of textures (2D / 3D / Cube / 2DArray)
  function setValueT1Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT3DArray(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.setTexture3D(v[i]||empty3dTexture,units[i]);}}function setValueT6Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}function setValueT2DArrayArray(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.setTexture2DArray(v[i]||emptyArrayTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
  function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
  case 0x8b50:return setValueV2fArray;// _VEC2
  case 0x8b51:return setValueV3fArray;// _VEC3
  case 0x8b52:return setValueV4fArray;// _VEC4
  case 0x8b5a:return setValueM2Array;// _MAT2
  case 0x8b5b:return setValueM3Array;// _MAT3
  case 0x8b5c:return setValueM4Array;// _MAT4
  case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
  case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
  case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
  case 0x1405:return setValueV1uiArray;// UINT
  case 0x8dc6:return setValueV2uiArray;// _VEC2
  case 0x8dc7:return setValueV3uiArray;// _VEC3
  case 0x8dc8:return setValueV4uiArray;// _VEC4
  case 0x8b5e:// SAMPLER_2D
  case 0x8d66:// SAMPLER_EXTERNAL_OES
  case 0x8dca:// INT_SAMPLER_2D
  case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
  case 0x8b62:// SAMPLER_2D_SHADOW
  return setValueT1Array;case 0x8b5f:// SAMPLER_3D
  case 0x8dcb:// INT_SAMPLER_3D
  case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
  return setValueT3DArray;case 0x8b60:// SAMPLER_CUBE
  case 0x8dcc:// INT_SAMPLER_CUBE
  case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
  case 0x8dc5:// SAMPLER_CUBE_SHADOW
  return setValueT6Array;case 0x8dc1:// SAMPLER_2D_ARRAY
  case 0x8dcf:// INT_SAMPLER_2D_ARRAY
  case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
  case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
  return setValueT2DArrayArray;}}// --- Uniform Classes ---
  var SingleUniform=/*#__PURE__*/_createClass(function SingleUniform(id,activeInfo,addr){_classCallCheck(this,SingleUniform);this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  });var PureArrayUniform=/*#__PURE__*/_createClass(function PureArrayUniform(id,activeInfo,addr){_classCallCheck(this,PureArrayUniform);this.id=id;this.addr=addr;this.cache=[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  });var StructuredUniform=/*#__PURE__*/function(){function StructuredUniform(id){_classCallCheck(this,StructuredUniform);this.id=id;this.seq=[];this.map={};}_createClass(StructuredUniform,[{key:"setValue",value:function setValue(gl,value,textures){var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id],textures);}}}]);return StructuredUniform;}();// --- Top-level ---
  // Parser - builds up the property tree from the path strings
  var RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.
  function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex=0;while(true){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;var _id2=match[1];var idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)_id2=_id2|0;// convert to integer
  if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
  addUniform(container,subscript===undefined?new SingleUniform(_id2,activeInfo,addr):new PureArrayUniform(_id2,activeInfo,addr));break;}else {// step into inner node / create it in case it doesn't exist
  var map=container.map;var next=map[_id2];if(next===undefined){next=new StructuredUniform(_id2);addUniform(container,next);}container=next;}}}// Root Container
  var WebGLUniforms=/*#__PURE__*/function(){function WebGLUniforms(gl,program){_classCallCheck(this,WebGLUniforms);this.seq=[];this.map={};var n=gl.getProgramParameter(program,35718);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}_createClass(WebGLUniforms,[{key:"setValue",value:function setValue(gl,name,value,textures){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);}},{key:"setOptional",value:function setOptional(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);}}],[{key:"upload",value:function upload(gl,seq,values,textures){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
  u.setValue(gl,v.value,textures);}}}},{key:"seqWithValue",value:function seqWithValue(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;}}]);return WebGLUniforms;}();function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}var programIdCount=0;function handleSource(string,errorLine){var lines=string.split('\n');var lines2=[];var from=Math.max(errorLine-6,0);var to=Math.min(errorLine+6,lines.length);for(var i=from;i<to;i++){var line=i+1;lines2.push("".concat(line===errorLine?'>':' '," ").concat(line,": ").concat(lines[i]));}return lines2.join('\n');}function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return ['Linear','( value )'];case sRGBEncoding:return ['sRGB','( value )'];default:console.warn('THREE.WebGLProgram: Unsupported encoding:',encoding);return ['Linear','( value )'];}}function getShaderErrors(gl,shader,type){var status=gl.getShaderParameter(shader,35713);var errors=gl.getShaderInfoLog(shader).trim();if(status&&errors==='')return '';var errorMatches=/ERROR: 0:(\d+)/.exec(errors);if(errorMatches){// --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
  var errorLine=parseInt(errorMatches[1]);return type.toUpperCase()+'\n\n'+errors+'\n\n'+handleSource(gl.getShaderSource(shader),errorLine);}else {return errors;}}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;case CustomToneMapping:toneMappingName='Custom';break;default:console.warn('THREE.WebGLProgram: Unsupported toneMapping:',toneMapping);toneMappingName='Linear';}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(parameters){var chunks=[parameters.extensionDerivatives||!!parameters.envMapCubeUVHeight||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==='physical'?'#extension GL_OES_standard_derivatives : enable':'',(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?'#extension GL_EXT_frag_depth : enable':'',parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?'#extension GL_EXT_draw_buffers : require':'',(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission)&&parameters.rendererExtensionShaderTextureLod?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var _value4=defines[name];if(_value4===false)continue;chunks.push('#define '+name+' '+_value4);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,35721);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;var locationSize=1;if(info.type===35674)locationSize=2;if(info.type===35675)locationSize=3;if(info.type===35676)locationSize=4;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
  attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize:locationSize};}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){var numSpotLightCoords=parameters.numSpotLightShadows+parameters.numSpotLightMaps-parameters.numSpotLightShadowsWithMaps;return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
  var includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}function includeReplacer(match,include){var string=ShaderChunk[include];if(string===undefined){throw new Error('Can not resolve #include <'+include+'>');}return resolveIncludes(string);}// Unroll Loops
  var unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer);}function loopReplacer(match,start,end,snippet){var string='';for(var i=parseInt(start);i<parseInt(end);i++){string+=snippet.replace(/\[\s*i\s*\]/g,'[ '+i+' ]').replace(/UNROLLED_LOOP_INDEX/g,i);}return string;}//
  function generatePrecision(parameters){var precisionstring='precision '+parameters.precision+' float;\nprecision '+parameters.precision+' int;';if(parameters.precision==='highp'){precisionstring+='\n#define HIGH_PRECISION';}else if(parameters.precision==='mediump'){precisionstring+='\n#define MEDIUM_PRECISION';}else if(parameters.precision==='lowp'){precisionstring+='\n#define LOW_PRECISION';}return precisionstring;}function generateShadowMapTypeDefine(parameters){var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){var envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){var envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){var envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function generateCubeUVSize(parameters){var imageHeight=parameters.envMapCubeUVHeight;if(imageHeight===null)return null;var maxMip=Math.log2(imageHeight)-2;var texelHeight=1.0/imageHeight;var texelWidth=1.0/(3*Math.max(Math.pow(2,maxMip),7*16));return {texelWidth:texelWidth,texelHeight:texelHeight,maxMip:maxMip};}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){// TODO Send this event to Three.js DevTools
  // console.log( 'WebGLProgram', cacheKey );
  var gl=renderer.getContext();var defines=parameters.defines;var vertexShader=parameters.vertexShader;var fragmentShader=parameters.fragmentShader;var shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);var envMapTypeDefine=generateEnvMapTypeDefine(parameters);var envMapModeDefine=generateEnvMapModeDefine(parameters);var envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);var envMapCubeUVSize=generateCubeUVSize(parameters);var customExtensions=parameters.isWebGL2?'':generateExtensions(parameters);var customDefines=generateDefines(defines);var program=gl.createProgram();var prefixVertex,prefixFragment;var versionString=parameters.glslVersion?'#version '+parameters.glslVersion+'\n':'';if(parameters.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else {prefixVertex=[generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.instancing?'#define USE_INSTANCING':'',parameters.instancingColor?'#define USE_INSTANCING_COLOR':'',parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'',parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularColorMap?'#define USE_SPECULARCOLORMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.sheenColorMap?'#define USE_SHEENCOLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEENROUGHNESSMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.morphColors&&parameters.isWebGL2?'#define USE_MORPHCOLORS':'',parameters.morphTargetsCount>0&&parameters.isWebGL2?'#define MORPHTARGETS_TEXTURE':'',parameters.morphTargetsCount>0&&parameters.isWebGL2?'#define MORPHTARGETS_TEXTURE_STRIDE '+parameters.morphTextureStride:'',parameters.morphTargetsCount>0&&parameters.isWebGL2?'#define MORPHTARGETS_COUNT '+parameters.morphTargetsCount:'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING','	attribute mat4 instanceMatrix;','#endif','#ifdef USE_INSTANCING_COLOR','	attribute vec3 instanceColor;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#if defined( USE_COLOR_ALPHA )','	attribute vec4 color;','#elif defined( USE_COLOR )','	attribute vec3 color;','#endif','#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_WIDTH '+envMapCubeUVSize.texelWidth:'',envMapCubeUVSize?'#define CUBEUV_TEXEL_HEIGHT '+envMapCubeUVSize.texelHeight:'',envMapCubeUVSize?'#define CUBEUV_MAX_MIP '+envMapCubeUVSize.maxMip+'.0':'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoat?'#define USE_CLEARCOAT':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.iridescence?'#define USE_IRIDESCENCE':'',parameters.iridescenceMap?'#define USE_IRIDESCENCEMAP':'',parameters.iridescenceThicknessMap?'#define USE_IRIDESCENCE_THICKNESSMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.specularIntensityMap?'#define USE_SPECULARINTENSITYMAP':'',parameters.specularColorMap?'#define USE_SPECULARCOLORMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.alphaTest?'#define USE_ALPHATEST':'',parameters.sheen?'#define USE_SHEEN':'',parameters.sheenColorMap?'#define USE_SHEENCOLORMAP':'',parameters.sheenRoughnessMap?'#define USE_SHEENROUGHNESSMAP':'',parameters.transmission?'#define USE_TRANSMISSION':'',parameters.transmissionMap?'#define USE_TRANSMISSIONMAP':'',parameters.thicknessMap?'#define USE_THICKNESSMAP':'',parameters.decodeVideoTexture?'#define DECODE_VIDEO_TEXTURE':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors||parameters.instancingColor?'#define USE_COLOR':'',parameters.vertexAlphas?'#define USE_COLOR_ALPHA':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
  parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.opaque?'#define OPAQUE':'',ShaderChunk['encodings_pars_fragment'],// this code is required here because it is used by the various encoding/decoding function defined below
  getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding),parameters.useDepthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isWebGL2&&parameters.isRawShaderMaterial!==true){// GLSL 3.0 conversion for built-in materials and ShaderMaterial
  versionString='#version 300 es\n';prefixVertex=['precision mediump sampler2DArray;','#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#define varying in',parameters.glslVersion===GLSL3?'':'layout(location = 0) out highp vec4 pc_fragColor;',parameters.glslVersion===GLSL3?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}var vertexGlsl=versionString+prefixVertex+vertexShader;var fragmentGlsl=versionString+prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );
  var glVertexShader=WebGLShader(gl,35633,vertexGlsl);var glFragmentShader=WebGLShader(gl,35632,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
  if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
  gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);// check for link errors
  if(renderer.debug.checkShaderErrors){var programLog=gl.getProgramInfoLog(program).trim();var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();var runnable=true;var haveDiagnostics=true;if(gl.getProgramParameter(program,35714)===false){runnable=false;var vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');var fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: Shader Error '+gl.getError()+' - '+'VALIDATE_STATUS '+gl.getProgramParameter(program,35715)+'\n\n'+'Program Info Log: '+programLog+'\n'+vertexErrors+'\n'+fragmentErrors);}else if(programLog!==''){console.warn('THREE.WebGLProgram: Program Info Log:',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );
  gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
  var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program);}return cachedUniforms;};// set up caching for attribute locations
  var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
  this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=undefined;};//
  this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}var _id=0;var WebGLShaderCache=/*#__PURE__*/function(){function WebGLShaderCache(){_classCallCheck(this,WebGLShaderCache);this.shaderCache=new Map();this.materialCache=new Map();}_createClass(WebGLShaderCache,[{key:"update",value:function update(material){var vertexShader=material.vertexShader;var fragmentShader=material.fragmentShader;var vertexShaderStage=this._getShaderStage(vertexShader);var fragmentShaderStage=this._getShaderStage(fragmentShader);var materialShaders=this._getShaderCacheForMaterial(material);if(materialShaders.has(vertexShaderStage)===false){materialShaders.add(vertexShaderStage);vertexShaderStage.usedTimes++;}if(materialShaders.has(fragmentShaderStage)===false){materialShaders.add(fragmentShaderStage);fragmentShaderStage.usedTimes++;}return this;}},{key:"remove",value:function remove(material){var materialShaders=this.materialCache.get(material);var _iterator=_createForOfIteratorHelper(materialShaders),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var shaderStage=_step.value;shaderStage.usedTimes--;if(shaderStage.usedTimes===0)this.shaderCache["delete"](shaderStage.code);}}catch(err){_iterator.e(err);}finally{_iterator.f();}this.materialCache["delete"](material);return this;}},{key:"getVertexShaderID",value:function getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id;}},{key:"getFragmentShaderID",value:function getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id;}},{key:"dispose",value:function dispose(){this.shaderCache.clear();this.materialCache.clear();}},{key:"_getShaderCacheForMaterial",value:function _getShaderCacheForMaterial(material){var cache=this.materialCache;var set=cache.get(material);if(set===undefined){set=new Set();cache.set(material,set);}return set;}},{key:"_getShaderStage",value:function _getShaderStage(code){var cache=this.shaderCache;var stage=cache.get(code);if(stage===undefined){stage=new WebGLShaderStage(code);cache.set(code,stage);}return stage;}}]);return WebGLShaderCache;}();var WebGLShaderStage=/*#__PURE__*/_createClass(function WebGLShaderStage(code){_classCallCheck(this,WebGLShaderStage);this.id=_id++;this.code=code;this.usedTimes=0;});function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){var _programLayers=new Layers();var _customShaders=new WebGLShaderCache();var programs=[];var isWebGL2=capabilities.isWebGL2;var logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;var vertexTextures=capabilities.vertexTextures;var precision=capabilities.precision;var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};function getParameters(material,lights,shadows,scene,object){var fog=scene.fog;var geometry=object.geometry;var environment=material.isMeshStandardMaterial?scene.environment:null;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var envMapCubeUVHeight=!!envMap&&envMap.mapping===CubeUVReflectionMapping?envMap.image.height:null;var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
  // (not to blow over maxLights budget)
  if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}//
  var morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;var morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;var morphTextureStride=0;if(geometry.morphAttributes.position!==undefined)morphTextureStride=1;if(geometry.morphAttributes.normal!==undefined)morphTextureStride=2;if(geometry.morphAttributes.color!==undefined)morphTextureStride=3;//
  var vertexShader,fragmentShader;var customVertexShaderID,customFragmentShaderID;if(shaderID){var shader=ShaderLib[shaderID];vertexShader=shader.vertexShader;fragmentShader=shader.fragmentShader;}else {vertexShader=material.vertexShader;fragmentShader=material.fragmentShader;_customShaders.update(material);customVertexShaderID=_customShaders.getVertexShaderID(material);customFragmentShaderID=_customShaders.getFragmentShaderID(material);}var currentRenderTarget=renderer.getRenderTarget();var useAlphaTest=material.alphaTest>0;var useClearcoat=material.clearcoat>0;var useIridescence=material.iridescence>0;var parameters={isWebGL2:isWebGL2,shaderID:shaderID,shaderName:material.type,vertexShader:vertexShader,fragmentShader:fragmentShader,defines:material.defines,customVertexShaderID:customVertexShaderID,customFragmentShaderID:customFragmentShaderID,isRawShaderMaterial:material.isRawShaderMaterial===true,glslVersion:material.glslVersion,precision:precision,instancing:object.isInstancedMesh===true,instancingColor:object.isInstancedMesh===true&&object.instanceColor!==null,supportsVertexTextures:vertexTextures,outputEncoding:currentRenderTarget===null?renderer.outputEncoding:currentRenderTarget.isXRRenderTarget===true?currentRenderTarget.texture.encoding:LinearEncoding,map:!!material.map,matcap:!!material.matcap,envMap:!!envMap,envMapMode:envMap&&envMap.mapping,envMapCubeUVHeight:envMapCubeUVHeight,lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,tangentSpaceNormalMap:material.normalMapType===TangentSpaceNormalMap,decodeVideoTexture:!!material.map&&material.map.isVideoTexture===true&&material.map.encoding===sRGBEncoding,clearcoat:useClearcoat,clearcoatMap:useClearcoat&&!!material.clearcoatMap,clearcoatRoughnessMap:useClearcoat&&!!material.clearcoatRoughnessMap,clearcoatNormalMap:useClearcoat&&!!material.clearcoatNormalMap,iridescence:useIridescence,iridescenceMap:useIridescence&&!!material.iridescenceMap,iridescenceThicknessMap:useIridescence&&!!material.iridescenceThicknessMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,specularIntensityMap:!!material.specularIntensityMap,specularColorMap:!!material.specularColorMap,opaque:material.transparent===false&&material.blending===NormalBlending,alphaMap:!!material.alphaMap,alphaTest:useAlphaTest,gradientMap:!!material.gradientMap,sheen:material.sheen>0,sheenColorMap:!!material.sheenColorMap,sheenRoughnessMap:!!material.sheenRoughnessMap,transmission:material.transmission>0,transmissionMap:!!material.transmissionMap,thicknessMap:!!material.thicknessMap,combine:material.combine,vertexTangents:!!material.normalMap&&!!geometry.attributes.tangent,vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.iridescenceMap||!!material.iridescenceThicknessMap||!!material.displacementMap||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularColorMap||!!material.sheenColorMap||!!material.sheenRoughnessMap,uvsVertexOnly:!(!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatNormalMap||!!material.iridescenceMap||!!material.iridescenceThicknessMap||material.transmission>0||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularColorMap||material.sheen>0||!!material.sheenColorMap||!!material.sheenRoughnessMap)&&!!material.displacementMap,fog:!!fog,useFog:material.fog===true,fogExp2:fog&&fog.isFogExp2,flatShading:!!material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:logarithmicDepthBuffer,skinning:object.isSkinnedMesh===true,morphTargets:geometry.morphAttributes.position!==undefined,morphNormals:geometry.morphAttributes.normal!==undefined,morphColors:geometry.morphAttributes.color!==undefined,morphTargetsCount:morphTargetsCount,morphTextureStride:morphTextureStride,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numSpotLightMaps:lights.spotLightMap.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numSpotLightShadowsWithMaps:lights.numSpotLightShadowsWithMaps,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:NoToneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,useDepthPacking:!!material.depthPacking,depthPacking:material.depthPacking||0,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||extensions.has('EXT_frag_depth'),rendererExtensionDrawBuffers:isWebGL2||extensions.has('WEBGL_draw_buffers'),rendererExtensionShaderTextureLod:isWebGL2||extensions.has('EXT_shader_texture_lod'),customProgramCacheKey:material.customProgramCacheKey()};return parameters;}function getProgramCacheKey(parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else {array.push(parameters.customVertexShaderID);array.push(parameters.customFragmentShaderID);}if(parameters.defines!==undefined){for(var name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===false){getProgramCacheKeyParameters(array,parameters);getProgramCacheKeyBooleans(array,parameters);array.push(renderer.outputEncoding);}array.push(parameters.customProgramCacheKey);return array.join();}function getProgramCacheKeyParameters(array,parameters){array.push(parameters.precision);array.push(parameters.outputEncoding);array.push(parameters.envMapMode);array.push(parameters.envMapCubeUVHeight);array.push(parameters.combine);array.push(parameters.vertexUvs);array.push(parameters.fogExp2);array.push(parameters.sizeAttenuation);array.push(parameters.morphTargetsCount);array.push(parameters.morphAttributeCount);array.push(parameters.numDirLights);array.push(parameters.numPointLights);array.push(parameters.numSpotLights);array.push(parameters.numSpotLightMaps);array.push(parameters.numHemiLights);array.push(parameters.numRectAreaLights);array.push(parameters.numDirLightShadows);array.push(parameters.numPointLightShadows);array.push(parameters.numSpotLightShadows);array.push(parameters.numSpotLightShadowsWithMaps);array.push(parameters.shadowMapType);array.push(parameters.toneMapping);array.push(parameters.numClippingPlanes);array.push(parameters.numClipIntersection);array.push(parameters.depthPacking);}function getProgramCacheKeyBooleans(array,parameters){_programLayers.disableAll();if(parameters.isWebGL2)_programLayers.enable(0);if(parameters.supportsVertexTextures)_programLayers.enable(1);if(parameters.instancing)_programLayers.enable(2);if(parameters.instancingColor)_programLayers.enable(3);if(parameters.map)_programLayers.enable(4);if(parameters.matcap)_programLayers.enable(5);if(parameters.envMap)_programLayers.enable(6);if(parameters.lightMap)_programLayers.enable(7);if(parameters.aoMap)_programLayers.enable(8);if(parameters.emissiveMap)_programLayers.enable(9);if(parameters.bumpMap)_programLayers.enable(10);if(parameters.normalMap)_programLayers.enable(11);if(parameters.objectSpaceNormalMap)_programLayers.enable(12);if(parameters.tangentSpaceNormalMap)_programLayers.enable(13);if(parameters.clearcoat)_programLayers.enable(14);if(parameters.clearcoatMap)_programLayers.enable(15);if(parameters.clearcoatRoughnessMap)_programLayers.enable(16);if(parameters.clearcoatNormalMap)_programLayers.enable(17);if(parameters.iridescence)_programLayers.enable(18);if(parameters.iridescenceMap)_programLayers.enable(19);if(parameters.iridescenceThicknessMap)_programLayers.enable(20);if(parameters.displacementMap)_programLayers.enable(21);if(parameters.specularMap)_programLayers.enable(22);if(parameters.roughnessMap)_programLayers.enable(23);if(parameters.metalnessMap)_programLayers.enable(24);if(parameters.gradientMap)_programLayers.enable(25);if(parameters.alphaMap)_programLayers.enable(26);if(parameters.alphaTest)_programLayers.enable(27);if(parameters.vertexColors)_programLayers.enable(28);if(parameters.vertexAlphas)_programLayers.enable(29);if(parameters.vertexUvs)_programLayers.enable(30);if(parameters.vertexTangents)_programLayers.enable(31);if(parameters.uvsVertexOnly)_programLayers.enable(32);array.push(_programLayers.mask);_programLayers.disableAll();if(parameters.fog)_programLayers.enable(0);if(parameters.useFog)_programLayers.enable(1);if(parameters.flatShading)_programLayers.enable(2);if(parameters.logarithmicDepthBuffer)_programLayers.enable(3);if(parameters.skinning)_programLayers.enable(4);if(parameters.morphTargets)_programLayers.enable(5);if(parameters.morphNormals)_programLayers.enable(6);if(parameters.morphColors)_programLayers.enable(7);if(parameters.premultipliedAlpha)_programLayers.enable(8);if(parameters.shadowMapEnabled)_programLayers.enable(9);if(parameters.physicallyCorrectLights)_programLayers.enable(10);if(parameters.doubleSided)_programLayers.enable(11);if(parameters.flipSided)_programLayers.enable(12);if(parameters.useDepthPacking)_programLayers.enable(13);if(parameters.dithering)_programLayers.enable(14);if(parameters.specularIntensityMap)_programLayers.enable(15);if(parameters.specularColorMap)_programLayers.enable(16);if(parameters.transmission)_programLayers.enable(17);if(parameters.transmissionMap)_programLayers.enable(18);if(parameters.thicknessMap)_programLayers.enable(19);if(parameters.sheen)_programLayers.enable(20);if(parameters.sheenColorMap)_programLayers.enable(21);if(parameters.sheenRoughnessMap)_programLayers.enable(22);if(parameters.decodeVideoTexture)_programLayers.enable(23);if(parameters.opaque)_programLayers.enable(24);array.push(_programLayers.mask);}function getUniforms(material){var shaderID=shaderIDs[material.type];var uniforms;if(shaderID){var shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms);}else {uniforms=material.uniforms;}return uniforms;}function acquireProgram(parameters,cacheKey){var program;// Check if code has been already compiled
  for(var p=0,pl=programs.length;p<pl;p++){var preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates);programs.push(program);}return program;}function releaseProgram(program){if(--program.usedTimes===0){// Remove from unordered set
  var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
  program.destroy();}}function releaseShaderCache(material){_customShaders.remove(material);}function dispose(){_customShaders.dispose();}return {getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,releaseShaderCache:releaseShaderCache,// Exposed for resource monitoring & error feedback via renderer.info:
  programs:programs,dispose:dispose};}function WebGLProperties(){var properties=new WeakMap();function get(object){var map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties["delete"](object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {get:get,remove:remove,update:update,dispose:dispose};}function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else {return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else {return a.id-b.id;}}function WebGLRenderList(){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transmissive=[];var transparent=[];function init(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){var renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else {renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.push(renderItem);}else if(material.transparent===true){transparent.push(renderItem);}else {opaque.push(renderItem);}}function unshift(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);if(material.transmission>0.0){transmissive.unshift(renderItem);}else if(material.transparent===true){transparent.unshift(renderItem);}else {opaque.unshift(renderItem);}}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transmissive.length>1)transmissive.sort(customTransparentSort||reversePainterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
  for(var i=renderItemsIndex,il=renderItems.length;i<il;i++){var renderItem=renderItems[i];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.group=null;}}return {opaque:opaque,transmissive:transmissive,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(){var lists=new WeakMap();function get(scene,renderCallDepth){var listArray=lists.get(scene);var list;if(listArray===undefined){list=new WebGLRenderList();lists.set(scene,[list]);}else {if(renderCallDepth>=listArray.length){list=new WebGLRenderList();listArray.push(list);}else {list=listArray[renderCallDepth];}}return list;}function dispose(){lists=new WeakMap();}return {get:get,dispose:dispose};}function UniformsCache(){var lights={};return {get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color$1()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color$1(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new Vector3(),color:new Color$1(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color$1(),groundColor:new Color$1()};break;case'RectAreaLight':uniforms={color:new Color$1(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){var lights={};return {get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
  }lights[light.id]=uniforms;return uniforms;}};}var nextVersion=0;function shadowCastingAndTexturingLightsFirst(lightA,lightB){return (lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0);}function WebGLLights(extensions,capabilities){var cache=new UniformsCache();var shadowCache=ShadowUniformsCache();var state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(var i=0;i<9;i++){state.probe.push(new Vector3());}var vector3=new Vector3();var matrix4=new Matrix4();var matrix42=new Matrix4();function setup(lights,physicallyCorrectLights){var r=0,g=0,b=0;for(var _i31=0;_i31<9;_i31++){state.probe[_i31].set(0,0,0);}var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var numDirectionalShadows=0;var numPointShadows=0;var numSpotShadows=0;var numSpotMaps=0;var numSpotShadowsWithMaps=0;// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
  lights.sort(shadowCastingAndTexturingLightsFirst);// artist-friendly light intensity scaling factor
  var scaleFactor=physicallyCorrectLights!==true?Math.PI:1;for(var _i32=0,l=lights.length;_i32<l;_i32++){var light=lights[_i32];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity*scaleFactor;g+=color.g*intensity*scaleFactor;b+=color.b*intensity*scaleFactor;}else if(light.isLightProbe){for(var j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowNormalBias=shadow.normalBias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var _uniforms=cache.get(light);_uniforms.position.setFromMatrixPosition(light.matrixWorld);_uniforms.color.copy(color).multiplyScalar(intensity*scaleFactor);_uniforms.distance=distance;_uniforms.coneCos=Math.cos(light.angle);_uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));_uniforms.decay=light.decay;state.spot[spotLength]=_uniforms;var _shadow=light.shadow;if(light.map){state.spotLightMap[numSpotMaps]=light.map;numSpotMaps++;// make sure the lightMatrix is up to date
  // TODO : do it if required only
  _shadow.updateMatrices(light);if(light.castShadow)numSpotShadowsWithMaps++;}state.spotLightMatrix[spotLength]=_shadow.matrix;if(light.castShadow){var _shadowUniforms=shadowCache.get(light);_shadowUniforms.shadowBias=_shadow.bias;_shadowUniforms.shadowNormalBias=_shadow.normalBias;_shadowUniforms.shadowRadius=_shadow.radius;_shadowUniforms.shadowMapSize=_shadow.mapSize;state.spotShadow[spotLength]=_shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;numSpotShadows++;}spotLength++;}else if(light.isRectAreaLight){var _uniforms2=cache.get(light);// (a) intensity is the total visible light emitted
  //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
  // (b) intensity is the brightness of the light
  _uniforms2.color.copy(color).multiplyScalar(intensity);_uniforms2.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms2.halfHeight.set(0.0,light.height*0.5,0.0);state.rectArea[rectAreaLength]=_uniforms2;rectAreaLength++;}else if(light.isPointLight){var _uniforms3=cache.get(light);_uniforms3.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor);_uniforms3.distance=light.distance;_uniforms3.decay=light.decay;if(light.castShadow){var _shadow2=light.shadow;var _shadowUniforms2=shadowCache.get(light);_shadowUniforms2.shadowBias=_shadow2.bias;_shadowUniforms2.shadowNormalBias=_shadow2.normalBias;_shadowUniforms2.shadowRadius=_shadow2.radius;_shadowUniforms2.shadowMapSize=_shadow2.mapSize;_shadowUniforms2.shadowCameraNear=_shadow2.camera.near;_shadowUniforms2.shadowCameraFar=_shadow2.camera.far;state.pointShadow[pointLength]=_shadowUniforms2;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=_uniforms3;pointLength++;}else if(light.isHemisphereLight){var _uniforms4=cache.get(light);_uniforms4.skyColor.copy(light.color).multiplyScalar(intensity*scaleFactor);_uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity*scaleFactor);state.hemi[hemiLength]=_uniforms4;hemiLength++;}}if(rectAreaLength>0){if(capabilities.isWebGL2){// WebGL 2
  state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else {// WebGL 1
  if(extensions.has('OES_texture_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1;state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2;}else if(extensions.has('OES_texture_half_float_linear')===true){state.rectAreaLTC1=UniformsLib.LTC_HALF_1;state.rectAreaLTC2=UniformsLib.LTC_HALF_2;}else {console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');}}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;var hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows||hash.numSpotMaps!==numSpotMaps){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotLightMatrix.length=numSpotShadows+numSpotMaps-numSpotShadowsWithMaps;state.spotLightMap.length=numSpotMaps;state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;hash.numSpotMaps=numSpotMaps;state.version=nextVersion++;}}function setupView(lights,camera){var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var viewMatrix=camera.matrixWorldInverse;for(var _i33=0,l=lights.length;_i33<l;_i33++){var light=lights[_i33];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);directionalLength++;}else if(light.isSpotLight){var _uniforms5=state.spot[spotLength];_uniforms5.position.setFromMatrixPosition(light.matrixWorld);_uniforms5.position.applyMatrix4(viewMatrix);_uniforms5.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);_uniforms5.direction.sub(vector3);_uniforms5.direction.transformDirection(viewMatrix);spotLength++;}else if(light.isRectAreaLight){var _uniforms6=state.rectArea[rectAreaLength];_uniforms6.position.setFromMatrixPosition(light.matrixWorld);_uniforms6.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
  matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);_uniforms6.halfWidth.set(light.width*0.5,0.0,0.0);_uniforms6.halfHeight.set(0.0,light.height*0.5,0.0);_uniforms6.halfWidth.applyMatrix4(matrix42);_uniforms6.halfHeight.applyMatrix4(matrix42);rectAreaLength++;}else if(light.isPointLight){var _uniforms7=state.point[pointLength];_uniforms7.position.setFromMatrixPosition(light.matrixWorld);_uniforms7.position.applyMatrix4(viewMatrix);pointLength++;}else if(light.isHemisphereLight){var _uniforms8=state.hemi[hemiLength];_uniforms8.direction.setFromMatrixPosition(light.matrixWorld);_uniforms8.direction.transformDirection(viewMatrix);hemiLength++;}}}return {setup:setup,setupView:setupView,state:state};}function WebGLRenderState(extensions,capabilities){var lights=new WebGLLights(extensions,capabilities);var lightsArray=[];var shadowsArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(physicallyCorrectLights){lights.setup(lightsArray,physicallyCorrectLights);}function setupLightsView(camera){lights.setupView(lightsArray,camera);}var state={lightsArray:lightsArray,shadowsArray:shadowsArray,lights:lights};return {init:init,state:state,setupLights:setupLights,setupLightsView:setupLightsView,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(extensions,capabilities){var renderStates=new WeakMap();function get(scene){var renderCallDepth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var renderStateArray=renderStates.get(scene);var renderState;if(renderStateArray===undefined){renderState=new WebGLRenderState(extensions,capabilities);renderStates.set(scene,[renderState]);}else {if(renderCallDepth>=renderStateArray.length){renderState=new WebGLRenderState(extensions,capabilities);renderStateArray.push(renderState);}else {renderState=renderStateArray[renderCallDepth];}}return renderState;}function dispose(){renderStates=new WeakMap();}return {get:get,dispose:dispose};}var MeshDepthMaterial=/*#__PURE__*/function(_Material3){_inherits(MeshDepthMaterial,_Material3);var _super32=_createSuper(MeshDepthMaterial);function MeshDepthMaterial(parameters){var _this24;_classCallCheck(this,MeshDepthMaterial);_this24=_super32.call(this);_this24.isMeshDepthMaterial=true;_this24.type='MeshDepthMaterial';_this24.depthPacking=BasicDepthPacking;_this24.map=null;_this24.alphaMap=null;_this24.displacementMap=null;_this24.displacementScale=1;_this24.displacementBias=0;_this24.wireframe=false;_this24.wireframeLinewidth=1;_this24.setValues(parameters);return _this24;}_createClass(MeshDepthMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshDepthMaterial.prototype),"copy",this).call(this,source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;}}]);return MeshDepthMaterial;}(Material);var MeshDistanceMaterial=/*#__PURE__*/function(_Material4){_inherits(MeshDistanceMaterial,_Material4);var _super33=_createSuper(MeshDistanceMaterial);function MeshDistanceMaterial(parameters){var _this25;_classCallCheck(this,MeshDistanceMaterial);_this25=_super33.call(this);_this25.isMeshDistanceMaterial=true;_this25.type='MeshDistanceMaterial';_this25.referencePosition=new Vector3();_this25.nearDistance=1;_this25.farDistance=1000;_this25.map=null;_this25.alphaMap=null;_this25.displacementMap=null;_this25.displacementScale=1;_this25.displacementBias=0;_this25.setValues(parameters);return _this25;}_createClass(MeshDistanceMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshDistanceMaterial.prototype),"copy",this).call(this,source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;}}]);return MeshDistanceMaterial;}(Material);var vertex="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";var fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(_renderer,_objects,_capabilities){var _frustum=new Frustum();var _shadowMapSize=new Vector2(),_viewportSize=new Vector2(),_viewport=new Vector4(),_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial(),_materialCache={},_maxTextureSize=_capabilities.maxTextureSize;var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};var shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2()},radius:{value:4.0}},vertexShader:vertex,fragmentShader:fragment});var shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;var fullScreenTri=new BufferGeometry();fullScreenTri.setAttribute('position',new BufferAttribute(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));var fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;var currentRenderTarget=_renderer.getRenderTarget();var activeCubeFace=_renderer.getActiveCubeFace();var activeMipmapLevel=_renderer.getActiveMipmapLevel();var _state=_renderer.state;// Set GL state for depth map.
  _state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
  for(var i=0,il=lights.length;i<il;i++){var light=lights[i];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}if(shadow.autoUpdate===false&&shadow.needsUpdate===false)continue;_shadowMapSize.copy(shadow.mapSize);var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize){if(_shadowMapSize.x>_maxTextureSize){_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>_maxTextureSize){_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null){var pars=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+'.shadowMap';shadow.camera.updateProjectionMatrix();}_renderer.setRenderTarget(shadow.map);_renderer.clear();var viewportCount=shadow.getViewportCount();for(var vp=0;vp<viewportCount;vp++){var viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
  if(shadow.isPointLightShadow!==true&&this.type===VSMShadowMap){VSMPass(shadow,camera);}shadow.needsUpdate=false;}scope.needsUpdate=false;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){var geometry=_objects.update(fullScreenMesh);if(shadowMaterialVertical.defines.VSM_SAMPLES!==shadow.blurSamples){shadowMaterialVertical.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialHorizontal.defines.VSM_SAMPLES=shadow.blurSamples;shadowMaterialVertical.needsUpdate=true;shadowMaterialHorizontal.needsUpdate=true;}if(shadow.mapPass===null){shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y);}// vertical pass
  shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.mapPass);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizontal pass
  shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizontal.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.map);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null);}function getDepthMaterial(object,material,light,shadowCameraNear,shadowCameraFar,type){var result=null;var customMaterial=light.isPointLight===true?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==undefined){result=customMaterial;}else {result=light.isPointLight===true?_distanceMaterial:_depthMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&Array.isArray(material.clippingPlanes)&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0){// in this case we need a unique material instance reflecting the
  // appropriate state
  var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else {result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.alphaMap=material.alphaMap;result.alphaTest=material.alphaTest;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.displacementMap=material.displacementMap;result.displacementScale=material.displacementScale;result.displacementBias=material.displacementBias;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){result.referencePosition.setFromMatrixPosition(light.matrixWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var _depthMaterial2=getDepthMaterial(object,material,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,_depthMaterial2,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,light,type);}}}function WebGLState(gl,extensions,capabilities){var _equationToGL,_factorToGL;var isWebGL2=capabilities.isWebGL2;function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return {setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
  }};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return {setTest:function setTest(depthTest){if(depthTest){enable(2929);}else {disable(2929);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(512);break;case AlwaysDepth:gl.depthFunc(519);break;case LessDepth:gl.depthFunc(513);break;case LessEqualDepth:gl.depthFunc(515);break;case EqualDepth:gl.depthFunc(514);break;case GreaterEqualDepth:gl.depthFunc(518);break;case GreaterDepth:gl.depthFunc(516);break;case NotEqualDepth:gl.depthFunc(517);break;default:gl.depthFunc(515);}}else {gl.depthFunc(515);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return {setTest:function setTest(stencilTest){if(!locked){if(stencilTest){enable(2960);}else {disable(2960);}}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
  var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var uboBindings=new WeakMap();var uboProgamMap=new WeakMap();var enabledCapabilities={};var currentBoundFramebuffers={};var currentDrawbuffers=new WeakMap();var defaultDrawbuffers=[];var currentProgram=null;var currentBlendingEnabled=false;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(35661);var lineWidthAvailable=false;var version=0;var glVersion=gl.getParameter(7938);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}var currentTextureSlot=null;var currentBoundTextures={};var scissorParam=gl.getParameter(3088);var viewportParam=gl.getParameter(2978);var currentScissor=new Vector4().fromArray(scissorParam);var currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
  var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,10241,9728);gl.texParameteri(type,10240,9728);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,6408,1,1,0,6408,5121,data);}return texture;}var emptyTextures={};emptyTextures[3553]=createTexture(3553,3553,1);emptyTextures[34067]=createTexture(34067,34069,6);// init
  colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(2929);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(2884);setBlending(NoBlending);//
  function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function bindFramebuffer(target,framebuffer){if(currentBoundFramebuffers[target]!==framebuffer){gl.bindFramebuffer(target,framebuffer);currentBoundFramebuffers[target]=framebuffer;if(isWebGL2){// 36009 is equivalent to 36160
  if(target===36009){currentBoundFramebuffers[36160]=framebuffer;}if(target===36160){currentBoundFramebuffers[36009]=framebuffer;}}return true;}return false;}function drawBuffers(renderTarget,framebuffer){var drawBuffers=defaultDrawbuffers;var needsUpdate=false;if(renderTarget){drawBuffers=currentDrawbuffers.get(framebuffer);if(drawBuffers===undefined){drawBuffers=[];currentDrawbuffers.set(framebuffer,drawBuffers);}if(renderTarget.isWebGLMultipleRenderTargets){var textures=renderTarget.texture;if(drawBuffers.length!==textures.length||drawBuffers[0]!==36064){for(var i=0,il=textures.length;i<il;i++){drawBuffers[i]=36064+i;}drawBuffers.length=textures.length;needsUpdate=true;}}else {if(drawBuffers[0]!==36064){drawBuffers[0]=36064;needsUpdate=true;}}}else {if(drawBuffers[0]!==1029){drawBuffers[0]=1029;needsUpdate=true;}}if(needsUpdate){if(capabilities.isWebGL2){gl.drawBuffers(drawBuffers);}else {extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);}}}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}var equationToGL=(_equationToGL={},_defineProperty(_equationToGL,AddEquation,32774),_defineProperty(_equationToGL,SubtractEquation,32778),_defineProperty(_equationToGL,ReverseSubtractEquation,32779),_equationToGL);if(isWebGL2){equationToGL[MinEquation]=32775;equationToGL[MaxEquation]=32776;}else {var extension=extensions.get('EXT_blend_minmax');if(extension!==null){equationToGL[MinEquation]=extension.MIN_EXT;equationToGL[MaxEquation]=extension.MAX_EXT;}}var factorToGL=(_factorToGL={},_defineProperty(_factorToGL,ZeroFactor,0),_defineProperty(_factorToGL,OneFactor,1),_defineProperty(_factorToGL,SrcColorFactor,768),_defineProperty(_factorToGL,SrcAlphaFactor,770),_defineProperty(_factorToGL,SrcAlphaSaturateFactor,776),_defineProperty(_factorToGL,DstColorFactor,774),_defineProperty(_factorToGL,DstAlphaFactor,772),_defineProperty(_factorToGL,OneMinusSrcColorFactor,769),_defineProperty(_factorToGL,OneMinusSrcAlphaFactor,771),_defineProperty(_factorToGL,OneMinusDstColorFactor,775),_defineProperty(_factorToGL,OneMinusDstAlphaFactor,773),_factorToGL);function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled===true){disable(3042);currentBlendingEnabled=false;}return;}if(currentBlendingEnabled===false){enable(3042);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(32774);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(1,771,1,771);break;case AdditiveBlending:gl.blendFunc(1,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,769,0,1);break;case MultiplyBlending:gl.blendFuncSeparate(0,768,0,770);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else {switch(blending){case NormalBlending:gl.blendFuncSeparate(770,771,1,771);break;case AdditiveBlending:gl.blendFunc(770,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,769,0,1);break;case MultiplyBlending:gl.blendFunc(0,768);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
  blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}currentBlending=blending;currentPremultipledAlpha=null;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(2884):enable(2884);var flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);var stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);material.alphaToCoverage===true?enable(32926):disable(32926);}//
  function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(2304);}else {gl.frontFace(2305);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(2884);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(1029);}else if(cullFace===CullFaceFront){gl.cullFace(1028);}else {gl.cullFace(1032);}}}else {disable(2884);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(32823);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else {disable(32823);}}function setScissorTest(scissorTest){if(scissorTest){enable(3089);}else {disable(3089);}}// texture
  function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=33984+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texSubImage2D(){try{gl.texSubImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texSubImage3D(){try{gl.texSubImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function compressedTexSubImage2D(){try{gl.compressedTexSubImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texStorage2D(){try{gl.texStorage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texStorage3D(){try{gl.texStorage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
  function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}function updateUBOMapping(uniformsGroup,program){var mapping=uboProgamMap.get(program);if(mapping===undefined){mapping=new WeakMap();uboProgamMap.set(program,mapping);}var blockIndex=mapping.get(uniformsGroup);if(blockIndex===undefined){blockIndex=gl.getUniformBlockIndex(program,uniformsGroup.name);mapping.set(uniformsGroup,blockIndex);}}function uniformBlockBinding(uniformsGroup,program){var mapping=uboProgamMap.get(program);var blockIndex=mapping.get(uniformsGroup);if(uboBindings.get(uniformsGroup)!==blockIndex){// bind shader specific block index to global block point
  gl.uniformBlockBinding(program,blockIndex,uniformsGroup.__bindingPointIndex);uboBindings.set(uniformsGroup,blockIndex);}}//
  function reset(){// reset state
  gl.disable(3042);gl.disable(2884);gl.disable(2929);gl.disable(32823);gl.disable(3089);gl.disable(2960);gl.disable(32926);gl.blendEquation(32774);gl.blendFunc(1,0);gl.blendFuncSeparate(1,0,1,0);gl.colorMask(true,true,true,true);gl.clearColor(0,0,0,0);gl.depthMask(true);gl.depthFunc(513);gl.clearDepth(1);gl.stencilMask(0xffffffff);gl.stencilFunc(519,0,0xffffffff);gl.stencilOp(7680,7680,7680);gl.clearStencil(0);gl.cullFace(1029);gl.frontFace(2305);gl.polygonOffset(0,0);gl.activeTexture(33984);gl.bindFramebuffer(36160,null);if(isWebGL2===true){gl.bindFramebuffer(36009,null);gl.bindFramebuffer(36008,null);}gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);// reset internals
  enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};currentBoundFramebuffers={};currentDrawbuffers=new WeakMap();defaultDrawbuffers=[];currentProgram=null;currentBlendingEnabled=false;currentBlending=null;currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentPremultipledAlpha=false;currentFlipSided=null;currentCullFace=null;currentLineWidth=null;currentPolygonOffsetFactor=null;currentPolygonOffsetUnits=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable:enable,disable:disable,bindFramebuffer:bindFramebuffer,drawBuffers:drawBuffers,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,updateUBOMapping:updateUBOMapping,uniformBlockBinding:uniformBlockBinding,texStorage2D:texStorage2D,texStorage3D:texStorage3D,texSubImage2D:texSubImage2D,texSubImage3D:texSubImage3D,compressedTexSubImage2D:compressedTexSubImage2D,scissor:scissor,viewport:viewport,reset:reset};}function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){var _wrappingToGL,_filterToGL;var isWebGL2=capabilities.isWebGL2;var maxTextures=capabilities.maxTextures;var maxCubemapSize=capabilities.maxCubemapSize;var maxTextureSize=capabilities.maxTextureSize;var maxSamples=capabilities.maxSamples;var multisampledRTTExt=extensions.has('WEBGL_multisampled_render_to_texture')?extensions.get('WEBGL_multisampled_render_to_texture'):null;var supportsInvalidateFramebuffer=/OculusBrowser/g.test(navigator.userAgent);var _videoTextures=new WeakMap();var _canvas;var _sources=new WeakMap();// maps WebglTexture objects to instances of Source
  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
  var useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'// eslint-disable-next-line compat/compat
  &&new OffscreenCanvas(1,1).getContext('2d')!==null;}catch(err){// Ignore any errors
  }function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
  return useOffscreenCanvas?// eslint-disable-next-line compat/compat
  new OffscreenCanvas(width,height):createElementNS('canvas');}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){var scale=1;// handle case if texture exceeds max size
  if(image.width>maxSize||image.height>maxSize){scale=maxSize/Math.max(image.width,image.height);}// only perform resize if necessary
  if(scale<1||needsPowerOfTwo===true){// only perform resize for certain image types
  if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){var floor=needsPowerOfTwo?floorPowerOfTwo:Math.floor;var width=floor(scale*image.width);var height=floor(scale*image.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
  var canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;var context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);console.warn('THREE.WebGLRenderer: Texture has been resized from ('+image.width+'x'+image.height+') to ('+width+'x'+height+').');return canvas;}else {if('data'in image){console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+image.width+'x'+image.height+').');}return image;}}return image;}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height);}function textureNeedsPowerOfTwo(texture){if(isWebGL2)return false;return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target){_gl.generateMipmap(target);}function getInternalFormat(internalFormatName,glFormat,glType,encoding){var isVideoTexture=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;if(isWebGL2===false)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \''+internalFormatName+'\'');}var internalFormat=glFormat;if(glFormat===6403){if(glType===5126)internalFormat=33326;if(glType===5131)internalFormat=33325;if(glType===5121)internalFormat=33321;}if(glFormat===33319){if(glType===5126)internalFormat=33328;if(glType===5131)internalFormat=33327;if(glType===5121)internalFormat=33323;}if(glFormat===6408){if(glType===5126)internalFormat=34836;if(glType===5131)internalFormat=34842;if(glType===5121)internalFormat=encoding===sRGBEncoding&&isVideoTexture===false?35907:32856;if(glType===32819)internalFormat=32854;if(glType===32820)internalFormat=32855;}if(internalFormat===33325||internalFormat===33326||internalFormat===33327||internalFormat===33328||internalFormat===34842||internalFormat===34836){extensions.get('EXT_color_buffer_float');}return internalFormat;}function getMipLevels(texture,image,supportsMips){if(textureNeedsGenerateMipmaps(texture,supportsMips)===true||texture.isFramebufferTexture&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){return Math.log2(Math.max(image.width,image.height))+1;}else if(texture.mipmaps!==undefined&&texture.mipmaps.length>0){// user-defined mipmaps
  return texture.mipmaps.length;}else if(texture.isCompressedTexture&&Array.isArray(texture.image)){return image.mipmaps.length;}else {// texture without mipmaps (only base level)
  return 1;}}// Fallback filters for non-power-of-2 textures
  function filterFallback(f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return 9728;}return 9729;}//
  function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures["delete"](texture);}}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);}//
  function deallocateTexture(texture){var textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;// check if it's necessary to remove the WebGLTexture object
  var source=texture.source;var webglTextures=_sources.get(source);if(webglTextures){var webglTexture=webglTextures[textureProperties.__cacheKey];webglTexture.usedTimes--;// the WebGLTexture object is not used anymore, remove it
  if(webglTexture.usedTimes===0){deleteTexture(texture);}// remove the weak map entry if no WebGLTexture uses the source anymore
  if(Object.keys(webglTextures).length===0){_sources["delete"](source);}}properties.remove(texture);}function deleteTexture(texture){var textureProperties=properties.get(texture);_gl.deleteTexture(textureProperties.__webglTexture);var source=texture.source;var webglTextures=_sources.get(source);delete webglTextures[textureProperties.__cacheKey];info.memory.textures--;}function deallocateRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);info.memory.textures--;}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLCubeRenderTarget){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else {_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer){for(var _i34=0;_i34<renderTargetProperties.__webglColorRenderbuffer.length;_i34++){if(renderTargetProperties.__webglColorRenderbuffer[_i34])_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[_i34]);}}if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}if(renderTarget.isWebGLMultipleRenderTargets){for(var _i35=0,il=texture.length;_i35<il;_i35++){var attachmentProperties=properties.get(texture[_i35]);if(attachmentProperties.__webglTexture){_gl.deleteTexture(attachmentProperties.__webglTexture);info.memory.textures--;}properties.remove(texture[_i35]);}}properties.remove(texture);properties.remove(renderTarget);}//
  var textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){var textureUnit=textureUnits;if(textureUnit>=maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+maxTextures);}textureUnits+=1;return textureUnit;}function getTextureCacheKey(texture){var array=[];array.push(texture.wrapS);array.push(texture.wrapT);array.push(texture.magFilter);array.push(texture.minFilter);array.push(texture.anisotropy);array.push(texture.internalFormat);array.push(texture.format);array.push(texture.type);array.push(texture.generateMipmaps);array.push(texture.premultiplyAlpha);array.push(texture.flipY);array.push(texture.unpackAlignment);array.push(texture.encoding);return array.join();}//
  function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.isRenderTargetTexture===false&&texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===null){console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');}else {uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(33984+slot);state.bindTexture(3553,textureProperties.__webglTexture);}function setTexture2DArray(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(35866,textureProperties.__webglTexture);}function setTexture3D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(32879,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);}var wrappingToGL=(_wrappingToGL={},_defineProperty(_wrappingToGL,RepeatWrapping,10497),_defineProperty(_wrappingToGL,ClampToEdgeWrapping,33071),_defineProperty(_wrappingToGL,MirroredRepeatWrapping,33648),_wrappingToGL);var filterToGL=(_filterToGL={},_defineProperty(_filterToGL,NearestFilter,9728),_defineProperty(_filterToGL,NearestMipmapNearestFilter,9984),_defineProperty(_filterToGL,NearestMipmapLinearFilter,9986),_defineProperty(_filterToGL,LinearFilter,9729),_defineProperty(_filterToGL,LinearMipmapNearestFilter,9985),_defineProperty(_filterToGL,LinearMipmapLinearFilter,9987),_filterToGL);function setTextureParameters(textureType,texture,supportsMips){if(supportsMips){_gl.texParameteri(textureType,10242,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,10243,wrappingToGL[texture.wrapT]);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,10240,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,10241,filterToGL[texture.minFilter]);}else {_gl.texParameteri(textureType,10242,33071);_gl.texParameteri(textureType,10243,33071);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,33071);}if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');}_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');}}if(extensions.has('EXT_texture_filter_anisotropic')===true){var extension=extensions.get('EXT_texture_filter_anisotropic');if(texture.type===FloatType&&extensions.has('OES_texture_float_linear')===false)return;// verify extension for WebGL 1 and WebGL 2
  if(isWebGL2===false&&texture.type===HalfFloatType&&extensions.has('OES_texture_half_float_linear')===false)return;// verify extension for WebGL 1 only
  if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){var forceUpload=false;if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);}// create Source <-> WebGLTextures mapping if necessary
  var source=texture.source;var webglTextures=_sources.get(source);if(webglTextures===undefined){webglTextures={};_sources.set(source,webglTextures);}// check if there is already a WebGLTexture object for the given texture parameters
  var textureCacheKey=getTextureCacheKey(texture);if(textureCacheKey!==textureProperties.__cacheKey){// if not, create a new instance of WebGLTexture
  if(webglTextures[textureCacheKey]===undefined){// create new entry
  webglTextures[textureCacheKey]={texture:_gl.createTexture(),usedTimes:0};info.memory.textures++;// when a new instance of WebGLTexture was created, a texture upload is required
  // even if the image contents are identical
  forceUpload=true;}webglTextures[textureCacheKey].usedTimes++;// every time the texture cache key changes, it's necessary to check if an instance of
  // WebGLTexture can be deleted in order to avoid a memory leak.
  var webglTexture=webglTextures[textureProperties.__cacheKey];if(webglTexture!==undefined){webglTextures[textureProperties.__cacheKey].usedTimes--;if(webglTexture.usedTimes===0){deleteTexture(texture);}}// store references to cache key and WebGLTexture object
  textureProperties.__cacheKey=textureCacheKey;textureProperties.__webglTexture=webglTextures[textureCacheKey].texture;}return forceUpload;}function uploadTexture(textureProperties,texture,slot){var textureType=3553;if(texture.isDataArrayTexture)textureType=35866;if(texture.isData3DTexture)textureType=32879;var forceUpload=initTexture(textureProperties,texture);var source=texture.source;state.activeTexture(33984+slot);state.bindTexture(textureType,textureProperties.__webglTexture);if(source.version!==source.__currentVersion||forceUpload===true){_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo$1(texture.image)===false;var image=resizeImage(texture.image,needsPowerOfTwo,false,maxTextureSize);image=verifyColorSpace(texture,image);var supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format,texture.encoding);var glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding,texture.isVideoTexture);setTextureParameters(textureType,texture,supportsMips);var mipmap;var mipmaps=texture.mipmaps;var useTexStorage=isWebGL2&&texture.isVideoTexture!==true;var allocateMemory=source.__currentVersion===undefined||forceUpload===true;var levels=getMipLevels(texture,image,supportsMips);if(texture.isDepthTexture){// populate depth texture with dummy data
  glInternalFormat=6402;if(isWebGL2){if(texture.type===FloatType){glInternalFormat=36012;}else if(texture.type===UnsignedIntType){glInternalFormat=33190;}else if(texture.type===UnsignedInt248Type){glInternalFormat=35056;}else {glInternalFormat=33189;// WebGL2 requires sized internalformat for glTexImage2D
  }}else {if(texture.type===FloatType){console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');}}// validation checks for WebGL 1
  if(texture.format===DepthFormat&&glInternalFormat===6402){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedIntType;glType=utils.convert(texture.type);}}if(texture.format===DepthStencilFormat&&glInternalFormat===6402){// Depth stencil textures need the DEPTH_STENCIL internal format
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  glInternalFormat=34041;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}//
  if(allocateMemory){if(useTexStorage){state.texStorage2D(3553,1,glInternalFormat,image.width,image.height);}else {state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}}}else if(texture.isDataTexture){// use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){if(useTexStorage&&allocateMemory){state.texStorage2D(3553,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(useTexStorage){state.texSubImage2D(3553,i,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}else {state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){state.texStorage2D(3553,levels,glInternalFormat,image.width,image.height);}state.texSubImage2D(3553,0,0,0,image.width,image.height,glFormat,glType,image.data);}else {state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);}}}else if(texture.isCompressedTexture){if(useTexStorage&&allocateMemory){state.texStorage2D(3553,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(var _i36=0,_il9=mipmaps.length;_i36<_il9;_i36++){mipmap=mipmaps[_i36];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){state.compressedTexSubImage2D(3553,_i36,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}else {state.compressedTexImage2D(3553,_i36,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else {if(useTexStorage){state.texSubImage2D(3553,_i36,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}else {state.texImage2D(3553,_i36,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}else if(texture.isDataArrayTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(35866,levels,glInternalFormat,image.width,image.height,image.depth);}state.texSubImage3D(35866,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}else {state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isData3DTexture){if(useTexStorage){if(allocateMemory){state.texStorage3D(32879,levels,glInternalFormat,image.width,image.height,image.depth);}state.texSubImage3D(32879,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data);}else {state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);}}else if(texture.isFramebufferTexture){if(allocateMemory){if(useTexStorage){state.texStorage2D(3553,levels,glInternalFormat,image.width,image.height);}else {var width=image.width,height=image.height;for(var _i37=0;_i37<levels;_i37++){state.texImage2D(3553,_i37,glInternalFormat,width,height,0,glFormat,glType,null);width>>=1;height>>=1;}}}}else {// regular Texture (image, video, canvas)
  // use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&supportsMips){if(useTexStorage&&allocateMemory){state.texStorage2D(3553,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);}for(var _i38=0,_il10=mipmaps.length;_i38<_il10;_i38++){mipmap=mipmaps[_i38];if(useTexStorage){state.texSubImage2D(3553,_i38,0,0,glFormat,glType,mipmap);}else {state.texImage2D(3553,_i38,glInternalFormat,glFormat,glType,mipmap);}}texture.generateMipmaps=false;}else {if(useTexStorage){if(allocateMemory){state.texStorage2D(3553,levels,glInternalFormat,image.width,image.height);}state.texSubImage2D(3553,0,0,0,glFormat,glType,image);}else {state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);}}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(textureType);}source.__currentVersion=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;var forceUpload=initTexture(textureProperties,texture);var source=texture.source;state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);if(source.version!==source.__currentVersion||forceUpload===true){_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);_gl.pixelStorei(37443,0);var isCompressed=texture.isCompressedTexture||texture.image[0].isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=resizeImage(texture.image[i],false,true,maxCubemapSize);}else {cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}cubeImage[i]=verifyColorSpace(texture,cubeImage[i]);}var image=cubeImage[0],supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format,texture.encoding),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);var useTexStorage=isWebGL2&&texture.isVideoTexture!==true;var allocateMemory=source.__currentVersion===undefined||forceUpload===true;var levels=getMipLevels(texture,image,supportsMips);setTextureParameters(34067,texture,supportsMips);var mipmaps;if(isCompressed){if(useTexStorage&&allocateMemory){state.texStorage2D(34067,levels,glInternalFormat,image.width,image.height);}for(var _i39=0;_i39<6;_i39++){mipmaps=cubeImage[_i39].mipmaps;for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];if(texture.format!==RGBAFormat){if(glFormat!==null){if(useTexStorage){state.compressedTexSubImage2D(34069+_i39,j,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data);}else {state.compressedTexImage2D(34069+_i39,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}}else {console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else {if(useTexStorage){state.texSubImage2D(34069+_i39,j,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data);}else {state.texImage2D(34069+_i39,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}}else {mipmaps=texture.mipmaps;if(useTexStorage&&allocateMemory){// TODO: Uniformly handle mipmap definitions
  // Normal textures and compressed cube textures define base level + mips with their mipmap array
  // Uncompressed cube textures use their mipmap array only for mips (no base level)
  if(mipmaps.length>0)levels++;state.texStorage2D(34067,levels,glInternalFormat,cubeImage[0].width,cubeImage[0].height);}for(var _i40=0;_i40<6;_i40++){if(isDataTexture){if(useTexStorage){state.texSubImage2D(34069+_i40,0,0,0,cubeImage[_i40].width,cubeImage[_i40].height,glFormat,glType,cubeImage[_i40].data);}else {state.texImage2D(34069+_i40,0,glInternalFormat,cubeImage[_i40].width,cubeImage[_i40].height,0,glFormat,glType,cubeImage[_i40].data);}for(var _j3=0;_j3<mipmaps.length;_j3++){var _mipmap=mipmaps[_j3];var mipmapImage=_mipmap.image[_i40].image;if(useTexStorage){state.texSubImage2D(34069+_i40,_j3+1,0,0,mipmapImage.width,mipmapImage.height,glFormat,glType,mipmapImage.data);}else {state.texImage2D(34069+_i40,_j3+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}}else {if(useTexStorage){state.texSubImage2D(34069+_i40,0,0,0,glFormat,glType,cubeImage[_i40]);}else {state.texImage2D(34069+_i40,0,glInternalFormat,glFormat,glType,cubeImage[_i40]);}for(var _j4=0;_j4<mipmaps.length;_j4++){var _mipmap2=mipmaps[_j4];if(useTexStorage){state.texSubImage2D(34069+_i40,_j4+1,0,0,glFormat,glType,_mipmap2.image[_i40]);}else {state.texImage2D(34069+_i40,_j4+1,glInternalFormat,glFormat,glType,_mipmap2.image[_i40]);}}}}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){// We assume images for cube map have the same size.
  generateMipmap(34067);}source.__currentVersion=source.version;if(texture.onUpdate)texture.onUpdate(texture);}textureProperties.__version=texture.version;}// Render targets
  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget){var glFormat=utils.convert(texture.format,texture.encoding);var glType=utils.convert(texture.type);var glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);var renderTargetProperties=properties.get(renderTarget);if(!renderTargetProperties.__hasExternalTextures){if(textureTarget===32879||textureTarget===35866){state.texImage3D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,renderTarget.depth,0,glFormat,glType,null);}else {state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);}}state.bindFramebuffer(36160,framebuffer);if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160,attachment,textureTarget,properties.get(texture).__webglTexture,0,getRenderTargetSamples(renderTarget));}else {_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(texture).__webglTexture,0);}state.bindFramebuffer(36160,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(36161,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){var glInternalFormat=33189;if(isMultisample||useMultisampledRTT(renderTarget)){var depthTexture=renderTarget.depthTexture;if(depthTexture&&depthTexture.isDepthTexture){if(depthTexture.type===FloatType){glInternalFormat=36012;}else if(depthTexture.type===UnsignedIntType){glInternalFormat=33190;}}var samples=getRenderTargetSamples(renderTarget);if(useMultisampledRTT(renderTarget)){multisampledRTTExt.renderbufferStorageMultisampleEXT(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}}else {_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){var _samples=getRenderTargetSamples(renderTarget);if(isMultisample&&useMultisampledRTT(renderTarget)===false){_gl.renderbufferStorageMultisample(36161,_samples,35056,renderTarget.width,renderTarget.height);}else if(useMultisampledRTT(renderTarget)){multisampledRTTExt.renderbufferStorageMultisampleEXT(36161,_samples,35056,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);}else {var textures=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture:[renderTarget.texture];for(var i=0;i<textures.length;i++){var texture=textures[i];var glFormat=utils.convert(texture.format,texture.encoding);var glType=utils.convert(texture.type);var _glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);var _samples2=getRenderTargetSamples(renderTarget);if(isMultisample&&useMultisampledRTT(renderTarget)===false){_gl.renderbufferStorageMultisample(36161,_samples2,_glInternalFormat,renderTarget.width,renderTarget.height);}else if(useMultisampledRTT(renderTarget)){multisampledRTTExt.renderbufferStorageMultisampleEXT(36161,_samples2,_glInternalFormat,renderTarget.width,renderTarget.height);}else {_gl.renderbufferStorage(36161,_glInternalFormat,renderTarget.width,renderTarget.height);}}}_gl.bindRenderbuffer(36161,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');state.bindFramebuffer(36160,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
  if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;var samples=getRenderTargetSamples(renderTarget);if(renderTarget.depthTexture.format===DepthFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160,36096,3553,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);}}else if(renderTarget.depthTexture.format===DepthStencilFormat){if(useMultisampledRTT(renderTarget)){multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160,33306,3553,webglDepthTexture,0,samples);}else {_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);}}else {throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLCubeRenderTarget===true;if(renderTarget.depthTexture&&!renderTargetProperties.__autoAllocateDepthBuffer){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else {if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget,false);}}else {state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}}state.bindFramebuffer(36160,null);}// rebind framebuffer with external textures
  function rebindTextures(renderTarget,colorTexture,depthTexture){var renderTargetProperties=properties.get(renderTarget);if(colorTexture!==undefined){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,renderTarget.texture,36064,3553);}if(depthTexture!==undefined){setupDepthRenderbuffer(renderTarget);}}// Set up GL resources for the render target
  function setupRenderTarget(renderTarget){var texture=renderTarget.texture;var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);if(renderTarget.isWebGLMultipleRenderTargets!==true){if(textureProperties.__webglTexture===undefined){textureProperties.__webglTexture=_gl.createTexture();}textureProperties.__version=texture.version;info.memory.textures++;}var isCube=renderTarget.isWebGLCubeRenderTarget===true;var isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===true;var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;// Setup framebuffer
  if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else {renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultipleRenderTargets){if(capabilities.drawBuffers){var textures=renderTarget.texture;for(var _i41=0,il=textures.length;_i41<il;_i41++){var attachmentProperties=properties.get(textures[_i41]);if(attachmentProperties.__webglTexture===undefined){attachmentProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}}else {console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');}}if(isWebGL2&&renderTarget.samples>0&&useMultisampledRTT(renderTarget)===false){var _textures=isMultipleRenderTargets?texture:[texture];renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=[];state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);for(var _i42=0;_i42<_textures.length;_i42++){var _texture=_textures[_i42];renderTargetProperties.__webglColorRenderbuffer[_i42]=_gl.createRenderbuffer();_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer[_i42]);var glFormat=utils.convert(_texture.format,_texture.encoding);var glType=utils.convert(_texture.type);var glInternalFormat=getInternalFormat(_texture.internalFormat,glFormat,glType,_texture.encoding);var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(36160,36064+_i42,36161,renderTargetProperties.__webglColorRenderbuffer[_i42]);}_gl.bindRenderbuffer(36161,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}state.bindFramebuffer(36160,null);}}// Setup color buffer
  if(isCube){state.bindTexture(34067,textureProperties.__webglTexture);setTextureParameters(34067,texture,supportsMips);for(var _i43=0;_i43<6;_i43++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i43],renderTarget,texture,36064,34069+_i43);}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(34067);}state.unbindTexture();}else if(isMultipleRenderTargets){var _textures2=renderTarget.texture;for(var _i44=0,_il11=_textures2.length;_i44<_il11;_i44++){var attachment=_textures2[_i44];var _attachmentProperties=properties.get(attachment);state.bindTexture(3553,_attachmentProperties.__webglTexture);setTextureParameters(3553,attachment,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,36064+_i44,3553);if(textureNeedsGenerateMipmaps(attachment,supportsMips)){generateMipmap(3553);}}state.unbindTexture();}else {var glTextureType=3553;if(renderTarget.isWebGL3DRenderTarget||renderTarget.isWebGLArrayRenderTarget){if(isWebGL2){glTextureType=renderTarget.isWebGL3DRenderTarget?32879:35866;}else {console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');}}state.bindTexture(glTextureType,textureProperties.__webglTexture);setTextureParameters(glTextureType,texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,36064,glTextureType);if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(glTextureType);}state.unbindTexture();}// Setup depth and stencil buffers
  if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;var textures=renderTarget.isWebGLMultipleRenderTargets===true?renderTarget.texture:[renderTarget.texture];for(var i=0,il=textures.length;i<il;i++){var texture=textures[i];if(textureNeedsGenerateMipmaps(texture,supportsMips)){var target=renderTarget.isWebGLCubeRenderTarget?34067:3553;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target);state.unbindTexture();}}}function updateMultisampleRenderTarget(renderTarget){if(isWebGL2&&renderTarget.samples>0&&useMultisampledRTT(renderTarget)===false){var textures=renderTarget.isWebGLMultipleRenderTargets?renderTarget.texture:[renderTarget.texture];var width=renderTarget.width;var height=renderTarget.height;var mask=16384;var invalidationArray=[];var depthStyle=renderTarget.stencilBuffer?33306:36096;var renderTargetProperties=properties.get(renderTarget);var isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===true;// If MRT we need to remove FBO attachments
  if(isMultipleRenderTargets){for(var i=0;i<textures.length;i++){state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064+i,36161,null);state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(36009,36064+i,3553,null,0);}}state.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);for(var _i45=0;_i45<textures.length;_i45++){invalidationArray.push(36064+_i45);if(renderTarget.depthBuffer){invalidationArray.push(depthStyle);}var ignoreDepthValues=renderTargetProperties.__ignoreDepthValues!==undefined?renderTargetProperties.__ignoreDepthValues:false;if(ignoreDepthValues===false){if(renderTarget.depthBuffer)mask|=256;if(renderTarget.stencilBuffer)mask|=1024;}if(isMultipleRenderTargets){_gl.framebufferRenderbuffer(36008,36064,36161,renderTargetProperties.__webglColorRenderbuffer[_i45]);}if(ignoreDepthValues===true){_gl.invalidateFramebuffer(36008,[depthStyle]);_gl.invalidateFramebuffer(36009,[depthStyle]);}if(isMultipleRenderTargets){var webglTexture=properties.get(textures[_i45]).__webglTexture;_gl.framebufferTexture2D(36009,36064,3553,webglTexture,0);}_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);if(supportsInvalidateFramebuffer){_gl.invalidateFramebuffer(36008,invalidationArray);}}state.bindFramebuffer(36008,null);state.bindFramebuffer(36009,null);// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
  if(isMultipleRenderTargets){for(var _i46=0;_i46<textures.length;_i46++){state.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064+_i46,36161,renderTargetProperties.__webglColorRenderbuffer[_i46]);var _webglTexture=properties.get(textures[_i46]).__webglTexture;state.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);_gl.framebufferTexture2D(36009,36064+_i46,3553,_webglTexture,0);}}state.bindFramebuffer(36009,renderTargetProperties.__webglMultisampledFramebuffer);}}function getRenderTargetSamples(renderTarget){return Math.min(maxSamples,renderTarget.samples);}function useMultisampledRTT(renderTarget){var renderTargetProperties=properties.get(renderTarget);return isWebGL2&&renderTarget.samples>0&&extensions.has('WEBGL_multisampled_render_to_texture')===true&&renderTargetProperties.__useRenderToTexture!==false;}function updateVideoTexture(texture){var frame=info.render.frame;// Check the last frame we updated the VideoTexture
  if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}function verifyColorSpace(texture,image){var encoding=texture.encoding;var format=texture.format;var type=texture.type;if(texture.isCompressedTexture===true||texture.isVideoTexture===true||texture.format===_SRGBAFormat)return image;if(encoding!==LinearEncoding){// sRGB
  if(encoding===sRGBEncoding){if(isWebGL2===false){// in WebGL 1, try to use EXT_sRGB extension and unsized formats
  if(extensions.has('EXT_sRGB')===true&&format===RGBAFormat){texture.format=_SRGBAFormat;// it's not possible to generate mips in WebGL 1 with this extension
  texture.minFilter=LinearFilter;texture.generateMipmaps=false;}else {// slow fallback (CPU decode)
  image=ImageUtils.sRGBToLinear(image);}}else {// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
  if(format!==RGBAFormat||type!==UnsignedByteType){console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');}}}else {console.error('THREE.WebGLTextures: Unsupported texture encoding:',encoding);}}return image;}//
  this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.rebindTextures=rebindTextures;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.setupDepthRenderbuffer=setupDepthRenderbuffer;this.setupFrameBufferTexture=setupFrameBufferTexture;this.useMultisampledRTT=useMultisampledRTT;}function WebGLUtils(gl,extensions,capabilities){var isWebGL2=capabilities.isWebGL2;function convert(p){var encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var extension;if(p===UnsignedByteType)return 5121;if(p===UnsignedShort4444Type)return 32819;if(p===UnsignedShort5551Type)return 32820;if(p===ByteType)return 5120;if(p===ShortType)return 5122;if(p===UnsignedShortType)return 5123;if(p===IntType)return 5124;if(p===UnsignedIntType)return 5125;if(p===FloatType)return 5126;if(p===HalfFloatType){if(isWebGL2)return 5131;extension=extensions.get('OES_texture_half_float');if(extension!==null){return extension.HALF_FLOAT_OES;}else {return null;}}if(p===AlphaFormat)return 6406;if(p===RGBAFormat)return 6408;if(p===LuminanceFormat)return 6409;if(p===LuminanceAlphaFormat)return 6410;if(p===DepthFormat)return 6402;if(p===DepthStencilFormat)return 34041;if(p===RedFormat)return 6403;// @deprecated since r137
  if(p===RGBFormat){console.warn('THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228');return 6408;}// WebGL 1 sRGB fallback
  if(p===_SRGBAFormat){extension=extensions.get('EXT_sRGB');if(extension!==null){return extension.SRGB_ALPHA_EXT;}else {return null;}}// WebGL2 formats.
  if(p===RedIntegerFormat)return 36244;if(p===RGFormat)return 33319;if(p===RGIntegerFormat)return 33320;if(p===RGBAIntegerFormat)return 36249;// S3TC
  if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){if(encoding===sRGBEncoding){extension=extensions.get('WEBGL_compressed_texture_s3tc_srgb');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;}else {return null;}}else {extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else {return null;}}}// PVRTC
  if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else {return null;}}// ETC1
  if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null){return extension.COMPRESSED_RGB_ETC1_WEBGL;}else {return null;}}// ETC2
  if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC2_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC;}else {return null;}}// ASTC
  if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){if(p===RGBA_ASTC_4x4_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(p===RGBA_ASTC_5x4_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(p===RGBA_ASTC_5x5_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(p===RGBA_ASTC_6x5_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(p===RGBA_ASTC_6x6_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(p===RGBA_ASTC_8x5_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(p===RGBA_ASTC_8x6_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(p===RGBA_ASTC_8x8_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;if(p===RGBA_ASTC_10x5_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(p===RGBA_ASTC_10x6_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(p===RGBA_ASTC_10x8_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(p===RGBA_ASTC_10x10_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(p===RGBA_ASTC_12x10_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(p===RGBA_ASTC_12x12_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR;}else {return null;}}// BPTC
  if(p===RGBA_BPTC_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){if(p===RGBA_BPTC_Format)return encoding===sRGBEncoding?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;}else {return null;}}//
  if(p===UnsignedInt248Type){if(isWebGL2)return 34042;extension=extensions.get('WEBGL_depth_texture');if(extension!==null){return extension.UNSIGNED_INT_24_8_WEBGL;}else {return null;}}// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
  return gl[p]!==undefined?gl[p]:null;}return {convert:convert};}var ArrayCamera=/*#__PURE__*/function(_PerspectiveCamera){_inherits(ArrayCamera,_PerspectiveCamera);var _super34=_createSuper(ArrayCamera);function ArrayCamera(){var _this26;var array=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];_classCallCheck(this,ArrayCamera);_this26=_super34.call(this);_this26.isArrayCamera=true;_this26.cameras=array;return _this26;}return _createClass(ArrayCamera);}(PerspectiveCamera);var Group=/*#__PURE__*/function(_Object3D4){_inherits(Group,_Object3D4);var _super35=_createSuper(Group);function Group(){var _this27;_classCallCheck(this,Group);_this27=_super35.call(this);_this27.isGroup=true;_this27.type='Group';return _this27;}return _createClass(Group);}(Object3D);var _moveEvent={type:'move'};var WebXRController=/*#__PURE__*/function(){function WebXRController(){_classCallCheck(this,WebXRController);this._targetRay=null;this._grip=null;this._hand=null;}_createClass(WebXRController,[{key:"getHandSpace",value:function getHandSpace(){if(this._hand===null){this._hand=new Group();this._hand.matrixAutoUpdate=false;this._hand.visible=false;this._hand.joints={};this._hand.inputState={pinching:false};}return this._hand;}},{key:"getTargetRaySpace",value:function getTargetRaySpace(){if(this._targetRay===null){this._targetRay=new Group();this._targetRay.matrixAutoUpdate=false;this._targetRay.visible=false;this._targetRay.hasLinearVelocity=false;this._targetRay.linearVelocity=new Vector3();this._targetRay.hasAngularVelocity=false;this._targetRay.angularVelocity=new Vector3();}return this._targetRay;}},{key:"getGripSpace",value:function getGripSpace(){if(this._grip===null){this._grip=new Group();this._grip.matrixAutoUpdate=false;this._grip.visible=false;this._grip.hasLinearVelocity=false;this._grip.linearVelocity=new Vector3();this._grip.hasAngularVelocity=false;this._grip.angularVelocity=new Vector3();}return this._grip;}},{key:"dispatchEvent",value:function dispatchEvent(event){if(this._targetRay!==null){this._targetRay.dispatchEvent(event);}if(this._grip!==null){this._grip.dispatchEvent(event);}if(this._hand!==null){this._hand.dispatchEvent(event);}return this;}},{key:"disconnect",value:function disconnect(inputSource){this.dispatchEvent({type:'disconnected',data:inputSource});if(this._targetRay!==null){this._targetRay.visible=false;}if(this._grip!==null){this._grip.visible=false;}if(this._hand!==null){this._hand.visible=false;}return this;}},{key:"update",value:function update(inputSource,frame,referenceSpace){var inputPose=null;var gripPose=null;var handPose=null;var targetRay=this._targetRay;var grip=this._grip;var hand=this._hand;if(inputSource&&frame.session.visibilityState!=='visible-blurred'){if(hand&&inputSource.hand){handPose=true;var _iterator2=_createForOfIteratorHelper(inputSource.hand.values()),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var inputjoint=_step2.value;// Update the joints groups with the XRJoint poses
  var jointPose=frame.getJointPose(inputjoint,referenceSpace);if(hand.joints[inputjoint.jointName]===undefined){// The transform of this joint will be updated with the joint pose on each frame
  var _joint=new Group();_joint.matrixAutoUpdate=false;_joint.visible=false;hand.joints[inputjoint.jointName]=_joint;// ??
  hand.add(_joint);}var joint=hand.joints[inputjoint.jointName];if(jointPose!==null){joint.matrix.fromArray(jointPose.transform.matrix);joint.matrix.decompose(joint.position,joint.rotation,joint.scale);joint.jointRadius=jointPose.radius;}joint.visible=jointPose!==null;}// Custom events
  // Check pinchz
  }catch(err){_iterator2.e(err);}finally{_iterator2.f();}var indexTip=hand.joints['index-finger-tip'];var thumbTip=hand.joints['thumb-tip'];var distance=indexTip.position.distanceTo(thumbTip.position);var distanceToPinch=0.02;var threshold=0.005;if(hand.inputState.pinching&&distance>distanceToPinch+threshold){hand.inputState.pinching=false;this.dispatchEvent({type:'pinchend',handedness:inputSource.handedness,target:this});}else if(!hand.inputState.pinching&&distance<=distanceToPinch-threshold){hand.inputState.pinching=true;this.dispatchEvent({type:'pinchstart',handedness:inputSource.handedness,target:this});}}else {if(grip!==null&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){grip.matrix.fromArray(gripPose.transform.matrix);grip.matrix.decompose(grip.position,grip.rotation,grip.scale);if(gripPose.linearVelocity){grip.hasLinearVelocity=true;grip.linearVelocity.copy(gripPose.linearVelocity);}else {grip.hasLinearVelocity=false;}if(gripPose.angularVelocity){grip.hasAngularVelocity=true;grip.angularVelocity.copy(gripPose.angularVelocity);}else {grip.hasAngularVelocity=false;}}}}if(targetRay!==null){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
  if(inputPose===null&&gripPose!==null){inputPose=gripPose;}if(inputPose!==null){targetRay.matrix.fromArray(inputPose.transform.matrix);targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale);if(inputPose.linearVelocity){targetRay.hasLinearVelocity=true;targetRay.linearVelocity.copy(inputPose.linearVelocity);}else {targetRay.hasLinearVelocity=false;}if(inputPose.angularVelocity){targetRay.hasAngularVelocity=true;targetRay.angularVelocity.copy(inputPose.angularVelocity);}else {targetRay.hasAngularVelocity=false;}this.dispatchEvent(_moveEvent);}}}if(targetRay!==null){targetRay.visible=inputPose!==null;}if(grip!==null){grip.visible=gripPose!==null;}if(hand!==null){hand.visible=handPose!==null;}return this;}}]);return WebXRController;}();var DepthTexture=/*#__PURE__*/function(_Texture4){_inherits(DepthTexture,_Texture4);var _super36=_createSuper(DepthTexture);function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){var _this28;_classCallCheck(this,DepthTexture);format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedIntType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;_this28=_super36.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);_this28.isDepthTexture=true;_this28.image={width:width,height:height};_this28.magFilter=magFilter!==undefined?magFilter:NearestFilter;_this28.minFilter=minFilter!==undefined?minFilter:NearestFilter;_this28.flipY=false;_this28.generateMipmaps=false;return _this28;}return _createClass(DepthTexture);}(Texture);var WebXRManager=/*#__PURE__*/function(_EventDispatcher6){_inherits(WebXRManager,_EventDispatcher6);var _super37=_createSuper(WebXRManager);function WebXRManager(renderer,gl){var _this29;_classCallCheck(this,WebXRManager);_this29=_super37.call(this);var scope=_assertThisInitialized(_this29);var session=null;var framebufferScaleFactor=1.0;var referenceSpace=null;var referenceSpaceType='local-floor';var customReferenceSpace=null;var pose=null;var glBinding=null;var glProjLayer=null;var glBaseLayer=null;var xrFrame=null;var attributes=gl.getContextAttributes();var initialRenderTarget=null;var newRenderTarget=null;var controllers=[];var controllerInputSources=[];//
  var cameraL=new PerspectiveCamera();cameraL.layers.enable(1);cameraL.viewport=new Vector4();var cameraR=new PerspectiveCamera();cameraR.layers.enable(2);cameraR.viewport=new Vector4();var cameras=[cameraL,cameraR];var cameraVR=new ArrayCamera();cameraVR.layers.enable(1);cameraVR.layers.enable(2);var _currentDepthNear=null;var _currentDepthFar=null;//
  _this29.cameraAutoUpdate=true;_this29.enabled=false;_this29.isPresenting=false;_this29.getController=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getTargetRaySpace();};_this29.getControllerGrip=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getGripSpace();};_this29.getHand=function(index){var controller=controllers[index];if(controller===undefined){controller=new WebXRController();controllers[index]=controller;}return controller.getHandSpace();};//
  function onSessionEvent(event){var controllerIndex=controllerInputSources.indexOf(event.inputSource);if(controllerIndex===-1){return;}var controller=controllers[controllerIndex];if(controller!==undefined){controller.dispatchEvent({type:event.type,data:event.inputSource});}}function onSessionEnd(){session.removeEventListener('select',onSessionEvent);session.removeEventListener('selectstart',onSessionEvent);session.removeEventListener('selectend',onSessionEvent);session.removeEventListener('squeeze',onSessionEvent);session.removeEventListener('squeezestart',onSessionEvent);session.removeEventListener('squeezeend',onSessionEvent);session.removeEventListener('end',onSessionEnd);session.removeEventListener('inputsourceschange',onInputSourcesChange);for(var i=0;i<controllers.length;i++){var inputSource=controllerInputSources[i];if(inputSource===null)continue;controllerInputSources[i]=null;controllers[i].disconnect(inputSource);}_currentDepthNear=null;_currentDepthFar=null;// restore framebuffer/rendering state
  renderer.setRenderTarget(initialRenderTarget);glBaseLayer=null;glProjLayer=null;glBinding=null;session=null;newRenderTarget=null;//
  animation.stop();scope.isPresenting=false;scope.dispatchEvent({type:'sessionend'});}_this29.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');}};_this29.setReferenceSpaceType=function(value){referenceSpaceType=value;if(scope.isPresenting===true){console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');}};_this29.getReferenceSpace=function(){return customReferenceSpace||referenceSpace;};_this29.setReferenceSpace=function(space){customReferenceSpace=space;};_this29.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer;};_this29.getBinding=function(){return glBinding;};_this29.getFrame=function(){return xrFrame;};_this29.getSession=function(){return session;};_this29.setSession=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(value){var layerInit,depthFormat,depthType,glDepthFormat,projectionlayerInit,renderTargetProperties;return _regeneratorRuntime().wrap(function _callee$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:session=value;if(!(session!==null)){_context8.next=25;break;}initialRenderTarget=renderer.getRenderTarget();session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);session.addEventListener('inputsourceschange',onInputSourcesChange);if(!(attributes.xrCompatible!==true)){_context8.next=14;break;}_context8.next=14;return gl.makeXRCompatible();case 14:if(session.renderState.layers===undefined||renderer.capabilities.isWebGL2===false){layerInit={antialias:session.renderState.layers===undefined?attributes.antialias:true,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:glBaseLayer});newRenderTarget=new WebGLRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,encoding:renderer.outputEncoding,stencilBuffer:attributes.stencil});}else {depthFormat=null;depthType=null;glDepthFormat=null;if(attributes.depth){glDepthFormat=attributes.stencil?35056:33190;depthFormat=attributes.stencil?DepthStencilFormat:DepthFormat;depthType=attributes.stencil?UnsignedInt248Type:UnsignedIntType;}projectionlayerInit={colorFormat:32856,depthFormat:glDepthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(projectionlayerInit);session.updateRenderState({layers:[glProjLayer]});newRenderTarget=new WebGLRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,undefined,undefined,undefined,undefined,undefined,undefined,depthFormat),stencilBuffer:attributes.stencil,encoding:renderer.outputEncoding,samples:attributes.antialias?4:0});renderTargetProperties=renderer.properties.get(newRenderTarget);renderTargetProperties.__ignoreDepthValues=glProjLayer.ignoreDepthValues;}newRenderTarget.isXRRenderTarget=true;// TODO Remove this when possible, see #23278
  // Set foveation to maximum.
  this.setFoveation(1.0);customReferenceSpace=null;_context8.next=20;return session.requestReferenceSpace(referenceSpaceType);case 20:referenceSpace=_context8.sent;animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});case 25:case"end":return _context8.stop();}}},_callee,this);}));return function(_x3){return _ref.apply(this,arguments);};}();function onInputSourcesChange(event){// Notify disconnected
  for(var i=0;i<event.removed.length;i++){var inputSource=event.removed[i];var index=controllerInputSources.indexOf(inputSource);if(index>=0){controllerInputSources[index]=null;controllers[index].dispatchEvent({type:'disconnected',data:inputSource});}}// Notify connected
  for(var _i47=0;_i47<event.added.length;_i47++){var _inputSource=event.added[_i47];var controllerIndex=controllerInputSources.indexOf(_inputSource);if(controllerIndex===-1){// Assign input source a controller that currently has no input source
  for(var _i48=0;_i48<controllers.length;_i48++){if(_i48>=controllerInputSources.length){controllerInputSources.push(_inputSource);controllerIndex=_i48;break;}else if(controllerInputSources[_i48]===null){controllerInputSources[_i48]=_inputSource;controllerIndex=_i48;break;}}// If all controllers do currently receive input we ignore new ones
  if(controllerIndex===-1)break;}var controller=controllers[controllerIndex];if(controller){controller.dispatchEvent({type:'connected',data:_inputSource});}}}//
  var cameraLPos=new Vector3();var cameraRPos=new Vector3();/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);var ipd=cameraLPos.distanceTo(cameraRPos);var projL=cameraL.projectionMatrix.elements;var projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
  // most likely identical top and bottom frustum extents.
  // Use the left camera for these values.
  var near=projL[14]/(projL[10]-1);var far=projL[14]/(projL[10]+1);var topFov=(projL[9]+1)/projL[5];var bottomFov=(projL[9]-1)/projL[5];var leftFov=(projL[8]-1)/projL[0];var rightFov=(projR[8]+1)/projR[0];var left=near*leftFov;var right=near*rightFov;// Calculate the new camera's position offset from the
  // left camera. xOffset should be roughly half `ipd`.
  var zOffset=ipd/(-leftFov+rightFov);var xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
  cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.copy(camera.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
  // the values so that the near plane's position does not change in world space,
  // although must now be relative to the new union camera.
  var near2=near+zOffset;var far2=far+zOffset;var left2=left-xOffset;var right2=right+(ipd-xOffset);var top2=topFov*far/far2*near2;var bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else {camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.copy(camera.matrixWorld).invert();}_this29.updateCamera=function(camera){if(session===null)return;cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far){// Note that the new renderState won't apply until the next frame. See #18320
  session.updateRenderState({depthNear:cameraVR.near,depthFar:cameraVR.far});_currentDepthNear=cameraVR.near;_currentDepthFar=cameraVR.far;}var parent=camera.parent;var cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(var i=0;i<cameras.length;i++){updateCamera(cameras[i],parent);}cameraVR.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);// update user camera and its children
  camera.matrix.copy(cameraVR.matrix);camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);var children=camera.children;for(var _i49=0,l=children.length;_i49<l;_i49++){children[_i49].updateMatrixWorld(true);}// update projection matrix for proper view frustum culling
  if(cameras.length===2){setProjectionFromUnion(cameraVR,cameraL,cameraR);}else {// assume single camera setup (AR)
  cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);}};_this29.getCamera=function(){return cameraVR;};_this29.getFoveation=function(){if(glProjLayer!==null){return glProjLayer.fixedFoveation;}if(glBaseLayer!==null){return glBaseLayer.fixedFoveation;}return undefined;};_this29.setFoveation=function(foveation){// 0 = no foveation = full resolution
  // 1 = maximum foveation = the edges render at lower resolution
  if(glProjLayer!==null){glProjLayer.fixedFoveation=foveation;}if(glBaseLayer!==null&&glBaseLayer.fixedFoveation!==undefined){glBaseLayer.fixedFoveation=foveation;}};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(customReferenceSpace||referenceSpace);xrFrame=frame;if(pose!==null){var views=pose.views;if(glBaseLayer!==null){renderer.setRenderTargetFramebuffer(newRenderTarget,glBaseLayer.framebuffer);renderer.setRenderTarget(newRenderTarget);}var cameraVRNeedsUpdate=false;// check if it's necessary to rebuild cameraVR's camera list
  if(views.length!==cameraVR.cameras.length){cameraVR.cameras.length=0;cameraVRNeedsUpdate=true;}for(var i=0;i<views.length;i++){var view=views[i];var viewport=null;if(glBaseLayer!==null){viewport=glBaseLayer.getViewport(view);}else {var glSubImage=glBinding.getViewSubImage(glProjLayer,view);viewport=glSubImage.viewport;// For side-by-side projection, we only produce a single texture for both eyes.
  if(i===0){renderer.setRenderTargetTextures(newRenderTarget,glSubImage.colorTexture,glProjLayer.ignoreDepthValues?undefined:glSubImage.depthStencilTexture);renderer.setRenderTarget(newRenderTarget);}}var camera=cameras[i];if(camera===undefined){camera=new PerspectiveCamera();camera.layers.enable(i);camera.viewport=new Vector4();cameras[i]=camera;}camera.matrix.fromArray(view.transform.matrix);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(i===0){cameraVR.matrix.copy(camera.matrix);}if(cameraVRNeedsUpdate===true){cameraVR.cameras.push(camera);}}}//
  for(var _i50=0;_i50<controllers.length;_i50++){var inputSource=controllerInputSources[_i50];var controller=controllers[_i50];if(inputSource!==null&&controller!==undefined){controller.update(inputSource,frame,customReferenceSpace||referenceSpace);}}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);xrFrame=null;}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);_this29.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};_this29.dispose=function(){};return _this29;}return _createClass(WebXRManager);}(EventDispatcher);function WebGLMaterials(renderer,properties){function refreshFogUniforms(uniforms,fog){uniforms.fogColor.value.copy(fog.color);if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsToon(uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsPhong(uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsStandard(uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(uniforms,material,transmissionRenderTarget);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsMatcap(uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(uniforms,material);refreshUniformsDistance(uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(uniforms,material,pixelRatio,height);}else if(material.isSpriteMaterial){refreshUniformsSprites(uniforms,material);}else if(material.isShadowMaterial){uniforms.color.value.copy(material.color);uniforms.opacity.value=material.opacity;}else if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
  }}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}var envMap=properties.get(material).envMap;if(envMap){uniforms.envMap.value=envMap;uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.ior.value=material.ior;uniforms.refractionRatio.value=material.refractionRatio;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;// artist-friendly light intensity scaling factor
  var scaleFactor=renderer.physicallyCorrectLights!==true?Math.PI:1;uniforms.lightMapIntensity.value=material.lightMapIntensity*scaleFactor;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. specular map
  // 3. displacementMap map
  // 4. normal map
  // 5. bump map
  // 6. roughnessMap map
  // 7. metalnessMap map
  // 8. alphaMap map
  // 9. emissiveMap map
  // 10. clearcoat map
  // 11. clearcoat normal map
  // 12. clearcoat roughnessMap map
  // 13. iridescence map
  // 14. iridescence thickness map
  // 15. specular intensity map
  // 16. specular tint map
  // 17. transmission map
  // 18. thickness map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}else if(material.clearcoatMap){uvScaleMap=material.clearcoatMap;}else if(material.clearcoatNormalMap){uvScaleMap=material.clearcoatNormalMap;}else if(material.clearcoatRoughnessMap){uvScaleMap=material.clearcoatRoughnessMap;}else if(material.iridescenceMap){uvScaleMap=material.iridescenceMap;}else if(material.iridescenceThicknessMap){uvScaleMap=material.iridescenceThicknessMap;}else if(material.specularIntensityMap){uvScaleMap=material.specularIntensityMap;}else if(material.specularColorMap){uvScaleMap=material.specularColorMap;}else if(material.transmissionMap){uvScaleMap=material.transmissionMap;}else if(material.thicknessMap){uvScaleMap=material.thicknessMap;}else if(material.sheenColorMap){uvScaleMap=material.sheenColorMap;}else if(material.sheenRoughnessMap){uvScaleMap=material.sheenRoughnessMap;}if(uvScaleMap!==undefined){// backwards compatibility
  if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}// uv repeat and offset setting priorities for uv2
  // 1. ao map
  // 2. light map
  var uv2ScaleMap;if(material.aoMap){uv2ScaleMap=material.aoMap;}else if(material.lightMap){uv2ScaleMap=material.lightMap;}if(uv2ScaleMap!==undefined){// backwards compatibility
  if(uv2ScaleMap.isWebGLRenderTarget){uv2ScaleMap=uv2ScaleMap.texture;}if(uv2ScaleMap.matrixAutoUpdate===true){uv2ScaleMap.updateMatrix();}uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=height*0.5;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.alphaTest>0){uniforms.alphaTest.value=material.alphaTest;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. alpha map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
  }function refreshUniformsToon(uniforms,material){if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}var envMap=properties.get(material).envMap;if(envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
  uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){uniforms.ior.value=material.ior;// also part of uniforms common
  if(material.sheen>0){uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);uniforms.sheenRoughness.value=material.sheenRoughness;if(material.sheenColorMap){uniforms.sheenColorMap.value=material.sheenColorMap;}if(material.sheenRoughnessMap){uniforms.sheenRoughnessMap.value=material.sheenRoughnessMap;}}if(material.clearcoat>0){uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;}if(material.clearcoatNormalMap){uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}}if(material.iridescence>0){uniforms.iridescence.value=material.iridescence;uniforms.iridescenceIOR.value=material.iridescenceIOR;uniforms.iridescenceThicknessMinimum.value=material.iridescenceThicknessRange[0];uniforms.iridescenceThicknessMaximum.value=material.iridescenceThicknessRange[1];if(material.iridescenceMap){uniforms.iridescenceMap.value=material.iridescenceMap;}if(material.iridescenceThicknessMap){uniforms.iridescenceThicknessMap.value=material.iridescenceThicknessMap;}}if(material.transmission>0){uniforms.transmission.value=material.transmission;uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture;uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height);if(material.transmissionMap){uniforms.transmissionMap.value=material.transmissionMap;}uniforms.thickness.value=material.thickness;if(material.thicknessMap){uniforms.thicknessMap.value=material.thicknessMap;}uniforms.attenuationDistance.value=material.attenuationDistance;uniforms.attenuationColor.value.copy(material.attenuationColor);}uniforms.specularIntensity.value=material.specularIntensity;uniforms.specularColor.value.copy(material.specularColor);if(material.specularIntensityMap){uniforms.specularIntensityMap.value=material.specularIntensityMap;}if(material.specularColorMap){uniforms.specularColorMap.value=material.specularColorMap;}}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}}function refreshUniformsDistance(uniforms,material){uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}return {refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms};}function WebGLUniformsGroups(gl,info,capabilities,state){var buffers={};var updateList={};var allocatedBindingPoints=[];var maxBindingPoints=capabilities.isWebGL2?gl.getParameter(35375):0;// binding points are global whereas block indices are per shader program
  function bind(uniformsGroup,program){var webglProgram=program.program;state.uniformBlockBinding(uniformsGroup,webglProgram);}function update(uniformsGroup,program){var buffer=buffers[uniformsGroup.id];if(buffer===undefined){prepareUniformsGroup(uniformsGroup);buffer=createBuffer(uniformsGroup);buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener('dispose',onUniformsGroupsDispose);}// ensure to update the binding points/block indices mapping for this program
  var webglProgram=program.program;state.updateUBOMapping(uniformsGroup,webglProgram);// update UBO once per frame
  var frame=info.render.frame;if(updateList[uniformsGroup.id]!==frame){updateBufferData(uniformsGroup);updateList[uniformsGroup.id]=frame;}}function createBuffer(uniformsGroup){// the setup of an UBO is independent of a particular shader program but global
  var bindingPointIndex=allocateBindingPointIndex();uniformsGroup.__bindingPointIndex=bindingPointIndex;var buffer=gl.createBuffer();var size=uniformsGroup.__size;var usage=uniformsGroup.usage;gl.bindBuffer(35345,buffer);gl.bufferData(35345,size,usage);gl.bindBuffer(35345,null);gl.bindBufferBase(35345,bindingPointIndex,buffer);return buffer;}function allocateBindingPointIndex(){for(var i=0;i<maxBindingPoints;i++){if(allocatedBindingPoints.indexOf(i)===-1){allocatedBindingPoints.push(i);return i;}}console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');return 0;}function updateBufferData(uniformsGroup){var buffer=buffers[uniformsGroup.id];var uniforms=uniformsGroup.uniforms;var cache=uniformsGroup.__cache;gl.bindBuffer(35345,buffer);for(var i=0,il=uniforms.length;i<il;i++){var uniform=uniforms[i];// partly update the buffer if necessary
  if(hasUniformChanged(uniform,i,cache)===true){var _value5=uniform.value;var offset=uniform.__offset;if(typeof _value5==='number'){uniform.__data[0]=_value5;gl.bufferSubData(35345,offset,uniform.__data);}else {if(uniform.value.isMatrix3){// manually converting 3x3 to 3x4
  uniform.__data[0]=uniform.value.elements[0];uniform.__data[1]=uniform.value.elements[1];uniform.__data[2]=uniform.value.elements[2];uniform.__data[3]=uniform.value.elements[0];uniform.__data[4]=uniform.value.elements[3];uniform.__data[5]=uniform.value.elements[4];uniform.__data[6]=uniform.value.elements[5];uniform.__data[7]=uniform.value.elements[0];uniform.__data[8]=uniform.value.elements[6];uniform.__data[9]=uniform.value.elements[7];uniform.__data[10]=uniform.value.elements[8];uniform.__data[11]=uniform.value.elements[0];}else {_value5.toArray(uniform.__data);}gl.bufferSubData(35345,offset,uniform.__data);}}}gl.bindBuffer(35345,null);}function hasUniformChanged(uniform,index,cache){var value=uniform.value;if(cache[index]===undefined){// cache entry does not exist so far
  if(typeof value==='number'){cache[index]=value;}else {cache[index]=value.clone();}return true;}else {// compare current value with cached entry
  if(typeof value==='number'){if(cache[index]!==value){cache[index]=value;return true;}}else {var cachedObject=cache[index];if(cachedObject.equals(value)===false){cachedObject.copy(value);return true;}}}return false;}function prepareUniformsGroup(uniformsGroup){// determine total buffer size according to the STD140 layout
  // Hint: STD140 is the only supported layout in WebGL 2
  var uniforms=uniformsGroup.uniforms;var offset=0;// global buffer offset in bytes
  var chunkSize=16;// size of a chunk in bytes
  var chunkOffset=0;// offset within a single chunk in bytes
  for(var i=0,l=uniforms.length;i<l;i++){var uniform=uniforms[i];var _info=getUniformSize(uniform);// the following two properties will be used for partial buffer updates
  uniform.__data=new Float32Array(_info.storage/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;//
  if(i>0){chunkOffset=offset%chunkSize;var remainingSizeInChunk=chunkSize-chunkOffset;// check for chunk overflow
  if(chunkOffset!==0&&remainingSizeInChunk-_info.boundary<0){// add padding and adjust offset
  offset+=chunkSize-chunkOffset;uniform.__offset=offset;}}offset+=_info.storage;}// ensure correct final padding
  chunkOffset=offset%chunkSize;if(chunkOffset>0)offset+=chunkSize-chunkOffset;//
  uniformsGroup.__size=offset;uniformsGroup.__cache={};return this;}function getUniformSize(uniform){var value=uniform.value;var info={boundary:0,// bytes
  storage:0// bytes
  };// determine sizes according to STD140
  if(typeof value==='number'){// float/int
  info.boundary=4;info.storage=4;}else if(value.isVector2){// vec2
  info.boundary=8;info.storage=8;}else if(value.isVector3||value.isColor){// vec3
  info.boundary=16;info.storage=12;// evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes
  }else if(value.isVector4){// vec4
  info.boundary=16;info.storage=16;}else if(value.isMatrix3){// mat3 (in STD140 a 3x3 matrix is represented as 3x4)
  info.boundary=48;info.storage=48;}else if(value.isMatrix4){// mat4
  info.boundary=64;info.storage=64;}else if(value.isTexture){console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.');}else {console.warn('THREE.WebGLRenderer: Unsupported uniform value type.',value);}return info;}function onUniformsGroupsDispose(event){var uniformsGroup=event.target;uniformsGroup.removeEventListener('dispose',onUniformsGroupsDispose);var index=allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);allocatedBindingPoints.splice(index,1);gl.deleteBuffer(buffers[uniformsGroup.id]);delete buffers[uniformsGroup.id];delete updateList[uniformsGroup.id];}function dispose(){for(var _id3 in buffers){gl.deleteBuffer(buffers[_id3]);}allocatedBindingPoints=[];buffers={};updateList={};}return {bind:bind,update:update,dispose:dispose};}function createCanvasElement(){var canvas=createElementNS('canvas');canvas.style.display='block';return canvas;}function WebGLRenderer(){var parameters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.isWebGLRenderer=true;var _canvas=parameters.canvas!==undefined?parameters.canvas:createCanvasElement(),_context=parameters.context!==undefined?parameters.context:null,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;var _alpha;if(_context!==null){_alpha=_context.getContextAttributes().alpha;}else {_alpha=parameters.alpha!==undefined?parameters.alpha:false;}var currentRenderList=null;var currentRenderState=null;// render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its list and state isolated from the parent render call.
  var renderListStack=[];var renderStateStack=[];// public properties
  this.domElement=_canvas;// Debug configuration container
  this.debug={/**
  		 * Enables error checking and reporting when shader programs are being compiled
  		 * @type {boolean}
  		 */checkShaderErrors:true};// clearing
  this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
  this.sortObjects=true;// user-defined clipping
  this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
  this.outputEncoding=LinearEncoding;// physical lights
  this.physicallyCorrectLights=false;// tone mapping
  this.toneMapping=NoToneMapping;this.toneMappingExposure=1.0;//
  Object.defineProperties(this,{// @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d
  gammaFactor:{get:function get(){console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');return 2;},set:function set(){console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');}}});// internal properties
  var _this=this;var _isContextLost=false;// internal state cache
  var _currentActiveCubeFace=0;var _currentActiveMipmapLevel=0;var _currentRenderTarget=null;var _currentMaterialId=-1;var _currentCamera=null;var _currentViewport=new Vector4();var _currentScissor=new Vector4();var _currentScissorTest=null;//
  var _width=_canvas.width;var _height=_canvas.height;var _pixelRatio=1;var _opaqueSort=null;var _transparentSort=null;var _viewport=new Vector4(0,0,_width,_height);var _scissor=new Vector4(0,0,_width,_height);var _scissorTest=false;// frustum
  var _frustum=new Frustum();// clipping
  var _clippingEnabled=false;var _localClippingEnabled=false;// transmission
  var _transmissionRenderTarget=null;// camera matrices cache
  var _projScreenMatrix=new Matrix4();var _vector2=new Vector2();var _vector3=new Vector3();var _emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:true};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
  var _gl=_context;function getContext(contextNames,contextAttributes){for(var i=0;i<contextNames.length;i++){var contextName=contextNames[i];var context=_canvas.getContext(contextName,contextAttributes);if(context!==null)return context;}return null;}try{var contextAttributes={alpha:true,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat};// OffscreenCanvas does not have setAttribute, see #22811
  if('setAttribute'in _canvas)_canvas.setAttribute('data-engine',"three.js r".concat(REVISION));// event listeners must be registered before WebGL context is created, see #12753
  _canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);_canvas.addEventListener('webglcontextcreationerror',onContextCreationError,false);if(_gl===null){var contextNames=['webgl2','webgl','experimental-webgl'];if(_this.isWebGL1Renderer===true){contextNames.shift();}_gl=getContext(contextNames,contextAttributes);if(_gl===null){if(getContext(contextNames)){throw new Error('Error creating WebGL context with your selected attributes.');}else {throw new Error('Error creating WebGL context.');}}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
  if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return {'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}var extensions,capabilities,state,info;var properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects;var programCache,materials,renderLists,renderStates,clipping,shadowMap;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var utils,bindingStates,uniformsGroups;function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters);extensions.init(capabilities);utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);info=new WebGLInfo();properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl,capabilities);bindingStates=new WebGLBindingStates(_gl,extensions,attributes,capabilities);geometries=new WebGLGeometries(_gl,attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(_this,properties);renderLists=new WebGLRenderLists();renderStates=new WebGLRenderStates(extensions,capabilities);background=new WebGLBackground(_this,cubemaps,state,objects,_alpha,_premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);uniformsGroups=new WebGLUniformsGroups(_gl,info,capabilities,state);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=state;_this.info=info;}initGLContext();// xr
  var xr=new WebXRManager(_this,_gl);this.xr=xr;// API
  this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){return target.set(_width,_height);};this.setSize=function(width,height,updateStyle){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=Math.floor(width*_pixelRatio);_canvas.height=Math.floor(height*_pixelRatio);if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else {_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else {_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(_boolean){state.setScissorTest(_scissorTest=_boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
  this.getClearColor=function(target){return target.copy(background.getClearColor());};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(){var color=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;var depth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var stencil=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var bits=0;if(color)bits|=16384;if(depth)bits|=256;if(stencil)bits|=1024;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
  this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);_canvas.removeEventListener('webglcontextcreationerror',onContextCreationError,false);renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();uniformsGroups.dispose();programCache.dispose();xr.dispose();xr.removeEventListener('sessionstart',onXRSessionStart);xr.removeEventListener('sessionend',onXRSessionEnd);if(_transmissionRenderTarget){_transmissionRenderTarget.dispose();_transmissionRenderTarget=null;}animation.stop();};// Events
  function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function/* event */onContextRestore(){console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;var infoAutoReset=info.autoReset;var shadowMapEnabled=shadowMap.enabled;var shadowMapAutoUpdate=shadowMap.autoUpdate;var shadowMapNeedsUpdate=shadowMap.needsUpdate;var shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType;}function onContextCreationError(event){console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',event.statusMessage);}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
  function deallocateMaterial(material){releaseMaterialProgramReferences(material);properties.remove(material);}function releaseMaterialProgramReferences(material){var programs=properties.get(material).programs;if(programs!==undefined){programs.forEach(function(program){programCache.releaseProgram(program);});if(material.isShaderMaterial){programCache.releaseShaderCache(material);}}}// Buffer rendering
  this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=_emptyScene;// renderBufferDirect second parameter used to be fog (could be null)
  var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;var program=setProgram(camera,scene,geometry,material,object);state.setMaterial(material,frontFaceCW);//
  var index=geometry.index;var position=geometry.attributes.position;//
  if(index===null){if(position===undefined||position.count===0)return;}else if(index.count===0){return;}//
  var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}bindingStates.setup(object,material,program,geometry,index);var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}//
  var dataCount=index!==null?index.count:position.count;var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
  if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(1);}else {renderer.setMode(4);}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
  state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(1);}else if(object.isLineLoop){renderer.setMode(2);}else {renderer.setMode(3);}}else if(object.isPoints){renderer.setMode(0);}else if(object.isSprite){renderer.setMode(4);}if(object.isInstancedMesh){renderer.renderInstances(drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){var instanceCount=Math.min(geometry.instanceCount,geometry._maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount);}else {renderer.render(drawStart,drawCount);}};// Compile
  this.compile=function(scene,camera){function prepare(material,scene,object){if(material.transparent===true&&material.side===DoubleSide){material.side=BackSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=FrontSide;material.needsUpdate=true;getProgram(material,scene,object);material.side=DoubleSide;}else {getProgram(material,scene,object);}}currentRenderState=renderStates.get(scene);currentRenderState.init();renderStateStack.push(currentRenderState);scene.traverseVisible(function(object){if(object.isLight&&object.layers.test(camera.layers)){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights(_this.physicallyCorrectLights);scene.traverse(function(object){var material=object.material;if(material){if(Array.isArray(material)){for(var i=0;i<material.length;i++){var material2=material[i];prepare(material2,scene,object);}}else {prepare(material,scene,object);}}});renderStateStack.pop();currentRenderState=null;};// Animation Loop
  var onAnimationFrameCallback=null;function onAnimationFrame(time){if(onAnimationFrameCallback)onAnimationFrameCallback(time);}function onXRSessionStart(){animation.stop();}function onXRSessionEnd(){animation.start();}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof self!=='undefined')animation.setContext(self);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);callback===null?animation.stop():animation.start();};xr.addEventListener('sessionstart',onXRSessionStart);xr.addEventListener('sessionend',onXRSessionEnd);// Rendering
  this.render=function(scene,camera){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost===true)return;// update scene graph
  if(scene.matrixWorldAutoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
  if(camera.parent===null&&camera.matrixWorldAutoUpdate===true)camera.updateMatrixWorld();if(xr.enabled===true&&xr.isPresenting===true){if(xr.cameraAutoUpdate===true)xr.updateCamera(camera);camera=xr.getCamera();// use XR camera for rendering
  }//
  if(scene.isScene===true)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init();renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}//
  if(_clippingEnabled===true)clipping.beginShadows();var shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);if(_clippingEnabled===true)clipping.endShadows();//
  if(this.info.autoReset===true)this.info.reset();//
  background.render(currentRenderList,scene);// render scene
  currentRenderState.setupLights(_this.physicallyCorrectLights);if(camera.isArrayCamera){var cameras=camera.cameras;for(var i=0,l=cameras.length;i<l;i++){var camera2=cameras[i];renderScene(currentRenderList,scene,camera2,camera2.viewport);}}else {renderScene(currentRenderList,scene,camera);}//
  if(_currentRenderTarget!==null){// resolve multisample renderbuffers to a single-sample texture if necessary
  textures.updateMultisampleRenderTarget(_currentRenderTarget);// Generate mipmap if we're using any kind of mipmap filtering
  textures.updateRenderTargetMipmap(_currentRenderTarget);}//
  if(scene.isScene===true)scene.onAfterRender(_this,scene,camera);// _gl.finish();
  bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();if(renderStateStack.length>0){currentRenderState=renderStateStack[renderStateStack.length-1];}else {currentRenderState=null;}renderListStack.pop();if(renderListStack.length>0){currentRenderList=renderListStack[renderListStack.length-1];}else {currentRenderList=null;}};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){// update skeleton only once in a frame
  if(object.skeleton.frame!==info.render.frame){object.skeleton.update();object.skeleton.frame=info.render.frame;}}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var _geometry2=objects.update(object);var _material=object.material;if(Array.isArray(_material)){var groups=_geometry2.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=_material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,_geometry2,groupMaterial,groupOrder,_vector3.z,group);}}}else if(_material.visible){currentRenderList.push(object,_geometry2,_material,groupOrder,_vector3.z,null);}}}}var children=object.children;for(var _i51=0,_l6=children.length;_i51<_l6;_i51++){projectObject(children[_i51],camera,groupOrder,sortObjects);}}function renderScene(currentRenderList,scene,camera,viewport){var opaqueObjects=currentRenderList.opaque;var transmissiveObjects=currentRenderList.transmissive;var transparentObjects=currentRenderList.transparent;currentRenderState.setupLightsView(camera);if(transmissiveObjects.length>0)renderTransmissionPass(opaqueObjects,scene,camera);if(viewport)state.viewport(_currentViewport.copy(viewport));if(opaqueObjects.length>0)renderObjects(opaqueObjects,scene,camera);if(transmissiveObjects.length>0)renderObjects(transmissiveObjects,scene,camera);if(transparentObjects.length>0)renderObjects(transparentObjects,scene,camera);// Ensure depth buffer writing is enabled so it can be cleared on next render
  state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);}function renderTransmissionPass(opaqueObjects,scene,camera){var isWebGL2=capabilities.isWebGL2;if(_transmissionRenderTarget===null){_transmissionRenderTarget=new WebGLRenderTarget(1,1,{generateMipmaps:true,type:extensions.has('EXT_color_buffer_half_float')?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:isWebGL2&&_antialias===true?4:0});}_this.getDrawingBufferSize(_vector2);if(isWebGL2){_transmissionRenderTarget.setSize(_vector2.x,_vector2.y);}else {_transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x),floorPowerOfTwo(_vector2.y));}//
  var currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(_transmissionRenderTarget);_this.clear();// Turn off the features which can affect the frag color for opaque objects pass.
  // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
  var currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping;renderObjects(opaqueObjects,scene,camera);_this.toneMapping=currentToneMapping;textures.updateMultisampleRenderTarget(_transmissionRenderTarget);textures.updateRenderTargetMipmap(_transmissionRenderTarget);_this.setRenderTarget(currentRenderTarget);}function renderObjects(renderList,scene,camera){var overrideMaterial=scene.isScene===true?scene.overrideMaterial:null;for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===null?renderItem.material:overrideMaterial;var group=renderItem.group;if(object.layers.test(camera.layers)){renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,scene,camera,geometry,object,group);if(material.transparent===true&&material.side===DoubleSide){material.side=BackSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=FrontSide;material.needsUpdate=true;_this.renderBufferDirect(camera,scene,geometry,material,object,group);material.side=DoubleSide;}else {_this.renderBufferDirect(camera,scene,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}function getProgram(material,scene,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;var shadowsArray=currentRenderState.state.shadowsArray;var lightsStateVersion=lights.state.version;var parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,object);var programCacheKey=programCache.getProgramCacheKey(parameters);var programs=materialProperties.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
  materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment);if(programs===undefined){// new material
  material.addEventListener('dispose',onMaterialDispose);programs=new Map();materialProperties.programs=programs;}var program=programs.get(programCacheKey);if(program!==undefined){// early out if program and light state is identical
  if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion){updateCommonMaterialProperties(material,parameters);return program;}}else {parameters.uniforms=programCache.getUniforms(material);material.onBuild(object,parameters,_this);material.onBeforeCompile(parameters,_this);program=programCache.acquireProgram(parameters,programCacheKey);programs.set(programCacheKey,program);materialProperties.uniforms=parameters.uniforms;}var uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){uniforms.clippingPlanes=clipping.uniform;}updateCommonMaterialProperties(material,parameters);// store the light setup it was created for
  materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
  uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.ltc_1.value=lights.state.rectAreaLTC1;uniforms.ltc_2.value=lights.state.rectAreaLTC2;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotLightMatrix.value=lights.state.spotLightMatrix;uniforms.spotLightMap.value=lights.state.spotLightMap;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
  }var progUniforms=program.getUniforms();var uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.currentProgram=program;materialProperties.uniformsList=uniformsList;return program;}function updateCommonMaterialProperties(material,parameters){var materialProperties=properties.get(material);materialProperties.outputEncoding=parameters.outputEncoding;materialProperties.instancing=parameters.instancing;materialProperties.skinning=parameters.skinning;materialProperties.morphTargets=parameters.morphTargets;materialProperties.morphNormals=parameters.morphNormals;materialProperties.morphColors=parameters.morphColors;materialProperties.morphTargetsCount=parameters.morphTargetsCount;materialProperties.numClippingPlanes=parameters.numClippingPlanes;materialProperties.numIntersection=parameters.numClipIntersection;materialProperties.vertexAlphas=parameters.vertexAlphas;materialProperties.vertexTangents=parameters.vertexTangents;materialProperties.toneMapping=parameters.toneMapping;}function setProgram(camera,scene,geometry,material,object){if(scene.isScene!==true)scene=_emptyScene;// scene could be a Mesh, Line, Points, ...
  textures.resetTextureUnits();var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var encoding=_currentRenderTarget===null?_this.outputEncoding:_currentRenderTarget.isXRRenderTarget===true?_currentRenderTarget.texture.encoding:LinearEncoding;var envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var vertexAlphas=material.vertexColors===true&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4;var vertexTangents=!!material.normalMap&&!!geometry.attributes.tangent;var morphTargets=!!geometry.morphAttributes.position;var morphNormals=!!geometry.morphAttributes.normal;var morphColors=!!geometry.morphAttributes.color;var toneMapping=material.toneMapped?_this.toneMapping:NoToneMapping;var morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;var morphTargetsCount=morphAttribute!==undefined?morphAttribute.length:0;var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;if(_clippingEnabled===true){if(_localClippingEnabled===true||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
  // object instead of the material, once it becomes feasible
  // (#8465, #8379)
  clipping.setState(material,camera,useCache);}}//
  var needsProgramChange=false;if(material.version===materialProperties.__version){if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){needsProgramChange=true;}else if(materialProperties.outputEncoding!==encoding){needsProgramChange=true;}else if(object.isInstancedMesh&&materialProperties.instancing===false){needsProgramChange=true;}else if(!object.isInstancedMesh&&materialProperties.instancing===true){needsProgramChange=true;}else if(object.isSkinnedMesh&&materialProperties.skinning===false){needsProgramChange=true;}else if(!object.isSkinnedMesh&&materialProperties.skinning===true){needsProgramChange=true;}else if(materialProperties.envMap!==envMap){needsProgramChange=true;}else if(material.fog===true&&materialProperties.fog!==fog){needsProgramChange=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)){needsProgramChange=true;}else if(materialProperties.vertexAlphas!==vertexAlphas){needsProgramChange=true;}else if(materialProperties.vertexTangents!==vertexTangents){needsProgramChange=true;}else if(materialProperties.morphTargets!==morphTargets){needsProgramChange=true;}else if(materialProperties.morphNormals!==morphNormals){needsProgramChange=true;}else if(materialProperties.morphColors!==morphColors){needsProgramChange=true;}else if(materialProperties.toneMapping!==toneMapping){needsProgramChange=true;}else if(capabilities.isWebGL2===true&&materialProperties.morphTargetsCount!==morphTargetsCount){needsProgramChange=true;}}else {needsProgramChange=true;materialProperties.__version=material.version;}//
  var program=materialProperties.currentProgram;if(needsProgramChange===true){program=getProgram(material,scene,object);}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
  // now, in case this material supports lights - or later, when
  // the next material that does gets activated:
  refreshMaterial=true;// set to true on material change
  refreshLights=true;// remains set until update done
  }// load material specific uniforms
  // (shader material also gets them for the sake of genericity)
  if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.isShadowMaterial||object.isSkinnedMesh){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning and morph target uniforms must be set even if material didn't change
  // auto-setting of texture unit for bone and morph texture must go before other textures
  // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
  if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){if(capabilities.floatVertexTextures){if(skeleton.boneTexture===null)skeleton.computeBoneTexture();p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else {console.warn('THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.');}}}var morphAttributes=geometry.morphAttributes;if(morphAttributes.position!==undefined||morphAttributes.normal!==undefined||morphAttributes.color!==undefined&&capabilities.isWebGL2===true){morphtargets.update(object,geometry,material,program);}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512
  if(material.isMeshGouraudMaterial&&material.envMap!==null){m_uniforms.envMap.value=envMap;m_uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===false?-1:1;}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);if(materialProperties.needsLights){// the current material requires lighting info
  // note: all lighting uniforms are always set correctly
  // they simply reference the renderer's state for their
  // values
  //
  // use the current material's .needsUpdate flags to set
  // the GL state when required
  markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
  if(fog&&material.fog===true){materials.refreshFogUniforms(m_uniforms,fog);}materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,_transmissionRenderTarget);WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
  p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);// UBOs
  if(material.isShaderMaterial||material.isRawShaderMaterial){var groups=material.uniformsGroups;for(var i=0,l=groups.length;i<l;i++){if(capabilities.isWebGL2){var group=groups[i];uniformsGroups.update(group,program);uniformsGroups.bind(group,program);}else {console.warn('THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.');}}}return program;}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
  function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTargetTextures=function(renderTarget,colorTexture,depthTexture){properties.get(renderTarget.texture).__webglTexture=colorTexture;properties.get(renderTarget.depthTexture).__webglTexture=depthTexture;var renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__hasExternalTextures=true;if(renderTargetProperties.__hasExternalTextures){renderTargetProperties.__autoAllocateDepthBuffer=depthTexture===undefined;if(!renderTargetProperties.__autoAllocateDepthBuffer){// The multisample_render_to_texture extension doesn't work properly if there
  // are midframe flushes and an external depth buffer. Disable use of the extension.
  if(extensions.has('WEBGL_multisampled_render_to_texture')===true){console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');renderTargetProperties.__useRenderToTexture=false;}}}};this.setRenderTargetFramebuffer=function(renderTarget,defaultFramebuffer){var renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__webglFramebuffer=defaultFramebuffer;renderTargetProperties.__useDefaultFramebuffer=defaultFramebuffer===undefined;};this.setRenderTarget=function(renderTarget){var activeCubeFace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var activeMipmapLevel=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;var useDefaultFramebuffer=true;if(renderTarget){var renderTargetProperties=properties.get(renderTarget);if(renderTargetProperties.__useDefaultFramebuffer!==undefined){// We need to make sure to rebind the framebuffer.
  state.bindFramebuffer(36160,null);useDefaultFramebuffer=false;}else if(renderTargetProperties.__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}else if(renderTargetProperties.__hasExternalTextures){// Color and depth texture must be rebound in order for the swapchain to update.
  textures.rebindTextures(renderTarget,properties.get(renderTarget.texture).__webglTexture,properties.get(renderTarget.depthTexture).__webglTexture);}}var framebuffer=null;var isCube=false;var isRenderTarget3D=false;if(renderTarget){var texture=renderTarget.texture;if(texture.isData3DTexture||texture.isDataArrayTexture){isRenderTarget3D=true;}var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){framebuffer=__webglFramebuffer[activeCubeFace];isCube=true;}else if(capabilities.isWebGL2&&renderTarget.samples>0&&textures.useMultisampledRTT(renderTarget)===false){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else {framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else {_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}var framebufferBound=state.bindFramebuffer(36160,framebuffer);if(framebufferBound&&capabilities.drawBuffers&&useDefaultFramebuffer){state.drawBuffers(renderTarget,framebuffer);}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(36160,36064,34069+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel);}else if(isRenderTarget3D){var _textureProperties=properties.get(renderTarget.texture);var layer=activeCubeFace||0;_gl.framebufferTextureLayer(36160,36064,_textureProperties.__webglTexture,activeMipmapLevel||0,layer);}_currentMaterialId=-1;// reset current material to ensure correct uniform bindings
  };this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){state.bindFramebuffer(36160,framebuffer);try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}var halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions.has('EXT_color_buffer_half_float')||capabilities.isWebGL2&&extensions.has('EXT_color_buffer_float'));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
  !(textureType===FloatType&&(capabilities.isWebGL2||extensions.has('OES_texture_float')||extensions.has('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
  !halfFloatSupportedByExt){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}finally{// restore framebuffer of current render target if necessary
  var _framebuffer=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(36160,_framebuffer);}}};this.copyFramebufferToTexture=function(position,texture){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var levelScale=Math.pow(2,-level);var width=Math.floor(texture.image.width*levelScale);var height=Math.floor(texture.image.height*levelScale);textures.setTexture2D(texture,0);_gl.copyTexSubImage2D(3553,level,0,0,position.x,position.y,width,height);state.unbindTexture();};this.copyTextureToTexture=function(position,srcTexture,dstTexture){var level=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var width=srcTexture.image.width;var height=srcTexture.image.height;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);// As another texture upload may have changed pixelStorei
  // parameters, make sure they are correct for the dstTexture
  _gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);if(srcTexture.isDataTexture){_gl.texSubImage2D(3553,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);}else {if(srcTexture.isCompressedTexture){_gl.compressedTexSubImage2D(3553,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data);}else {_gl.texSubImage2D(3553,level,position.x,position.y,glFormat,glType,srcTexture.image);}}// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(3553);state.unbindTexture();};this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture){var level=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;if(_this.isWebGL1Renderer){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');return;}var width=sourceBox.max.x-sourceBox.min.x+1;var height=sourceBox.max.y-sourceBox.min.y+1;var depth=sourceBox.max.z-sourceBox.min.z+1;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);var glTarget;if(dstTexture.isData3DTexture){textures.setTexture3D(dstTexture,0);glTarget=32879;}else if(dstTexture.isDataArrayTexture){textures.setTexture2DArray(dstTexture,0);glTarget=35866;}else {console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');return;}_gl.pixelStorei(37440,dstTexture.flipY);_gl.pixelStorei(37441,dstTexture.premultiplyAlpha);_gl.pixelStorei(3317,dstTexture.unpackAlignment);var unpackRowLen=_gl.getParameter(3314);var unpackImageHeight=_gl.getParameter(32878);var unpackSkipPixels=_gl.getParameter(3316);var unpackSkipRows=_gl.getParameter(3315);var unpackSkipImages=_gl.getParameter(32877);var image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(3314,image.width);_gl.pixelStorei(32878,image.height);_gl.pixelStorei(3316,sourceBox.min.x);_gl.pixelStorei(3315,sourceBox.min.y);_gl.pixelStorei(32877,sourceBox.min.z);if(srcTexture.isDataTexture||srcTexture.isData3DTexture){_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image.data);}else {if(srcTexture.isCompressedTexture){console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,image.data);}else {_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image);}}_gl.pixelStorei(3314,unpackRowLen);_gl.pixelStorei(32878,unpackImageHeight);_gl.pixelStorei(3316,unpackSkipPixels);_gl.pixelStorei(3315,unpackSkipRows);_gl.pixelStorei(32877,unpackSkipImages);// Generate mipmaps only when copying level 0
  if(level===0&&dstTexture.generateMipmaps)_gl.generateMipmap(glTarget);state.unbindTexture();};this.initTexture=function(texture){if(texture.isCubeTexture){textures.setTextureCube(texture,0);}else if(texture.isData3DTexture){textures.setTexture3D(texture,0);}else if(texture.isDataArrayTexture){textures.setTexture2DArray(texture,0);}else {textures.setTexture2D(texture,0);}state.unbindTexture();};this.resetState=function(){_currentActiveCubeFace=0;_currentActiveMipmapLevel=0;_currentRenderTarget=null;state.reset();bindingStates.reset();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));}}var WebGL1Renderer=/*#__PURE__*/function(_WebGLRenderer){_inherits(WebGL1Renderer,_WebGLRenderer);var _super38=_createSuper(WebGL1Renderer);function WebGL1Renderer(){_classCallCheck(this,WebGL1Renderer);return _super38.apply(this,arguments);}return _createClass(WebGL1Renderer);}(WebGLRenderer);WebGL1Renderer.prototype.isWebGL1Renderer=true;var Scene$1=/*#__PURE__*/function(_Object3D5){_inherits(Scene,_Object3D5);var _super39=_createSuper(Scene);function Scene(){var _this30;_classCallCheck(this,Scene);_this30=_super39.call(this);_this30.isScene=true;_this30.type='Scene';_this30.background=null;_this30.environment=null;_this30.fog=null;_this30.overrideMaterial=null;if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:_assertThisInitialized(_this30)}));}return _this30;}_createClass(Scene,[{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Scene.prototype),"copy",this).call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.matrixAutoUpdate=source.matrixAutoUpdate;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(Scene.prototype),"toJSON",this).call(this,meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}// @deprecated
  },{key:"autoUpdate",get:function get(){console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');return this.matrixWorldAutoUpdate;},set:function set(value){console.warn('THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.');this.matrixWorldAutoUpdate=value;}}]);return Scene;}(Object3D);var InstancedBufferAttribute=/*#__PURE__*/function(_BufferAttribute11){_inherits(InstancedBufferAttribute,_BufferAttribute11);var _super46=_createSuper(InstancedBufferAttribute);function InstancedBufferAttribute(array,itemSize,normalized){var _this37;var meshPerAttribute=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,InstancedBufferAttribute);_this37=_super46.call(this,array,itemSize,normalized);_this37.isInstancedBufferAttribute=true;_this37.meshPerAttribute=meshPerAttribute;return _this37;}_createClass(InstancedBufferAttribute,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(InstancedBufferAttribute.prototype),"copy",this).call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(InstancedBufferAttribute.prototype),"toJSON",this).call(this);data.meshPerAttribute=this.meshPerAttribute;data.isInstancedBufferAttribute=true;return data;}}]);return InstancedBufferAttribute;}(BufferAttribute);var PolyhedronGeometry=/*#__PURE__*/function(_BufferGeometry6){_inherits(PolyhedronGeometry,_BufferGeometry6);var _super75=_createSuper(PolyhedronGeometry);function PolyhedronGeometry(){var _this66;var vertices=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var indices=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var radius=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;var detail=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;_classCallCheck(this,PolyhedronGeometry);_this66=_super75.call(this);_this66.type='PolyhedronGeometry';_this66.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};// default buffer data
  var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
  subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
  applyRadius(radius);// finally, create the uv data
  generateUVs();// build non-indexed geometry
  _this66.setAttribute('position',new Float32BufferAttribute(vertexBuffer,3));_this66.setAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));_this66.setAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){_this66.computeVertexNormals();// flat normals
  }else {_this66.normalizeNormals();// smooth normals
  }// helper functions
  function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
  for(var i=0;i<indices.length;i+=3){// get the vertices of the face
  getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
  subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=detail+1;// we use this multidimensional array as a data structure for creating the subdivision
  var v=[];// construct all of the vertices for this subdivision
  for(var i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(var j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else {v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
  for(var _i59=0;_i59<cols;_i59++){for(var _j7=0;_j7<2*(cols-_i59)-1;_j7++){var k=Math.floor(_j7/2);if(_j7%2===0){pushVertex(v[_i59][k+1]);pushVertex(v[_i59+1][k]);pushVertex(v[_i59][k]);}else {pushVertex(v[_i59][k+1]);pushVertex(v[_i59+1][k+1]);pushVertex(v[_i59+1][k]);}}}}function applyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
  for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
  for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
  var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
  if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
  function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
  function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}return _this66;}_createClass(PolyhedronGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,data.details);}}]);return PolyhedronGeometry;}(BufferGeometry);var IcosahedronGeometry=/*#__PURE__*/function(_PolyhedronGeometry2){_inherits(IcosahedronGeometry,_PolyhedronGeometry2);var _super80=_createSuper(IcosahedronGeometry);function IcosahedronGeometry(){var _this71;var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var detail=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,IcosahedronGeometry);var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];_this71=_super80.call(this,vertices,indices,radius,detail);_this71.type='IcosahedronGeometry';_this71.parameters={radius:radius,detail:detail};return _this71;}_createClass(IcosahedronGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail);}}]);return IcosahedronGeometry;}(PolyhedronGeometry);var SphereGeometry=/*#__PURE__*/function(_BufferGeometry11){_inherits(SphereGeometry,_BufferGeometry11);var _super84=_createSuper(SphereGeometry);function SphereGeometry(){var _this75;var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var widthSegments=arguments.length>1&&arguments[1]!==undefined?arguments[1]:32;var heightSegments=arguments.length>2&&arguments[2]!==undefined?arguments[2]:16;var phiStart=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var phiLength=arguments.length>4&&arguments[4]!==undefined?arguments[4]:Math.PI*2;var thetaStart=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;var thetaLength=arguments.length>6&&arguments[6]!==undefined?arguments[6]:Math.PI;_classCallCheck(this,SphereGeometry);_this75=_super84.call(this);_this75.type='SphereGeometry';_this75.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};widthSegments=Math.max(3,Math.floor(widthSegments));heightSegments=Math.max(2,Math.floor(heightSegments));var thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
  for(var iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;// special case for the poles
  var uOffset=0;if(iy==0&&thetaStart==0){uOffset=0.5/widthSegments;}else if(iy==heightSegments&&thetaEnd==Math.PI){uOffset=-0.5/widthSegments;}for(var ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
  vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normal.copy(vertex).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u+uOffset,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
  for(var _iy3=0;_iy3<heightSegments;_iy3++){for(var _ix3=0;_ix3<widthSegments;_ix3++){var a=grid[_iy3][_ix3+1];var b=grid[_iy3][_ix3];var c=grid[_iy3+1][_ix3];var d=grid[_iy3+1][_ix3+1];if(_iy3!==0||thetaStart>0)indices.push(a,b,d);if(_iy3!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
  _this75.setIndex(indices);_this75.setAttribute('position',new Float32BufferAttribute(vertices,3));_this75.setAttribute('normal',new Float32BufferAttribute(normals,3));_this75.setAttribute('uv',new Float32BufferAttribute(uvs,2));return _this75;}_createClass(SphereGeometry,null,[{key:"fromJSON",value:function fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);}}]);return SphereGeometry;}(BufferGeometry);var MeshStandardMaterial=/*#__PURE__*/function(_Material9){_inherits(MeshStandardMaterial,_Material9);var _super92=_createSuper(MeshStandardMaterial);function MeshStandardMaterial(parameters){var _this83;_classCallCheck(this,MeshStandardMaterial);_this83=_super92.call(this);_this83.isMeshStandardMaterial=true;_this83.defines={'STANDARD':''};_this83.type='MeshStandardMaterial';_this83.color=new Color$1(0xffffff);// diffuse
  _this83.roughness=1.0;_this83.metalness=0.0;_this83.map=null;_this83.lightMap=null;_this83.lightMapIntensity=1.0;_this83.aoMap=null;_this83.aoMapIntensity=1.0;_this83.emissive=new Color$1(0x000000);_this83.emissiveIntensity=1.0;_this83.emissiveMap=null;_this83.bumpMap=null;_this83.bumpScale=1;_this83.normalMap=null;_this83.normalMapType=TangentSpaceNormalMap;_this83.normalScale=new Vector2(1,1);_this83.displacementMap=null;_this83.displacementScale=1;_this83.displacementBias=0;_this83.roughnessMap=null;_this83.metalnessMap=null;_this83.alphaMap=null;_this83.envMap=null;_this83.envMapIntensity=1.0;_this83.wireframe=false;_this83.wireframeLinewidth=1;_this83.wireframeLinecap='round';_this83.wireframeLinejoin='round';_this83.flatShading=false;_this83.fog=true;_this83.setValues(parameters);return _this83;}_createClass(MeshStandardMaterial,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshStandardMaterial.prototype),"copy",this).call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this;}}]);return MeshStandardMaterial;}(Material);var MeshPhysicalMaterial=/*#__PURE__*/function(_MeshStandardMaterial){_inherits(MeshPhysicalMaterial,_MeshStandardMaterial);var _super93=_createSuper(MeshPhysicalMaterial);function MeshPhysicalMaterial(parameters){var _this84;_classCallCheck(this,MeshPhysicalMaterial);_this84=_super93.call(this);_this84.isMeshPhysicalMaterial=true;_this84.defines={'STANDARD':'','PHYSICAL':''};_this84.type='MeshPhysicalMaterial';_this84.clearcoatMap=null;_this84.clearcoatRoughness=0.0;_this84.clearcoatRoughnessMap=null;_this84.clearcoatNormalScale=new Vector2(1,1);_this84.clearcoatNormalMap=null;_this84.ior=1.5;Object.defineProperty(_assertThisInitialized(_this84),'reflectivity',{get:function get(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1);},set:function set(reflectivity){this.ior=(1+0.4*reflectivity)/(1-0.4*reflectivity);}});_this84.iridescenceMap=null;_this84.iridescenceIOR=1.3;_this84.iridescenceThicknessRange=[100,400];_this84.iridescenceThicknessMap=null;_this84.sheenColor=new Color$1(0x000000);_this84.sheenColorMap=null;_this84.sheenRoughness=1.0;_this84.sheenRoughnessMap=null;_this84.transmissionMap=null;_this84.thickness=0;_this84.thicknessMap=null;_this84.attenuationDistance=0.0;_this84.attenuationColor=new Color$1(1,1,1);_this84.specularIntensity=1.0;_this84.specularIntensityMap=null;_this84.specularColor=new Color$1(1,1,1);_this84.specularColorMap=null;_this84._sheen=0.0;_this84._clearcoat=0;_this84._iridescence=0;_this84._transmission=0;_this84.setValues(parameters);return _this84;}_createClass(MeshPhysicalMaterial,[{key:"sheen",get:function get(){return this._sheen;},set:function set(value){if(this._sheen>0!==value>0){this.version++;}this._sheen=value;}},{key:"clearcoat",get:function get(){return this._clearcoat;},set:function set(value){if(this._clearcoat>0!==value>0){this.version++;}this._clearcoat=value;}},{key:"iridescence",get:function get(){return this._iridescence;},set:function set(value){if(this._iridescence>0!==value>0){this.version++;}this._iridescence=value;}},{key:"transmission",get:function get(){return this._transmission;},set:function set(value){if(this._transmission>0!==value>0){this.version++;}this._transmission=value;}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(MeshPhysicalMaterial.prototype),"copy",this).call(this,source);this.defines={'STANDARD':'','PHYSICAL':''};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.ior=source.ior;this.iridescence=source.iridescence;this.iridescenceMap=source.iridescenceMap;this.iridescenceIOR=source.iridescenceIOR;this.iridescenceThicknessRange=_toConsumableArray(source.iridescenceThicknessRange);this.iridescenceThicknessMap=source.iridescenceThicknessMap;this.sheen=source.sheen;this.sheenColor.copy(source.sheenColor);this.sheenColorMap=source.sheenColorMap;this.sheenRoughness=source.sheenRoughness;this.sheenRoughnessMap=source.sheenRoughnessMap;this.transmission=source.transmission;this.transmissionMap=source.transmissionMap;this.thickness=source.thickness;this.thicknessMap=source.thicknessMap;this.attenuationDistance=source.attenuationDistance;this.attenuationColor.copy(source.attenuationColor);this.specularIntensity=source.specularIntensity;this.specularIntensityMap=source.specularIntensityMap;this.specularColor.copy(source.specularColor);this.specularColorMap=source.specularColorMap;return this;}}]);return MeshPhysicalMaterial;}(MeshStandardMaterial);function arraySlice(array,from,to){if(isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
  // but array.subarray(from) or array.subarray(from, len) is correct
  return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);}// converts an array to a specific type
  function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
  !forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
  }return Array.prototype.slice.call(array);// create Array
  }function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);}// returns an array by which times and values can be sorted
  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */var Interpolant=/*#__PURE__*/function(){function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,Interpolant);this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;this.settings=null;this.DefaultSettings_={};}_createClass(Interpolant,[{key:"evaluate",value:function evaluate(t){var pp=this.parameterPositions;var i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
  //- slower code:
  //-
  //- 				if ( t >= t1 || t1 === undefined ) {
  forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
  i1=pp.length;this._cachedIndex=i1;return this.copySampleValue_(i1-1);}if(i1===giveUpAt)break;// this loop
  t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the right side of the index
  right=pp.length;break linear_scan;}//- slower code:
  //-					if ( t < t0 || t0 === undefined ) {
  if(!(t>=t0)){// looping?
  var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
  t0=t1global;}// linear reverse scan
  for(var _giveUpAt=i1-2;;){if(t0===undefined){// before start
  this._cachedIndex=0;return this.copySampleValue_(0);}if(i1===_giveUpAt)break;// this loop
  t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the left side of the index
  right=i1;i1=0;break linear_scan;}// the interval is valid
  break validate_interval;}// linear scan
  // binary search
  while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else {i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
  if(t0===undefined){this._cachedIndex=0;return this.copySampleValue_(0);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.copySampleValue_(i1-1);}}// seek
  this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
  return this.interpolate_(i1,t0,t,t1);}},{key:"getSettings_",value:function getSettings_(){return this.settings||this.DefaultSettings_;}},{key:"copySampleValue_",value:function copySampleValue_(index){// copies a sample value to the result buffer
  var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;}// Template methods for derived classes:
  },{key:"interpolate_",value:function/* i1, t0, t, t1 */interpolate_(){throw new Error('call to abstract method');// implementations shall return this.resultBuffer
  }},{key:"intervalChanged_",value:function/* i1, t0, t1 */intervalChanged_(){// empty
  }}]);return Interpolant;}();/**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */var CubicInterpolant=/*#__PURE__*/function(_Interpolant){_inherits(CubicInterpolant,_Interpolant);var _super100=_createSuper(CubicInterpolant);function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){var _this91;_classCallCheck(this,CubicInterpolant);_this91=_super100.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);_this91._weightPrev=-0;_this91._offsetPrev=-0;_this91._weightNext=-0;_this91._offsetNext=-0;_this91.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};return _this91;}_createClass(CubicInterpolant,[{key:"intervalChanged_",value:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions;var iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
  iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
  iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
  // f''(t0) = 0 a.k.a. Natural Spline
  iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
  iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
  iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
  // f''(tN) = 0, a.k.a. Natural Spline
  iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;}},{key:"interpolate_",value:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
  var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
  for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}}]);return CubicInterpolant;}(Interpolant);var LinearInterpolant=/*#__PURE__*/function(_Interpolant2){_inherits(LinearInterpolant,_Interpolant2);var _super101=_createSuper(LinearInterpolant);function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,LinearInterpolant);return _super101.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}_createClass(LinearInterpolant,[{key:"interpolate_",value:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}}]);return LinearInterpolant;}(Interpolant);/**
   *
   * Interpolant that evaluates to the sample value at the position preceding
   * the parameter.
   */var DiscreteInterpolant=/*#__PURE__*/function(_Interpolant3){_inherits(DiscreteInterpolant,_Interpolant3);var _super102=_createSuper(DiscreteInterpolant);function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,DiscreteInterpolant);return _super102.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}_createClass(DiscreteInterpolant,[{key:"interpolate_",value:function interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}}]);return DiscreteInterpolant;}(Interpolant);var KeyframeTrack=/*#__PURE__*/function(){function KeyframeTrack(name,times,values,interpolation){_classCallCheck(this,KeyframeTrack);if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=convertArray(times,this.TimeBufferType);this.values=convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);}// Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  _createClass(KeyframeTrack,[{key:"InterpolantFactoryMethodDiscrete",value:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"InterpolantFactoryMethodLinear",value:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"InterpolantFactoryMethodSmooth",value:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);}},{key:"setInterpolation",value:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message='unsupported interpolation for '+this.ValueTypeName+' keyframe track named '+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
  if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else {throw new Error(message);// fatal, in this case
  }}console.warn('THREE.KeyframeTrack:',message);return this;}this.createInterpolant=factoryMethod;return this;}},{key:"getInterpolation",value:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}}},{key:"getValueSize",value:function getValueSize(){return this.values.length/this.times.length;}// move all keyframes either forwards or backwards in time
  },{key:"shift",value:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  },{key:"scale",value:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  },{key:"trim",value:function trim(startTime,endTime){var times=this.times,nKeys=times.length;var from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
  if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
  if(from>=to){to=Math.max(to,1);from=to-1;}var stride=this.getValueSize();this.times=arraySlice(times,from,to);this.values=arraySlice(this.values,from*stride,to*stride);}return this;}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  },{key:"validate",value:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(isTypedArray(values)){for(var _i83=0,n=values.length;_i83!==n;++_i83){var _value6=values[_i83];if(isNaN(_value6)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,_i83,_value6);valid=false;break;}}}}return valid;}// removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  },{key:"optimize",value:function optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
  var times=arraySlice(this.times),values=arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,lastIndex=times.length-1;var writeIndex=1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
  if(time!==timeNext&&(i!==1||time!==times[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
  var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var _value7=values[offset+j];if(_value7!==values[offsetP+j]||_value7!==values[offsetN+j]){keep=true;break;}}}else {keep=true;}}// in-place compaction
  if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var _j14=0;_j14!==stride;++_j14){values[writeOffset+_j14]=values[readOffset+_j14];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
  if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var _readOffset=lastIndex*stride,_writeOffset=writeIndex*stride,_j15=0;_j15!==stride;++_j15){values[_writeOffset+_j15]=values[_readOffset+_j15];}++writeIndex;}if(writeIndex!==times.length){this.times=arraySlice(times,0,writeIndex);this.values=arraySlice(values,0,writeIndex*stride);}else {this.times=times;this.values=values;}return this;}},{key:"clone",value:function clone(){var times=arraySlice(this.times,0);var values=arraySlice(this.values,0);var TypedKeyframeTrack=this.constructor;var track=new TypedKeyframeTrack(this.name,times,values);// Interpolant argument to constructor is not saved, so copy the factory method directly.
  track.createInterpolant=this.createInterpolant;return track;}}],[{key:"toJSON",value:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
  if(trackType.toJSON!==this.toJSON){json=trackType.toJSON(track);}else {// by default, we assume the data can be serialized as-is
  json={'name':track.name,'times':convertArray(track.times,Array),'values':convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
  return json;}}]);return KeyframeTrack;}();KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;/**
   * A Track of Boolean keyframe values.
   */var BooleanKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack){_inherits(BooleanKeyframeTrack,_KeyframeTrack);var _super103=_createSuper(BooleanKeyframeTrack);function BooleanKeyframeTrack(){_classCallCheck(this,BooleanKeyframeTrack);return _super103.apply(this,arguments);}return _createClass(BooleanKeyframeTrack);}(KeyframeTrack);BooleanKeyframeTrack.prototype.ValueTypeName='bool';BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of keyframe values that represent color.
   */var ColorKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack2){_inherits(ColorKeyframeTrack,_KeyframeTrack2);var _super104=_createSuper(ColorKeyframeTrack);function ColorKeyframeTrack(){_classCallCheck(this,ColorKeyframeTrack);return _super104.apply(this,arguments);}return _createClass(ColorKeyframeTrack);}(KeyframeTrack);ColorKeyframeTrack.prototype.ValueTypeName='color';/**
   * A Track of numeric keyframe values.
   */var NumberKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack3){_inherits(NumberKeyframeTrack,_KeyframeTrack3);var _super105=_createSuper(NumberKeyframeTrack);function NumberKeyframeTrack(){_classCallCheck(this,NumberKeyframeTrack);return _super105.apply(this,arguments);}return _createClass(NumberKeyframeTrack);}(KeyframeTrack);NumberKeyframeTrack.prototype.ValueTypeName='number';/**
   * A Track that interpolates Strings
   */var StringKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack5){_inherits(StringKeyframeTrack,_KeyframeTrack5);var _super108=_createSuper(StringKeyframeTrack);function StringKeyframeTrack(){_classCallCheck(this,StringKeyframeTrack);return _super108.apply(this,arguments);}return _createClass(StringKeyframeTrack);}(KeyframeTrack);StringKeyframeTrack.prototype.ValueTypeName='string';StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=undefined;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=undefined;/**
   * A Track of vectored keyframe values.
   */var VectorKeyframeTrack=/*#__PURE__*/function(_KeyframeTrack6){_inherits(VectorKeyframeTrack,_KeyframeTrack6);var _super109=_createSuper(VectorKeyframeTrack);function VectorKeyframeTrack(){_classCallCheck(this,VectorKeyframeTrack);return _super109.apply(this,arguments);}return _createClass(VectorKeyframeTrack);}(KeyframeTrack);VectorKeyframeTrack.prototype.ValueTypeName='vector';var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
  this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
  return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};var LoadingManager=/*#__PURE__*/_createClass(function LoadingManager(onLoad,onProgress,onError){_classCallCheck(this,LoadingManager);var scope=this;var isLoading=false;var itemsLoaded=0;var itemsTotal=0;var urlModifier=undefined;var handlers=[];// Refer to #5689 for the reason why we don't set .onStart
  // in the constructor
  this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this;};this.removeHandler=function(regex){var index=handlers.indexOf(regex);if(index!==-1){handlers.splice(index,2);}return this;};this.getHandler=function(file){for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.global)regex.lastIndex=0;// see #17920
  if(regex.test(file)){return loader;}}return null;};});var DefaultLoadingManager=/*@__PURE__*/new LoadingManager();var Loader=/*#__PURE__*/function(){function Loader(manager){_classCallCheck(this,Loader);this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.withCredentials=false;this.path='';this.resourcePath='';this.requestHeader={};}_createClass(Loader,[{key:"load",value:function/* url, onLoad, onProgress, onError */load(){}},{key:"loadAsync",value:function loadAsync(url,onProgress){var scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject);});}},{key:"parse",value:function/* data */parse(){}},{key:"setCrossOrigin",value:function setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;}},{key:"setWithCredentials",value:function setWithCredentials(value){this.withCredentials=value;return this;}},{key:"setPath",value:function setPath(path){this.path=path;return this;}},{key:"setResourcePath",value:function setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}},{key:"setRequestHeader",value:function setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this;}}]);return Loader;}();var ImageLoader=/*#__PURE__*/function(_Loader4){_inherits(ImageLoader,_Loader4);var _super114=_createSuper(ImageLoader);function ImageLoader(manager){_classCallCheck(this,ImageLoader);return _super114.call(this,manager);}_createClass(ImageLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=createElementNS('img');function onImageLoad(){removeEventListeners();Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);}function onImageError(event){removeEventListeners();if(onError)onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url);}function removeEventListeners(){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);}image.addEventListener('load',onImageLoad,false);image.addEventListener('error',onImageError,false);if(url.slice(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;}}]);return ImageLoader;}(Loader);var TextureLoader=/*#__PURE__*/function(_Loader7){_inherits(TextureLoader,_Loader7);var _super117=_createSuper(TextureLoader);function TextureLoader(manager){_classCallCheck(this,TextureLoader);return _super117.call(this,manager);}_createClass(TextureLoader,[{key:"load",value:function load(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;}}]);return TextureLoader;}(Loader);var Light=/*#__PURE__*/function(_Object3D11){_inherits(Light,_Object3D11);var _super118=_createSuper(Light);function Light(color){var _this94;var intensity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;_classCallCheck(this,Light);_this94=_super118.call(this);_this94.isLight=true;_this94.type='Light';_this94.color=new Color$1(color);_this94.intensity=intensity;return _this94;}_createClass(Light,[{key:"dispose",value:function dispose(){// Empty here in base class; some subclasses override.
  }},{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(Light.prototype),"copy",this).call(this,source,recursive);this.color.copy(source.color);this.intensity=source.intensity;return this;}},{key:"toJSON",value:function toJSON(meta){var data=_get(_getPrototypeOf(Light.prototype),"toJSON",this).call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}}]);return Light;}(Object3D);var _projScreenMatrix$1=/*@__PURE__*/new Matrix4();var _lightPositionWorld$1=/*@__PURE__*/new Vector3();var _lookTarget$1=/*@__PURE__*/new Vector3();var LightShadow=/*#__PURE__*/function(){function LightShadow(camera){_classCallCheck(this,LightShadow);this.camera=camera;this.bias=0;this.normalBias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4();this.autoUpdate=true;this.needsUpdate=false;this._frustum=new Frustum();this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}_createClass(LightShadow,[{key:"getViewportCount",value:function getViewportCount(){return this._viewportCount;}},{key:"getFrustum",value:function getFrustum(){return this._frustum;}},{key:"updateMatrices",value:function updateMatrices(light){var shadowCamera=this.camera;var shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}},{key:"getViewport",value:function getViewport(viewportIndex){return this._viewports[viewportIndex];}},{key:"getFrameExtents",value:function getFrameExtents(){return this._frameExtents;}},{key:"dispose",value:function dispose(){if(this.map){this.map.dispose();}if(this.mapPass){this.mapPass.dispose();}}},{key:"copy",value:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"toJSON",value:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.normalBias!==0)object.normalBias=this.normalBias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}}]);return LightShadow;}();var _projScreenMatrix=/*@__PURE__*/new Matrix4();var _lightPositionWorld=/*@__PURE__*/new Vector3();var _lookTarget=/*@__PURE__*/new Vector3();var PointLightShadow=/*#__PURE__*/function(_LightShadow2){_inherits(PointLightShadow,_LightShadow2);var _super122=_createSuper(PointLightShadow);function PointLightShadow(){var _this98;_classCallCheck(this,PointLightShadow);_this98=_super122.call(this,new PerspectiveCamera(90,1,0.5,500));_this98.isPointLightShadow=true;_this98._frameExtents=new Vector2(4,2);_this98._viewportCount=6;_this98._viewports=[// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2,1,1,1),// negative X
  new Vector4(0,1,1,1),// positive Z
  new Vector4(3,1,1,1),// negative Z
  new Vector4(1,1,1,1),// positive Y
  new Vector4(3,0,1,1),// negative Y
  new Vector4(1,0,1,1)];_this98._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];_this98._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];return _this98;}_createClass(PointLightShadow,[{key:"updateMatrices",value:function updateMatrices(light){var viewportIndex=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var camera=this.camera;var shadowMatrix=this.matrix;var far=light.distance||camera.far;if(far!==camera.far){camera.far=far;camera.updateProjectionMatrix();}_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(_lightPositionWorld);_lookTarget.copy(camera.position);_lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(_lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix);}}]);return PointLightShadow;}(LightShadow);var PointLight=/*#__PURE__*/function(_Light3){_inherits(PointLight,_Light3);var _super123=_createSuper(PointLight);function PointLight(color,intensity){var _this99;var distance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var decay=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;_classCallCheck(this,PointLight);_this99=_super123.call(this,color,intensity);_this99.isPointLight=true;_this99.type='PointLight';_this99.distance=distance;_this99.decay=decay;// for physically correct lights, should be 2.
  _this99.shadow=new PointLightShadow();return _this99;}_createClass(PointLight,[{key:"power",get:function get(){// compute the light's luminous power (in lumens) from its intensity (in candela)
  // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
  return this.intensity*4*Math.PI;},set:function set(power){// set the light's intensity (in candela) from the desired luminous power (in lumens)
  this.intensity=power/(4*Math.PI);}},{key:"dispose",value:function dispose(){this.shadow.dispose();}},{key:"copy",value:function copy(source,recursive){_get(_getPrototypeOf(PointLight.prototype),"copy",this).call(this,source,recursive);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}}]);return PointLight;}(Light);var DirectionalLightShadow=/*#__PURE__*/function(_LightShadow3){_inherits(DirectionalLightShadow,_LightShadow3);var _super124=_createSuper(DirectionalLightShadow);function DirectionalLightShadow(){var _this100;_classCallCheck(this,DirectionalLightShadow);_this100=_super124.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));_this100.isDirectionalLightShadow=true;return _this100;}return _createClass(DirectionalLightShadow);}(LightShadow);var DirectionalLight=/*#__PURE__*/function(_Light4){_inherits(DirectionalLight,_Light4);var _super125=_createSuper(DirectionalLight);function DirectionalLight(color,intensity){var _this101;_classCallCheck(this,DirectionalLight);_this101=_super125.call(this,color,intensity);_this101.isDirectionalLight=true;_this101.type='DirectionalLight';_this101.position.copy(Object3D.DefaultUp);_this101.updateMatrix();_this101.target=new Object3D();_this101.shadow=new DirectionalLightShadow();return _this101;}_createClass(DirectionalLight,[{key:"dispose",value:function dispose(){this.shadow.dispose();}},{key:"copy",value:function copy(source){_get(_getPrototypeOf(DirectionalLight.prototype),"copy",this).call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}}]);return DirectionalLight;}(Light);var AmbientLight=/*#__PURE__*/function(_Light5){_inherits(AmbientLight,_Light5);var _super126=_createSuper(AmbientLight);function AmbientLight(color,intensity){var _this102;_classCallCheck(this,AmbientLight);_this102=_super126.call(this,color,intensity);_this102.isAmbientLight=true;_this102.type='AmbientLight';return _this102;}return _createClass(AmbientLight);}(Light);var InstancedBufferGeometry=/*#__PURE__*/function(_BufferGeometry16){_inherits(InstancedBufferGeometry,_BufferGeometry16);var _super130=_createSuper(InstancedBufferGeometry);function InstancedBufferGeometry(){var _this106;_classCallCheck(this,InstancedBufferGeometry);_this106=_super130.call(this);_this106.isInstancedBufferGeometry=true;_this106.type='InstancedBufferGeometry';_this106.instanceCount=Infinity;return _this106;}_createClass(InstancedBufferGeometry,[{key:"copy",value:function copy(source){_get(_getPrototypeOf(InstancedBufferGeometry.prototype),"copy",this).call(this,source);this.instanceCount=source.instanceCount;return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}},{key:"toJSON",value:function toJSON(){var data=_get(_getPrototypeOf(InstancedBufferGeometry.prototype),"toJSON",this).call(this,this);data.instanceCount=this.instanceCount;data.isInstancedBufferGeometry=true;return data;}}]);return InstancedBufferGeometry;}(BufferGeometry);/**
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
   * The azimuthal angle (theta) is measured from the positive z-axis.
   */var Spherical=/*#__PURE__*/function(){function Spherical(){var radius=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var phi=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var theta=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;_classCallCheck(this,Spherical);this.radius=radius;this.phi=phi;// polar angle
  this.theta=theta;// azimuthal angle
  return this;}_createClass(Spherical,[{key:"set",value:function set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;}},{key:"copy",value:function copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;}// restrict phi to be between EPS and PI-EPS
  },{key:"makeSafe",value:function makeSafe(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;}},{key:"setFromVector3",value:function setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);}},{key:"setFromCartesianCoords",value:function setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);if(this.radius===0){this.theta=0;this.phi=0;}else {this.theta=Math.atan2(x,z);this.phi=Math.acos(clamp(y/this.radius,-1,1));}return this;}},{key:"clone",value:function clone(){return new this.constructor().copy(this);}}]);return Spherical;}();var SphereBufferGeometry=/*#__PURE__*/function(_SphereGeometry){_inherits(SphereBufferGeometry,_SphereGeometry);var _super173=_createSuper(SphereBufferGeometry);function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){_classCallCheck(this,SphereBufferGeometry);console.warn('THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.');return _super173.call(this,radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength);}return _createClass(SphereBufferGeometry);}(SphereGeometry);// r144
  if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));}if(typeof window!=='undefined'){if(window.__THREE__){console.warn('WARNING: Multiple instances of Three.js being imported.');}else {window.__THREE__=REVISION;}}

  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one-finger move
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

  var _changeEvent = {
    type: 'change'
  };
  var _startEvent = {
    type: 'start'
  };
  var _endEvent = {
    type: 'end'
  };

  var OrbitControls = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(OrbitControls, _EventDispatcher);

    var _super = _createSuper(OrbitControls);

    function OrbitControls(object, domElement) {
      var _this;

      _classCallCheck(this, OrbitControls);

      _this = _super.call(this);
      _this.object = object;
      _this.domElement = domElement;
      _this.domElement.style.touchAction = 'none'; // disable touch scroll
      // Set to false to disable this control

      _this.enabled = true; // "target" sets the location of focus, where the object orbits around

      _this.target = new Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

      _this.minDistance = 0;
      _this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

      _this.minZoom = 0;
      _this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
      // Range is 0 to Math.PI radians.

      _this.minPolarAngle = 0; // radians

      _this.maxPolarAngle = Math.PI; // radians
      // How far you can orbit horizontally, upper and lower limits.
      // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )

      _this.minAzimuthAngle = -Infinity; // radians

      _this.maxAzimuthAngle = Infinity; // radians
      // Set to true to enable damping (inertia)
      // If damping is enabled, you must call controls.update() in your animation loop

      _this.enableDamping = false;
      _this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
      // Set to false to disable zooming

      _this.enableZoom = true;
      _this.zoomSpeed = 1.0; // Set to false to disable rotating

      _this.enableRotate = true;
      _this.rotateSpeed = 1.0; // Set to false to disable panning

      _this.enablePan = true;
      _this.panSpeed = 1.0;
      _this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up

      _this.keyPanSpeed = 7.0; // pixels moved per arrow key push
      // Set to true to automatically rotate around the target
      // If auto-rotate is enabled, you must call controls.update() in your animation loop

      _this.autoRotate = false;
      _this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60
      // The four arrow keys

      _this.keys = {
        LEFT: 'ArrowLeft',
        UP: 'ArrowUp',
        RIGHT: 'ArrowRight',
        BOTTOM: 'ArrowDown'
      }; // Mouse buttons

      _this.mouseButtons = {
        LEFT: MOUSE.ROTATE,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.PAN
      }; // Touch fingers

      _this.touches = {
        ONE: TOUCH.ROTATE,
        TWO: TOUCH.DOLLY_PAN
      }; // for reset

      _this.target0 = _this.target.clone();
      _this.position0 = _this.object.position.clone();
      _this.zoom0 = _this.object.zoom; // the target DOM element for key events

      _this._domElementKeyEvents = null; //
      // public methods
      //

      _this.getPolarAngle = function () {
        return spherical.phi;
      };

      _this.getAzimuthalAngle = function () {
        return spherical.theta;
      };

      _this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      };

      _this.listenToKeyEvents = function (domElement) {
        domElement.addEventListener('keydown', onKeyDown);
        this._domElementKeyEvents = domElement;
      };

      _this.saveState = function () {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };

      _this.reset = function () {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(_changeEvent);
        scope.update();
        state = STATE.NONE;
      }; // this method is exposed, but perhaps it would be better if we can make it private...


      _this.update = function () {
        var offset = new Vector3(); // so camera.up is the orbit axis

        var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        var quatInverse = quat.clone().invert();
        var lastPosition = new Vector3();
        var lastQuaternion = new Quaternion();
        var twoPI = 2 * Math.PI;
        return function update() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

          offset.applyQuaternion(quat); // angle from z-axis around y-axis

          spherical.setFromVector3(offset);

          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }

          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          } // restrict theta to be between desired limits


          var min = scope.minAzimuthAngle;
          var max = scope.maxAzimuthAngle;

          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
            if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;

            if (min <= max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          } // restrict phi to be between desired limits


          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale; // restrict radius to be between desired limits

          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }

          offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);

          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }

          scale = 1; // update condition is:
          // min(camera displacement, camera rotation in radians)^2 > EPS
          // using small-angle approximation cos(x/2) = 1 - x^2 / 8

          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(_changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }

          return false;
        };
      }();

      _this.dispose = function () {
        scope.domElement.removeEventListener('contextmenu', onContextMenu);
        scope.domElement.removeEventListener('pointerdown', onPointerDown);
        scope.domElement.removeEventListener('pointercancel', onPointerCancel);
        scope.domElement.removeEventListener('wheel', onMouseWheel);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);

        if (scope._domElementKeyEvents !== null) {
          scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
        } //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

      }; //
      // internals
      //


      var scope = _assertThisInitialized(_this);

      var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      var state = STATE.NONE;
      var EPS = 0.000001; // current position in spherical coordinates

      var spherical = new Spherical();
      var sphericalDelta = new Spherical();
      var scale = 1;
      var panOffset = new Vector3();
      var zoomChanged = false;
      var rotateStart = new Vector2();
      var rotateEnd = new Vector2();
      var rotateDelta = new Vector2();
      var panStart = new Vector2();
      var panEnd = new Vector2();
      var panDelta = new Vector2();
      var dollyStart = new Vector2();
      var dollyEnd = new Vector2();
      var dollyDelta = new Vector2();
      var pointers = [];
      var pointerPositions = {};

      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }

      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }

      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }

      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }

      var panLeft = function () {
        var v = new Vector3();
        return function panLeft(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

          v.multiplyScalar(-distance);
          panOffset.add(v);
        };
      }();

      var panUp = function () {
        var v = new Vector3();
        return function panUp(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.crossVectors(scope.object.up, v);
          }

          v.multiplyScalar(distance);
          panOffset.add(v);
        };
      }(); // deltaX and deltaY are in pixels; right and down are positive


      var pan = function () {
        var offset = new Vector3();
        return function pan(deltaX, deltaY) {
          var element = scope.domElement;

          if (scope.object.isPerspectiveCamera) {
            // perspective
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            var targetDistance = offset.length(); // half of the fov is center to top of screen

            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            // orthographic
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            // camera neither orthographic nor perspective
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
            scope.enablePan = false;
          }
        };
      }();

      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
          scope.enableZoom = false;
        }
      }

      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
          scope.enableZoom = false;
        }
      } //
      // event callbacks - update the object state
      //


      function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
      }

      function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
      }

      function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
      }

      function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }

      function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);

        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale());
        }

        dollyStart.copy(dollyEnd);
        scope.update();
      }

      function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }

      function handleMouseWheel(event) {
        if (event.deltaY < 0) {
          dollyIn(getZoomScale());
        } else if (event.deltaY > 0) {
          dollyOut(getZoomScale());
        }

        scope.update();
      }

      function handleKeyDown(event) {
        var needsUpdate = false;

        switch (event.code) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;

          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;

          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;

          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }

        if (needsUpdate) {
          // prevent the browser from scrolling on cursor keys
          event.preventDefault();
          scope.update();
        }
      }

      function handleTouchStartRotate() {
        if (pointers.length === 1) {
          rotateStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          var x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          var y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          rotateStart.set(x, y);
        }
      }

      function handleTouchStartPan() {
        if (pointers.length === 1) {
          panStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          var x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          var y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          panStart.set(x, y);
        }
      }

      function handleTouchStartDolly() {
        var dx = pointers[0].pageX - pointers[1].pageX;
        var dy = pointers[0].pageY - pointers[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }

      function handleTouchStartDollyPan() {
        if (scope.enableZoom) handleTouchStartDolly();
        if (scope.enablePan) handleTouchStartPan();
      }

      function handleTouchStartDollyRotate() {
        if (scope.enableZoom) handleTouchStartDolly();
        if (scope.enableRotate) handleTouchStartRotate();
      }

      function handleTouchMoveRotate(event) {
        if (pointers.length == 1) {
          rotateEnd.set(event.pageX, event.pageY);
        } else {
          var position = getSecondPointerPosition(event);
          var x = 0.5 * (event.pageX + position.x);
          var y = 0.5 * (event.pageY + position.y);
          rotateEnd.set(x, y);
        }

        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }

      function handleTouchMovePan(event) {
        if (pointers.length === 1) {
          panEnd.set(event.pageX, event.pageY);
        } else {
          var position = getSecondPointerPosition(event);
          var x = 0.5 * (event.pageX + position.x);
          var y = 0.5 * (event.pageY + position.y);
          panEnd.set(x, y);
        }

        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }

      function handleTouchMoveDolly(event) {
        var position = getSecondPointerPosition(event);
        var dx = event.pageX - position.x;
        var dy = event.pageY - position.y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }

      function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom) handleTouchMoveDolly(event);
        if (scope.enablePan) handleTouchMovePan(event);
      }

      function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom) handleTouchMoveDolly(event);
        if (scope.enableRotate) handleTouchMoveRotate(event);
      } //
      // event handlers - FSM: listen for events and reset state
      //


      function onPointerDown(event) {
        if (scope.enabled === false) return;

        if (pointers.length === 0) {
          scope.domElement.setPointerCapture(event.pointerId);
          scope.domElement.addEventListener('pointermove', onPointerMove);
          scope.domElement.addEventListener('pointerup', onPointerUp);
        } //


        addPointer(event);

        if (event.pointerType === 'touch') {
          onTouchStart(event);
        } else {
          onMouseDown(event);
        }
      }

      function onPointerMove(event) {
        if (scope.enabled === false) return;

        if (event.pointerType === 'touch') {
          onTouchMove(event);
        } else {
          onMouseMove(event);
        }
      }

      function onPointerUp(event) {
        removePointer(event);

        if (pointers.length === 0) {
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener('pointermove', onPointerMove);
          scope.domElement.removeEventListener('pointerup', onPointerUp);
        }

        scope.dispatchEvent(_endEvent);
        state = STATE.NONE;
      }

      function onPointerCancel(event) {
        removePointer(event);
      }

      function onMouseDown(event) {
        var mouseAction;

        switch (event.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;

          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;

          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;

          default:
            mouseAction = -1;
        }

        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false) return;
            handleMouseDownDolly(event);
            state = STATE.DOLLY;
            break;

          case MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            }

            break;

          case MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            }

            break;

          default:
            state = STATE.NONE;
        }

        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }

      function onMouseMove(event) {
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false) return;
            handleMouseMoveRotate(event);
            break;

          case STATE.DOLLY:
            if (scope.enableZoom === false) return;
            handleMouseMoveDolly(event);
            break;

          case STATE.PAN:
            if (scope.enablePan === false) return;
            handleMouseMovePan(event);
            break;
        }
      }

      function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
        event.preventDefault();
        scope.dispatchEvent(_startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(_endEvent);
      }

      function onKeyDown(event) {
        if (scope.enabled === false || scope.enablePan === false) return;
        handleKeyDown(event);
      }

      function onTouchStart(event) {
        trackPointer(event);

        switch (pointers.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false) return;
                handleTouchStartRotate();
                state = STATE.TOUCH_ROTATE;
                break;

              case TOUCH.PAN:
                if (scope.enablePan === false) return;
                handleTouchStartPan();
                state = STATE.TOUCH_PAN;
                break;

              default:
                state = STATE.NONE;
            }

            break;

          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false) return;
                handleTouchStartDollyPan();
                state = STATE.TOUCH_DOLLY_PAN;
                break;

              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false) return;
                handleTouchStartDollyRotate();
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;

              default:
                state = STATE.NONE;
            }

            break;

          default:
            state = STATE.NONE;
        }

        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }

      function onTouchMove(event) {
        trackPointer(event);

        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false) return;
            handleTouchMoveRotate(event);
            scope.update();
            break;

          case STATE.TOUCH_PAN:
            if (scope.enablePan === false) return;
            handleTouchMovePan(event);
            scope.update();
            break;

          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false) return;
            handleTouchMoveDollyPan(event);
            scope.update();
            break;

          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false) return;
            handleTouchMoveDollyRotate(event);
            scope.update();
            break;

          default:
            state = STATE.NONE;
        }
      }

      function onContextMenu(event) {
        if (scope.enabled === false) return;
        event.preventDefault();
      }

      function addPointer(event) {
        pointers.push(event);
      }

      function removePointer(event) {
        delete pointerPositions[event.pointerId];

        for (var i = 0; i < pointers.length; i++) {
          if (pointers[i].pointerId == event.pointerId) {
            pointers.splice(i, 1);
            return;
          }
        }
      }

      function trackPointer(event) {
        var position = pointerPositions[event.pointerId];

        if (position === undefined) {
          position = new Vector2();
          pointerPositions[event.pointerId] = position;
        }

        position.set(event.pageX, event.pageY);
      }

      function getSecondPointerPosition(event) {
        var pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
        return pointerPositions[pointer.pointerId];
      } //


      scope.domElement.addEventListener('contextmenu', onContextMenu);
      scope.domElement.addEventListener('pointerdown', onPointerDown);
      scope.domElement.addEventListener('pointercancel', onPointerCancel);
      scope.domElement.addEventListener('wheel', onMouseWheel, {
        passive: false
      }); // force an update at start

      _this.update();

      return _this;
    }

    return _createClass(OrbitControls);
  }(EventDispatcher); // This set of controls performs orbiting, dollying (zooming), and panning.

  let sce, cam, ren, cc;
  let zero = new Vector3();
  let size = new Vector2();
  class Stage {
    constructor(w, h) {
      sce = new Scene$1();
      cam = new PerspectiveCamera(60, w / h, 0.001, 10000);

      ren = new WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      ren.setClearColor(new Color$1(1, 1, 1));
      cc = new OrbitControls(cam, ren.domElement);
      cc.enabled = true;
      cam.position.z = -50;
      cam.lookAt(zero);

      this.domElement = ren.domElement;
      this.resize(w, h);

      this.camera = cam;
      this.renderer = ren;
      this.scene = sce;
      this.controls = cc;

      window.camera = cam;
      window.target = cc.target;
    }

    resize(w, h) {
      ren.setSize(w, h);
      size.x = w;
      size.y = h;
      ren.setPixelRatio(window.devicePixelRatio);
      cam.aspect = w / h;
      cam.updateProjectionMatrix();
    }

    render() {
      if (cc && cc.enabled) cc.update();
      ren.render(sce, cam);
    }

    add(obj) {
      sce.add(obj);
    }

    static add(obj) {
      sce.add(obj);
    }
    get size() {
      return size;
    }
    static get size() {
      return size;
    }
  }

  /**
   * dat-gui JavaScript Controller Library
   * https://github.com/dataarts/dat.gui
   *
   * Copyright 2011 Data Arts Team, Google Creative Lab
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   */
  function ___$insertStyle(css) {
    if (!css) {
      return;
    }

    if (typeof window === 'undefined') {
      return;
    }

    var style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
  }

  function colorToString(color, forceCSSHex) {
    var colorFormat = color.__state.conversionName.toString();

    var r = Math.round(color.r);
    var g = Math.round(color.g);
    var b = Math.round(color.b);
    var a = color.a;
    var h = Math.round(color.h);
    var s = color.s.toFixed(1);
    var v = color.v.toFixed(1);

    if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
      var str = color.hex.toString(16);

      while (str.length < 6) {
        str = '0' + str;
      }

      return '#' + str;
    } else if (colorFormat === 'CSS_RGB') {
      return 'rgb(' + r + ',' + g + ',' + b + ')';
    } else if (colorFormat === 'CSS_RGBA') {
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    } else if (colorFormat === 'HEX') {
      return '0x' + color.hex.toString(16);
    } else if (colorFormat === 'RGB_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ']';
    } else if (colorFormat === 'RGBA_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ',' + a + ']';
    } else if (colorFormat === 'RGB_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + '}';
    } else if (colorFormat === 'RGBA_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
    } else if (colorFormat === 'HSV_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + '}';
    } else if (colorFormat === 'HSVA_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
    }

    return 'unknown format';
  }

  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;
  var Common = {
    BREAK: {},
    extend: function extend(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (!this.isUndefined(obj[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    defaults: function defaults(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (this.isUndefined(target[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    compose: function compose() {
      var toCall = ARR_SLICE.call(arguments);
      return function () {
        var args = ARR_SLICE.call(arguments);

        for (var i = toCall.length - 1; i >= 0; i--) {
          args = [toCall[i].apply(this, args)];
        }

        return args[0];
      };
    },
    each: function each(obj, itr, scope) {
      if (!obj) {
        return;
      }

      if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
        obj.forEach(itr, scope);
      } else if (obj.length === obj.length + 0) {
        var key = void 0;
        var l = void 0;

        for (key = 0, l = obj.length; key < l; key++) {
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
            return;
          }
        }
      } else {
        for (var _key in obj) {
          if (itr.call(scope, obj[_key], _key) === this.BREAK) {
            return;
          }
        }
      }
    },
    defer: function defer(fnc) {
      setTimeout(fnc, 0);
    },
    debounce: function debounce(func, threshold, callImmediately) {
      var timeout = void 0;
      return function () {
        var obj = this;
        var args = arguments;

        function delayed() {
          timeout = null;
          if (!callImmediately) func.apply(obj, args);
        }

        var callNow = callImmediately || !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(delayed, threshold);

        if (callNow) {
          func.apply(obj, args);
        }
      };
    },
    toArray: function toArray(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },
    isUndefined: function isUndefined(obj) {
      return obj === undefined;
    },
    isNull: function isNull(obj) {
      return obj === null;
    },
    isNaN: function (_isNaN) {
      function isNaN(_x) {
        return _isNaN.apply(this, arguments);
      }

      isNaN.toString = function () {
        return _isNaN.toString();
      };

      return isNaN;
    }(function (obj) {
      return isNaN(obj);
    }),
    isArray: Array.isArray || function (obj) {
      return obj.constructor === Array;
    },
    isObject: function isObject(obj) {
      return obj === Object(obj);
    },
    isNumber: function isNumber(obj) {
      return obj === obj + 0;
    },
    isString: function isString(obj) {
      return obj === obj + '';
    },
    isBoolean: function isBoolean(obj) {
      return obj === false || obj === true;
    },
    isFunction: function isFunction(obj) {
      return obj instanceof Function;
    }
  };
  var INTERPRETATIONS = [{
    litmus: Common.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
          };
        },
        write: colorToString
      },
      SIX_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9]{6})$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString(), 0)
          };
        },
        write: colorToString
      },
      CSS_RGB: {
        read: function read(original) {
          var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3])
          };
        },
        write: colorToString
      },
      CSS_RGBA: {
        read: function read(original) {
          var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
            a: parseFloat(test[4])
          };
        },
        write: colorToString
      }
    }
  }, {
    litmus: Common.isNumber,
    conversions: {
      HEX: {
        read: function read(original) {
          return {
            space: 'HEX',
            hex: original,
            conversionName: 'HEX'
          };
        },
        write: function write(color) {
          return color.hex;
        }
      }
    }
  }, {
    litmus: Common.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function read(original) {
          if (original.length !== 3) {
            return false;
          }

          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b];
        }
      },
      RGBA_ARRAY: {
        read: function read(original) {
          if (original.length !== 4) return false;
          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2],
            a: original[3]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b, color.a];
        }
      }
    }
  }, {
    litmus: Common.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a
          };
        }
      },
      RGB_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b
          };
        }
      },
      HSVA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
            a: color.a
          };
        }
      },
      HSV_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v
          };
        }
      }
    }
  }];
  var result = void 0;
  var toReturn = void 0;

  var interpret = function interpret() {
    toReturn = false;
    var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
    Common.each(INTERPRETATIONS, function (family) {
      if (family.litmus(original)) {
        Common.each(family.conversions, function (conversion, conversionName) {
          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return Common.BREAK;
          }
        });
        return Common.BREAK;
      }
    });
    return toReturn;
  };

  var tmpComponent = void 0;
  var ColorMath = {
    hsv_to_rgb: function hsv_to_rgb(h, s, v) {
      var hi = Math.floor(h / 60) % 6;
      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - f * s);
      var t = v * (1.0 - (1.0 - f) * s);
      var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };
    },
    rgb_to_hsv: function rgb_to_hsv(r, g, b) {
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h = void 0;
      var s = void 0;

      if (max !== 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }

      h /= 6;

      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },
    rgb_to_hex: function rgb_to_hex(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },
    component_from_hex: function component_from_hex(hex, componentIndex) {
      return hex >> componentIndex * 8 & 0xFF;
    },
    hex_with_component: function hex_with_component(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
    }
  };

  var _typeof = typeof Symbol === "function" && _typeof$1(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof$1(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof$1(obj);
  };

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + _typeof$1(superClass));
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (_typeof$1(call) === "object" || typeof call === "function") ? call : self;
  };

  var Color = function () {
    function Color() {
      classCallCheck(this, Color);
      this.__state = interpret.apply(this, arguments);

      if (this.__state === false) {
        throw new Error('Failed to interpret color arguments');
      }

      this.__state.a = this.__state.a || 1;
    }

    createClass(Color, [{
      key: 'toString',
      value: function toString() {
        return colorToString(this);
      }
    }, {
      key: 'toHexString',
      value: function toHexString() {
        return colorToString(this, true);
      }
    }, {
      key: 'toOriginal',
      value: function toOriginal() {
        return this.__state.conversion.write(this);
      }
    }]);
    return Color;
  }();

  function defineRGBComponent(target, component, componentHexIndex) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        Color.recalculateRGB(this, component, componentHexIndex);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'RGB') {
          Color.recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;
      }
    });
  }

  function defineHSVComponent(target, component) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'HSV') {
          return this.__state[component];
        }

        Color.recalculateHSV(this);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'HSV') {
          Color.recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;
      }
    });
  }

  Color.recalculateRGB = function (color, component, componentHexIndex) {
    if (color.__state.space === 'HEX') {
      color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
    } else if (color.__state.space === 'HSV') {
      Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
    } else {
      throw new Error('Corrupted color state');
    }
  };

  Color.recalculateHSV = function (color) {
    var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
    Common.extend(color.__state, {
      s: result.s,
      v: result.v
    });

    if (!Common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (Common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }
  };

  Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);
  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');
  Object.defineProperty(Color.prototype, 'a', {
    get: function get$$1() {
      return this.__state.a;
    },
    set: function set$$1(v) {
      this.__state.a = v;
    }
  });
  Object.defineProperty(Color.prototype, 'hex', {
    get: function get$$1() {
      if (this.__state.space !== 'HEX') {
        this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
        this.__state.space = 'HEX';
      }

      return this.__state.hex;
    },
    set: function set$$1(v) {
      this.__state.space = 'HEX';
      this.__state.hex = v;
    }
  });

  var Controller = function () {
    function Controller(object, property) {
      classCallCheck(this, Controller);
      this.initialValue = object[property];
      this.domElement = document.createElement('div');
      this.object = object;
      this.property = property;
      this.__onChange = undefined;
      this.__onFinishChange = undefined;
    }

    createClass(Controller, [{
      key: 'onChange',
      value: function onChange(fnc) {
        this.__onChange = fnc;
        return this;
      }
    }, {
      key: 'onFinishChange',
      value: function onFinishChange(fnc) {
        this.__onFinishChange = fnc;
        return this;
      }
    }, {
      key: 'setValue',
      value: function setValue(newValue) {
        this.object[this.property] = newValue;

        if (this.__onChange) {
          this.__onChange.call(this, newValue);
        }

        this.updateDisplay();
        return this;
      }
    }, {
      key: 'getValue',
      value: function getValue() {
        return this.object[this.property];
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        return this;
      }
    }, {
      key: 'isModified',
      value: function isModified() {
        return this.initialValue !== this.getValue();
      }
    }]);
    return Controller;
  }();

  var EVENT_MAP = {
    HTMLEvents: ['change'],
    MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
    KeyboardEvents: ['keydown']
  };
  var EVENT_MAP_INV = {};
  Common.each(EVENT_MAP, function (v, k) {
    Common.each(v, function (e) {
      EVENT_MAP_INV[e] = k;
    });
  });
  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {
    if (val === '0' || Common.isUndefined(val)) {
      return 0;
    }

    var match = val.match(CSS_VALUE_PIXELS);

    if (!Common.isNull(match)) {
      return parseFloat(match[1]);
    }

    return 0;
  }

  var dom = {
    makeSelectable: function makeSelectable(elem, selectable) {
      if (elem === undefined || elem.style === undefined) return;
      elem.onselectstart = selectable ? function () {
        return false;
      } : function () {};
      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';
    },
    makeFullscreen: function makeFullscreen(elem, hor, vert) {
      var vertical = vert;
      var horizontal = hor;

      if (Common.isUndefined(horizontal)) {
        horizontal = true;
      }

      if (Common.isUndefined(vertical)) {
        vertical = true;
      }

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }

      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }
    },
    fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
      var params = pars || {};
      var className = EVENT_MAP_INV[eventType];

      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }

      var evt = document.createEvent(className);

      switch (className) {
        case 'MouseEvents':
          {
            var clientX = params.x || params.clientX || 0;
            var clientY = params.y || params.clientY || 0;
            evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, 0, clientX, clientY, false, false, false, false, 0, null);
            break;
          }

        case 'KeyboardEvents':
          {
            var init = evt.initKeyboardEvent || evt.initKeyEvent;
            Common.defaults(params, {
              cancelable: true,
              ctrlKey: false,
              altKey: false,
              shiftKey: false,
              metaKey: false,
              keyCode: undefined,
              charCode: undefined
            });
            init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
            break;
          }

        default:
          {
            evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
            break;
          }
      }

      Common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },
    bind: function bind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.addEventListener) {
        elem.addEventListener(event, func, bool);
      } else if (elem.attachEvent) {
        elem.attachEvent('on' + event, func);
      }

      return dom;
    },
    unbind: function unbind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.removeEventListener) {
        elem.removeEventListener(event, func, bool);
      } else if (elem.detachEvent) {
        elem.detachEvent('on' + event, func);
      }

      return dom;
    },
    addClass: function addClass(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);

        if (classes.indexOf(className) === -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }

      return dom;
    },
    removeClass: function removeClass(elem, className) {
      if (className) {
        if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);

          if (index !== -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }

      return dom;
    },
    hasClass: function hasClass(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },
    getWidth: function getWidth(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
    },
    getHeight: function getHeight(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
    },
    getOffset: function getOffset(el) {
      var elem = el;
      var offset = {
        left: 0,
        top: 0
      };

      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
          elem = elem.offsetParent;
        } while (elem);
      }

      return offset;
    },
    isActive: function isActive(elem) {
      return elem === document.activeElement && (elem.type || elem.href);
    }
  };

  var BooleanController = function (_Controller) {
    inherits(BooleanController, _Controller);

    function BooleanController(object, property) {
      classCallCheck(this, BooleanController);

      var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));

      var _this = _this2;
      _this2.__prev = _this2.getValue();
      _this2.__checkbox = document.createElement('input');

      _this2.__checkbox.setAttribute('type', 'checkbox');

      function onChange() {
        _this.setValue(!_this.__prev);
      }

      dom.bind(_this2.__checkbox, 'change', onChange, false);

      _this2.domElement.appendChild(_this2.__checkbox);

      _this2.updateDisplay();

      return _this2;
    }

    createClass(BooleanController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        this.__prev = this.getValue();
        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (this.getValue() === true) {
          this.__checkbox.setAttribute('checked', 'checked');

          this.__checkbox.checked = true;
          this.__prev = true;
        } else {
          this.__checkbox.checked = false;
          this.__prev = false;
        }

        return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return BooleanController;
  }(Controller);

  var OptionController = function (_Controller) {
    inherits(OptionController, _Controller);

    function OptionController(object, property, opts) {
      classCallCheck(this, OptionController);

      var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));

      var options = opts;
      var _this = _this2;
      _this2.__select = document.createElement('select');

      if (Common.isArray(options)) {
        var map = {};
        Common.each(options, function (element) {
          map[element] = element;
        });
        options = map;
      }

      Common.each(options, function (value, key) {
        var opt = document.createElement('option');
        opt.innerHTML = key;
        opt.setAttribute('value', value);

        _this.__select.appendChild(opt);
      });

      _this2.updateDisplay();

      dom.bind(_this2.__select, 'change', function () {
        var desiredValue = this.options[this.selectedIndex].value;

        _this.setValue(desiredValue);
      });

      _this2.domElement.appendChild(_this2.__select);

      return _this2;
    }

    createClass(OptionController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (dom.isActive(this.__select)) return this;
        this.__select.value = this.getValue();
        return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return OptionController;
  }(Controller);

  var StringController = function (_Controller) {
    inherits(StringController, _Controller);

    function StringController(object, property) {
      classCallCheck(this, StringController);

      var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));

      var _this = _this2;

      function onChange() {
        _this.setValue(_this.__input.value);
      }

      function onBlur() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'keyup', onChange);
      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          this.blur();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(StringController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (!dom.isActive(this.__input)) {
          this.__input.value = this.getValue();
        }

        return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return StringController;
  }(Controller);

  function numDecimals(x) {
    var _x = x.toString();

    if (_x.indexOf('.') > -1) {
      return _x.length - _x.indexOf('.') - 1;
    }

    return 0;
  }

  var NumberController = function (_Controller) {
    inherits(NumberController, _Controller);

    function NumberController(object, property, params) {
      classCallCheck(this, NumberController);

      var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));

      var _params = params || {};

      _this.__min = _params.min;
      _this.__max = _params.max;
      _this.__step = _params.step;

      if (Common.isUndefined(_this.__step)) {
        if (_this.initialValue === 0) {
          _this.__impliedStep = 1;
        } else {
          _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
        }
      } else {
        _this.__impliedStep = _this.__step;
      }

      _this.__precision = numDecimals(_this.__impliedStep);
      return _this;
    }

    createClass(NumberController, [{
      key: 'setValue',
      value: function setValue(v) {
        var _v = v;

        if (this.__min !== undefined && _v < this.__min) {
          _v = this.__min;
        } else if (this.__max !== undefined && _v > this.__max) {
          _v = this.__max;
        }

        if (this.__step !== undefined && _v % this.__step !== 0) {
          _v = Math.round(_v / this.__step) * this.__step;
        }

        return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
      }
    }, {
      key: 'min',
      value: function min(minValue) {
        this.__min = minValue;
        return this;
      }
    }, {
      key: 'max',
      value: function max(maxValue) {
        this.__max = maxValue;
        return this;
      }
    }, {
      key: 'step',
      value: function step(stepValue) {
        this.__step = stepValue;
        this.__impliedStep = stepValue;
        this.__precision = numDecimals(stepValue);
        return this;
      }
    }]);
    return NumberController;
  }(Controller);

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  var NumberControllerBox = function (_NumberController) {
    inherits(NumberControllerBox, _NumberController);

    function NumberControllerBox(object, property, params) {
      classCallCheck(this, NumberControllerBox);

      var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));

      _this2.__truncationSuspended = false;
      var _this = _this2;
      var prevY = void 0;

      function onChange() {
        var attempted = parseFloat(_this.__input.value);

        if (!Common.isNaN(attempted)) {
          _this.setValue(attempted);
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onBlur() {
        onFinish();
      }

      function onMouseDrag(e) {
        var diff = prevY - e.clientY;

        _this.setValue(_this.getValue() + diff * _this.__impliedStep);

        prevY = e.clientY;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);
        onFinish();
      }

      function onMouseDown(e) {
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        prevY = e.clientY;
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'mousedown', onMouseDown);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          _this.__truncationSuspended = true;
          this.blur();
          _this.__truncationSuspended = false;
          onFinish();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(NumberControllerBox, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
        return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerBox;
  }(NumberController);

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  var NumberControllerSlider = function (_NumberController) {
    inherits(NumberControllerSlider, _NumberController);

    function NumberControllerSlider(object, property, min, max, step) {
      classCallCheck(this, NumberControllerSlider);

      var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, {
        min: min,
        max: max,
        step: step
      }));

      var _this = _this2;
      _this2.__background = document.createElement('div');
      _this2.__foreground = document.createElement('div');
      dom.bind(_this2.__background, 'mousedown', onMouseDown);
      dom.bind(_this2.__background, 'touchstart', onTouchStart);
      dom.addClass(_this2.__background, 'slider');
      dom.addClass(_this2.__foreground, 'slider-fg');

      function onMouseDown(e) {
        document.activeElement.blur();
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        onMouseDrag(e);
      }

      function onMouseDrag(e) {
        e.preventDefault();

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));

        return false;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onTouchStart(e) {
        if (e.touches.length !== 1) {
          return;
        }

        dom.bind(window, 'touchmove', onTouchMove);
        dom.bind(window, 'touchend', onTouchEnd);
        onTouchMove(e);
      }

      function onTouchMove(e) {
        var clientX = e.touches[0].clientX;

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      }

      function onTouchEnd() {
        dom.unbind(window, 'touchmove', onTouchMove);
        dom.unbind(window, 'touchend', onTouchEnd);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.updateDisplay();

      _this2.__background.appendChild(_this2.__foreground);

      _this2.domElement.appendChild(_this2.__background);

      return _this2;
    }

    createClass(NumberControllerSlider, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var pct = (this.getValue() - this.__min) / (this.__max - this.__min);

        this.__foreground.style.width = pct * 100 + '%';
        return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerSlider;
  }(NumberController);

  var FunctionController = function (_Controller) {
    inherits(FunctionController, _Controller);

    function FunctionController(object, property, text) {
      classCallCheck(this, FunctionController);

      var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));

      var _this = _this2;
      _this2.__button = document.createElement('div');
      _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
      dom.bind(_this2.__button, 'click', function (e) {
        e.preventDefault();

        _this.fire();

        return false;
      });
      dom.addClass(_this2.__button, 'button');

      _this2.domElement.appendChild(_this2.__button);

      return _this2;
    }

    createClass(FunctionController, [{
      key: 'fire',
      value: function fire() {
        if (this.__onChange) {
          this.__onChange.call(this);
        }

        this.getValue().call(this.object);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
      }
    }]);
    return FunctionController;
  }(Controller);

  var ColorController = function (_Controller) {
    inherits(ColorController, _Controller);

    function ColorController(object, property) {
      classCallCheck(this, ColorController);

      var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));

      _this2.__color = new Color(_this2.getValue());
      _this2.__temp = new Color(0);
      var _this = _this2;
      _this2.domElement = document.createElement('div');
      dom.makeSelectable(_this2.domElement, false);
      _this2.__selector = document.createElement('div');
      _this2.__selector.className = 'selector';
      _this2.__saturation_field = document.createElement('div');
      _this2.__saturation_field.className = 'saturation-field';
      _this2.__field_knob = document.createElement('div');
      _this2.__field_knob.className = 'field-knob';
      _this2.__field_knob_border = '2px solid ';
      _this2.__hue_knob = document.createElement('div');
      _this2.__hue_knob.className = 'hue-knob';
      _this2.__hue_field = document.createElement('div');
      _this2.__hue_field.className = 'hue-field';
      _this2.__input = document.createElement('input');
      _this2.__input.type = 'text';
      _this2.__input_textShadow = '0 1px 1px ';
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          onBlur.call(this);
        }
      });
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__selector, 'mousedown', function () {
        dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      dom.bind(_this2.__selector, 'touchstart', function () {
        dom.addClass(this, 'drag').bind(window, 'touchend', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      var valueField = document.createElement('div');
      Common.extend(_this2.__selector.style, {
        width: '122px',
        height: '102px',
        padding: '3px',
        backgroundColor: '#222',
        boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
      });
      Common.extend(_this2.__field_knob.style, {
        position: 'absolute',
        width: '12px',
        height: '12px',
        border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
        boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
        borderRadius: '12px',
        zIndex: 1
      });
      Common.extend(_this2.__hue_knob.style, {
        position: 'absolute',
        width: '15px',
        height: '2px',
        borderRight: '4px solid #fff',
        zIndex: 1
      });
      Common.extend(_this2.__saturation_field.style, {
        width: '100px',
        height: '100px',
        border: '1px solid #555',
        marginRight: '3px',
        display: 'inline-block',
        cursor: 'pointer'
      });
      Common.extend(valueField.style, {
        width: '100%',
        height: '100%',
        background: 'none'
      });
      linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
      Common.extend(_this2.__hue_field.style, {
        width: '15px',
        height: '100px',
        border: '1px solid #555',
        cursor: 'ns-resize',
        position: 'absolute',
        top: '3px',
        right: '3px'
      });
      hueGradient(_this2.__hue_field);
      Common.extend(_this2.__input.style, {
        outline: 'none',
        textAlign: 'center',
        color: '#fff',
        border: 0,
        fontWeight: 'bold',
        textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
      });
      dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
      dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
      dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
      dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
      dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
      dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);

      function fieldDown(e) {
        setSV(e);
        dom.bind(window, 'mousemove', setSV);
        dom.bind(window, 'touchmove', setSV);
        dom.bind(window, 'mouseup', fieldUpSV);
        dom.bind(window, 'touchend', fieldUpSV);
      }

      function fieldDownH(e) {
        setH(e);
        dom.bind(window, 'mousemove', setH);
        dom.bind(window, 'touchmove', setH);
        dom.bind(window, 'mouseup', fieldUpH);
        dom.bind(window, 'touchend', fieldUpH);
      }

      function fieldUpSV() {
        dom.unbind(window, 'mousemove', setSV);
        dom.unbind(window, 'touchmove', setSV);
        dom.unbind(window, 'mouseup', fieldUpSV);
        dom.unbind(window, 'touchend', fieldUpSV);
        onFinish();
      }

      function fieldUpH() {
        dom.unbind(window, 'mousemove', setH);
        dom.unbind(window, 'touchmove', setH);
        dom.unbind(window, 'mouseup', fieldUpH);
        dom.unbind(window, 'touchend', fieldUpH);
        onFinish();
      }

      function onBlur() {
        var i = interpret(this.value);

        if (i !== false) {
          _this.__color.__state = i;

          _this.setValue(_this.__color.toOriginal());
        } else {
          this.value = _this.__color.toString();
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.__color.toOriginal());
        }
      }

      _this2.__saturation_field.appendChild(valueField);

      _this2.__selector.appendChild(_this2.__field_knob);

      _this2.__selector.appendChild(_this2.__saturation_field);

      _this2.__selector.appendChild(_this2.__hue_field);

      _this2.__hue_field.appendChild(_this2.__hue_knob);

      _this2.domElement.appendChild(_this2.__input);

      _this2.domElement.appendChild(_this2.__selector);

      _this2.updateDisplay();

      function setSV(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__saturation_field.getBoundingClientRect();

        var _ref = e.touches && e.touches[0] || e,
            clientX = _ref.clientX,
            clientY = _ref.clientY;

        var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
        var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (v > 1) {
          v = 1;
        } else if (v < 0) {
          v = 0;
        }

        if (s > 1) {
          s = 1;
        } else if (s < 0) {
          s = 0;
        }

        _this.__color.v = v;
        _this.__color.s = s;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      function setH(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__hue_field.getBoundingClientRect();

        var _ref2 = e.touches && e.touches[0] || e,
            clientY = _ref2.clientY;

        var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (h > 1) {
          h = 1;
        } else if (h < 0) {
          h = 0;
        }

        _this.__color.h = h * 360;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      return _this2;
    }

    createClass(ColorController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var i = interpret(this.getValue());

        if (i !== false) {
          var mismatch = false;
          Common.each(Color.COMPONENTS, function (component) {
            if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
              mismatch = true;
              return {};
            }
          }, this);

          if (mismatch) {
            Common.extend(this.__color.__state, i);
          }
        }

        Common.extend(this.__temp.__state, this.__color.__state);
        this.__temp.a = 1;
        var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;

        var _flip = 255 - flip;

        Common.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + 'px',
          marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
          backgroundColor: this.__temp.toHexString(),
          border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
        });
        this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
        this.__temp.s = 1;
        this.__temp.v = 1;
        linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
        this.__input.value = this.__color.toString();
        Common.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
          textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
        });
      }
    }]);
    return ColorController;
  }(Controller);

  var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];

  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    Common.each(vendors, function (vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
    });
  }

  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  }

  var css = {
    load: function load(url, indoc) {
      var doc = indoc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function inject(cssContent, indoc) {
      var doc = indoc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = cssContent;
      var head = doc.getElementsByTagName('head')[0];

      try {
        head.appendChild(injected);
      } catch (e) {}
    }
  };
  var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

  var ControllerFactory = function ControllerFactory(object, property) {
    var initialValue = object[property];

    if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
      return new OptionController(object, property, arguments[2]);
    }

    if (Common.isNumber(initialValue)) {
      if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
        if (Common.isNumber(arguments[4])) {
          return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
        }

        return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
      }

      if (Common.isNumber(arguments[4])) {
        return new NumberControllerBox(object, property, {
          min: arguments[2],
          max: arguments[3],
          step: arguments[4]
        });
      }

      return new NumberControllerBox(object, property, {
        min: arguments[2],
        max: arguments[3]
      });
    }

    if (Common.isString(initialValue)) {
      return new StringController(object, property);
    }

    if (Common.isFunction(initialValue)) {
      return new FunctionController(object, property, '');
    }

    if (Common.isBoolean(initialValue)) {
      return new BooleanController(object, property);
    }

    return null;
  };

  function requestAnimationFrame$1(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1;

  var CenteredDiv = function () {
    function CenteredDiv() {
      classCallCheck(this, CenteredDiv);
      this.backgroundElement = document.createElement('div');
      Common.extend(this.backgroundElement.style, {
        backgroundColor: 'rgba(0,0,0,0.8)',
        top: 0,
        left: 0,
        display: 'none',
        zIndex: '1000',
        opacity: 0,
        WebkitTransition: 'opacity 0.2s linear',
        transition: 'opacity 0.2s linear'
      });
      dom.makeFullscreen(this.backgroundElement);
      this.backgroundElement.style.position = 'fixed';
      this.domElement = document.createElement('div');
      Common.extend(this.domElement.style, {
        position: 'fixed',
        display: 'none',
        zIndex: '1001',
        opacity: 0,
        WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
        transition: 'transform 0.2s ease-out, opacity 0.2s linear'
      });
      document.body.appendChild(this.backgroundElement);
      document.body.appendChild(this.domElement);

      var _this = this;

      dom.bind(this.backgroundElement, 'click', function () {
        _this.hide();
      });
    }

    createClass(CenteredDiv, [{
      key: 'show',
      value: function show() {
        var _this = this;

        this.backgroundElement.style.display = 'block';
        this.domElement.style.display = 'block';
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
        this.layout();
        Common.defer(function () {
          _this.backgroundElement.style.opacity = 1;
          _this.domElement.style.opacity = 1;
          _this.domElement.style.webkitTransform = 'scale(1)';
        });
      }
    }, {
      key: 'hide',
      value: function hide() {
        var _this = this;

        var hide = function hide() {
          _this.domElement.style.display = 'none';
          _this.backgroundElement.style.display = 'none';
          dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
          dom.unbind(_this.domElement, 'transitionend', hide);
          dom.unbind(_this.domElement, 'oTransitionEnd', hide);
        };

        dom.bind(this.domElement, 'webkitTransitionEnd', hide);
        dom.bind(this.domElement, 'transitionend', hide);
        dom.bind(this.domElement, 'oTransitionEnd', hide);
        this.backgroundElement.style.opacity = 0;
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
        this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
      }
    }]);
    return CenteredDiv;
  }();

  var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

  css.inject(styleSheet);
  var CSS_NAMESPACE = 'dg';
  var HIDE_KEY_CODE = 72;
  var CLOSE_BUTTON_HEIGHT = 20;
  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = function () {
    try {
      return !!window.localStorage;
    } catch (e) {
      return false;
    }
  }();

  var SAVE_DIALOGUE = void 0;
  var autoPlaceVirgin = true;
  var autoPlaceContainer = void 0;
  var hide = false;
  var hideableGuis = [];

  var GUI = function GUI(pars) {
    var _this = this;

    var params = pars || {};
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);
    dom.addClass(this.domElement, CSS_NAMESPACE);
    this.__folders = {};
    this.__controllers = [];
    this.__rememberedObjects = [];
    this.__rememberedObjectIndecesToControllers = [];
    this.__listening = [];
    params = Common.defaults(params, {
      closeOnTop: false,
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });
    params = Common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });

    if (!Common.isUndefined(params.load)) {
      if (params.preset) {
        params.load.preset = params.preset;
      }
    } else {
      params.load = {
        preset: DEFAULT_DEFAULT_PRESET_NAME
      };
    }

    if (Common.isUndefined(params.parent) && params.hideable) {
      hideableGuis.push(this);
    }

    params.resizable = Common.isUndefined(params.parent) && params.resizable;

    if (params.autoPlace && Common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }

    var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
    var saveToLocalStorage = void 0;
    var titleRow = void 0;
    Object.defineProperties(this, {
      parent: {
        get: function get$$1() {
          return params.parent;
        }
      },
      scrollable: {
        get: function get$$1() {
          return params.scrollable;
        }
      },
      autoPlace: {
        get: function get$$1() {
          return params.autoPlace;
        }
      },
      closeOnTop: {
        get: function get$$1() {
          return params.closeOnTop;
        }
      },
      preset: {
        get: function get$$1() {
          if (_this.parent) {
            return _this.getRoot().preset;
          }

          return params.load.preset;
        },
        set: function set$$1(v) {
          if (_this.parent) {
            _this.getRoot().preset = v;
          } else {
            params.load.preset = v;
          }

          setPresetSelectIndex(this);

          _this.revert();
        }
      },
      width: {
        get: function get$$1() {
          return params.width;
        },
        set: function set$$1(v) {
          params.width = v;
          setWidth(_this, v);
        }
      },
      name: {
        get: function get$$1() {
          return params.name;
        },
        set: function set$$1(v) {
          params.name = v;

          if (titleRow) {
            titleRow.innerHTML = params.name;
          }
        }
      },
      closed: {
        get: function get$$1() {
          return params.closed;
        },
        set: function set$$1(v) {
          params.closed = v;

          if (params.closed) {
            dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
          } else {
            dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
          }

          this.onResize();

          if (_this.__closeButton) {
            _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
          }
        }
      },
      load: {
        get: function get$$1() {
          return params.load;
        }
      },
      useLocalStorage: {
        get: function get$$1() {
          return useLocalStorage;
        },
        set: function set$$1(bool) {
          if (SUPPORTS_LOCAL_STORAGE) {
            useLocalStorage = bool;

            if (bool) {
              dom.bind(window, 'unload', saveToLocalStorage);
            } else {
              dom.unbind(window, 'unload', saveToLocalStorage);
            }

            localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
          }
        }
      }
    });

    if (Common.isUndefined(params.parent)) {
      this.closed = params.closed || false;
      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      if (SUPPORTS_LOCAL_STORAGE) {
        if (useLocalStorage) {
          _this.useLocalStorage = true;
          var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (savedGui) {
            params.load = JSON.parse(savedGui);
          }
        }
      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);

      if (params.closeOnTop) {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
      } else {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
        this.domElement.appendChild(this.__closeButton);
      }

      dom.bind(this.__closeButton, 'click', function () {
        _this.closed = !_this.closed;
      });
    } else {
      if (params.closed === undefined) {
        params.closed = true;
      }

      var titleRowName = document.createTextNode(params.name);
      dom.addClass(titleRowName, 'controller-name');
      titleRow = addRow(_this, titleRowName);

      var onClickTitle = function onClickTitle(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);
      dom.addClass(titleRow, 'title');
      dom.bind(titleRow, 'click', onClickTitle);

      if (!params.closed) {
        this.closed = false;
      }
    }

    if (params.autoPlace) {
      if (Common.isUndefined(params.parent)) {
        if (autoPlaceVirgin) {
          autoPlaceContainer = document.createElement('div');
          dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
          dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(autoPlaceContainer);
          autoPlaceVirgin = false;
        }

        autoPlaceContainer.appendChild(this.domElement);
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
      }

      if (!this.parent) {
        setWidth(_this, params.width);
      }
    }

    this.__resizeHandler = function () {
      _this.onResizeDebounced();
    };

    dom.bind(window, 'resize', this.__resizeHandler);
    dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
    dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
    dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
    this.onResize();

    if (params.resizable) {
      addResizeHandle(this);
    }

    saveToLocalStorage = function saveToLocalStorage() {
      if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
        localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
      }
    };

    this.saveToLocalStorageIfPossible = saveToLocalStorage;

    function resetWidth() {
      var root = _this.getRoot();

      root.width += 1;
      Common.defer(function () {
        root.width -= 1;
      });
    }

    if (!params.parent) {
      resetWidth();
    }
  };

  GUI.toggleHide = function () {
    hide = !hide;
    Common.each(hideableGuis, function (gui) {
      gui.domElement.style.display = hide ? 'none' : '';
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_CLOSE_TOP = 'close-top';
  GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
  GUI.CLASS_DRAG = 'drag';
  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  GUI._keydownHandler = function (e) {
    if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }
  };

  dom.bind(window, 'keydown', GUI._keydownHandler, false);
  Common.extend(GUI.prototype, {
    add: function add(object, property) {
      return _add(this, object, property, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function addColor(object, property) {
      return _add(this, object, property, {
        color: true
      });
    },
    remove: function remove(controller) {
      this.__ul.removeChild(controller.__li);

      this.__controllers.splice(this.__controllers.indexOf(controller), 1);

      var _this = this;

      Common.defer(function () {
        _this.onResize();
      });
    },
    destroy: function destroy() {
      if (this.parent) {
        throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
      }

      if (this.autoPlace) {
        autoPlaceContainer.removeChild(this.domElement);
      }

      var _this = this;

      Common.each(this.__folders, function (subfolder) {
        _this.removeFolder(subfolder);
      });
      dom.unbind(window, 'keydown', GUI._keydownHandler, false);
      removeListeners(this);
    },
    addFolder: function addFolder(name) {
      if (this.__folders[name] !== undefined) {
        throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
      }

      var newGuiParams = {
        name: name,
        parent: this
      };
      newGuiParams.autoPlace = this.autoPlace;

      if (this.load && this.load.folders && this.load.folders[name]) {
        newGuiParams.closed = this.load.folders[name].closed;
        newGuiParams.load = this.load.folders[name];
      }

      var gui = new GUI(newGuiParams);
      this.__folders[name] = gui;
      var li = addRow(this, gui.domElement);
      dom.addClass(li, 'folder');
      return gui;
    },
    removeFolder: function removeFolder(folder) {
      this.__ul.removeChild(folder.domElement.parentElement);

      delete this.__folders[folder.name];

      if (this.load && this.load.folders && this.load.folders[folder.name]) {
        delete this.load.folders[folder.name];
      }

      removeListeners(folder);

      var _this = this;

      Common.each(folder.__folders, function (subfolder) {
        folder.removeFolder(subfolder);
      });
      Common.defer(function () {
        _this.onResize();
      });
    },
    open: function open() {
      this.closed = false;
    },
    close: function close() {
      this.closed = true;
    },
    hide: function hide() {
      this.domElement.style.display = 'none';
    },
    show: function show() {
      this.domElement.style.display = '';
    },
    onResize: function onResize() {
      var root = this.getRoot();

      if (root.scrollable) {
        var top = dom.getOffset(root.__ul).top;
        var h = 0;
        Common.each(root.__ul.childNodes, function (node) {
          if (!(root.autoPlace && node === root.__save_row)) {
            h += dom.getHeight(node);
          }
        });

        if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
          dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
        } else {
          dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = 'auto';
        }
      }

      if (root.__resize_handle) {
        Common.defer(function () {
          root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
        });
      }

      if (root.__closeButton) {
        root.__closeButton.style.width = root.width + 'px';
      }
    },
    onResizeDebounced: Common.debounce(function () {
      this.onResize();
    }, 50),
    remember: function remember() {
      if (Common.isUndefined(SAVE_DIALOGUE)) {
        SAVE_DIALOGUE = new CenteredDiv();
        SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
      }

      if (this.parent) {
        throw new Error('You can only call remember on a top level GUI.');
      }

      var _this = this;

      Common.each(Array.prototype.slice.call(arguments), function (object) {
        if (_this.__rememberedObjects.length === 0) {
          addSaveMenu(_this);
        }

        if (_this.__rememberedObjects.indexOf(object) === -1) {
          _this.__rememberedObjects.push(object);
        }
      });

      if (this.autoPlace) {
        setWidth(this, this.width);
      }
    },
    getRoot: function getRoot() {
      var gui = this;

      while (gui.parent) {
        gui = gui.parent;
      }

      return gui;
    },
    getSaveObject: function getSaveObject() {
      var toReturn = this.load;
      toReturn.closed = this.closed;

      if (this.__rememberedObjects.length > 0) {
        toReturn.preset = this.preset;

        if (!toReturn.remembered) {
          toReturn.remembered = {};
        }

        toReturn.remembered[this.preset] = getCurrentPreset(this);
      }

      toReturn.folders = {};
      Common.each(this.__folders, function (element, key) {
        toReturn.folders[key] = element.getSaveObject();
      });
      return toReturn;
    },
    save: function save() {
      if (!this.load.remembered) {
        this.load.remembered = {};
      }

      this.load.remembered[this.preset] = getCurrentPreset(this);
      markPresetModified(this, false);
      this.saveToLocalStorageIfPossible();
    },
    saveAs: function saveAs(presetName) {
      if (!this.load.remembered) {
        this.load.remembered = {};
        this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
      }

      this.load.remembered[presetName] = getCurrentPreset(this);
      this.preset = presetName;
      addPresetOption(this, presetName, true);
      this.saveToLocalStorageIfPossible();
    },
    revert: function revert(gui) {
      Common.each(this.__controllers, function (controller) {
        if (!this.getRoot().load.remembered) {
          controller.setValue(controller.initialValue);
        } else {
          recallSavedValue(gui || this.getRoot(), controller);
        }

        if (controller.__onFinishChange) {
          controller.__onFinishChange.call(controller, controller.getValue());
        }
      }, this);
      Common.each(this.__folders, function (folder) {
        folder.revert(folder);
      });

      if (!gui) {
        markPresetModified(this.getRoot(), false);
      }
    },
    listen: function listen(controller) {
      var init = this.__listening.length === 0;

      this.__listening.push(controller);

      if (init) {
        updateDisplays(this.__listening);
      }
    },
    updateDisplay: function updateDisplay() {
      Common.each(this.__controllers, function (controller) {
        controller.updateDisplay();
      });
      Common.each(this.__folders, function (folder) {
        folder.updateDisplay();
      });
    }
  });

  function addRow(gui, newDom, liBefore) {
    var li = document.createElement('li');

    if (newDom) {
      li.appendChild(newDom);
    }

    if (liBefore) {
      gui.__ul.insertBefore(li, liBefore);
    } else {
      gui.__ul.appendChild(li);
    }

    gui.onResize();
    return li;
  }

  function removeListeners(gui) {
    dom.unbind(window, 'resize', gui.__resizeHandler);

    if (gui.saveToLocalStorageIfPossible) {
      dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];

    if (modified) {
      opt.innerHTML = opt.value + '*';
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function augmentController(gui, li, controller) {
    controller.__li = li;
    controller.__gui = gui;
    Common.extend(controller, {
      options: function options(_options) {
        if (arguments.length > 1) {
          var nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: nextSibling,
            factoryArgs: [Common.toArray(arguments)]
          });
        }

        if (Common.isArray(_options) || Common.isObject(_options)) {
          var _nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: _nextSibling,
            factoryArgs: [_options]
          });
        }
      },
      name: function name(_name) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
        return controller;
      },
      listen: function listen() {
        controller.__gui.listen(controller);

        return controller;
      },
      remove: function remove() {
        controller.__gui.remove(controller);

        return controller;
      }
    });

    if (controller instanceof NumberControllerSlider) {
      var box = new NumberControllerBox(controller.object, controller.property, {
        min: controller.__min,
        max: controller.__max,
        step: controller.__step
      });
      Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
        var pc = controller[method];
        var pb = box[method];

        controller[method] = box[method] = function () {
          var args = Array.prototype.slice.call(arguments);
          pb.apply(box, args);
          return pc.apply(controller, args);
        };
      });
      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
    } else if (controller instanceof NumberControllerBox) {
      var r = function r(returned) {
        if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
          var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
          var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
          controller.remove();

          var newController = _add(gui, controller.object, controller.property, {
            before: controller.__li.nextElementSibling,
            factoryArgs: [controller.__min, controller.__max, controller.__step]
          });

          newController.name(oldName);
          if (wasListening) newController.listen();
          return newController;
        }

        return returned;
      };

      controller.min = Common.compose(r, controller.min);
      controller.max = Common.compose(r, controller.max);
    } else if (controller instanceof BooleanController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__checkbox, 'click');
      });
      dom.bind(controller.__checkbox, 'click', function (e) {
        e.stopPropagation();
      });
    } else if (controller instanceof FunctionController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__button, 'click');
      });
      dom.bind(li, 'mouseover', function () {
        dom.addClass(controller.__button, 'hover');
      });
      dom.bind(li, 'mouseout', function () {
        dom.removeClass(controller.__button, 'hover');
      });
    } else if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
      controller.updateDisplay = Common.compose(function (val) {
        li.style.borderLeftColor = controller.__color.toString();
        return val;
      }, controller.updateDisplay);
      controller.updateDisplay();
    }

    controller.setValue = Common.compose(function (val) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }

      return val;
    }, controller.setValue);
  }

  function recallSavedValue(gui, controller) {
    var root = gui.getRoot();

    var matchedIndex = root.__rememberedObjects.indexOf(controller.object);

    if (matchedIndex !== -1) {
      var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];

      if (controllerMap === undefined) {
        controllerMap = {};
        root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
      }

      controllerMap[controller.property] = controller;

      if (root.load && root.load.remembered) {
        var presetMap = root.load.remembered;
        var preset = void 0;

        if (presetMap[gui.preset]) {
          preset = presetMap[gui.preset];
        } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
          preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
        } else {
          return;
        }

        if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
          var value = preset[matchedIndex][controller.property];
          controller.initialValue = value;
          controller.setValue(value);
        }
      }
    }
  }

  function _add(gui, object, property, params) {
    if (object[property] === undefined) {
      throw new Error('Object "' + object + '" has no property "' + property + '"');
    }

    var controller = void 0;

    if (params.color) {
      controller = new ColorController(object, property);
    } else {
      var factoryArgs = [object, property].concat(params.factoryArgs);
      controller = ControllerFactory.apply(gui, factoryArgs);
    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);
    dom.addClass(controller.domElement, 'c');
    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;
    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);
    var li = addRow(gui, container, params.before);
    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);

    if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
    } else {
      dom.addClass(li, _typeof(controller.getValue()));
    }

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;
  }

  function getLocalStorageHash(gui, key) {
    return document.location.href + '.' + key;
  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;

    gui.__preset_select.appendChild(opt);

    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function showHideExplain(gui, explain) {
    explain.style.display = gui.useLocalStorage ? 'block' : 'none';
  }

  function addSaveMenu(gui) {
    var div = gui.__save_row = document.createElement('li');
    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');
    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');
    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');
    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');
    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {
      Common.each(gui.load.remembered, function (value, key) {
        addPresetOption(gui, key, key === gui.preset);
      });
    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function () {
      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;
    });
    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {
      var explain = document.getElementById('dg-local-explain');
      var localStorageCheckBox = document.getElementById('dg-local-storage');
      var saveLocally = document.getElementById('dg-save-locally');
      saveLocally.style.display = 'block';

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      showHideExplain(gui, explain);
      dom.bind(localStorageCheckBox, 'change', function () {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain(gui, explain);
      });
    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');
    dom.bind(newConstructorTextArea, 'keydown', function (e) {
      if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
        SAVE_DIALOGUE.hide();
      }
    });
    dom.bind(gears, 'click', function () {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });
    dom.bind(button, 'click', function () {
      gui.save();
    });
    dom.bind(button2, 'click', function () {
      var presetName = prompt('Enter a new preset name.');

      if (presetName) {
        gui.saveAs(presetName);
      }
    });
    dom.bind(button3, 'click', function () {
      gui.revert();
    });
  }

  function addResizeHandle(gui) {
    var pmouseX = void 0;
    gui.__resize_handle = document.createElement('div');
    Common.extend(gui.__resize_handle.style, {
      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
    });

    function drag(e) {
      e.preventDefault();
      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;
      return false;
    }

    function dragStop() {
      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);
    }

    function dragStart(e) {
      e.preventDefault();
      pmouseX = e.clientX;
      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);
      return false;
    }

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);
    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';

    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }

    if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {
    var toReturn = {};
    Common.each(gui.__rememberedObjects, function (val, index) {
      var savedValues = {};
      var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
      Common.each(controllerMap, function (controller, property) {
        savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });
      toReturn[index] = savedValues;
    });
    return toReturn;
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value === gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function updateDisplays(controllerArray) {
    if (controllerArray.length !== 0) {
      requestAnimationFrame$1$1.call(window, function () {
        updateDisplays(controllerArray);
      });
    }

    Common.each(controllerArray, function (c) {
      c.updateDisplay();
    });
  }

  var color = {
    Color: Color,
    math: ColorMath,
    interpret: interpret
  };
  var controllers = {
    Controller: Controller,
    BooleanController: BooleanController,
    OptionController: OptionController,
    StringController: StringController,
    NumberController: NumberController,
    NumberControllerBox: NumberControllerBox,
    NumberControllerSlider: NumberControllerSlider,
    FunctionController: FunctionController,
    ColorController: ColorController
  };
  var dom$1 = {
    dom: dom
  };
  var gui$1 = {
    GUI: GUI
  };
  var GUI$1 = GUI;
  var index = {
    color: color,
    controllers: controllers,
    dom: dom$1,
    gui: gui$1,
    GUI: GUI$1
  };

  const gui = new index.GUI();

  class MoebiusGeometry extends InstancedBufferGeometry {
    constructor(config) {
      //create blueprints
      super();
      let src = new IcosahedronGeometry(0.5, config.sphereDetail);
      this.setAttribute(
        "position",
        new BufferAttribute(src.getAttribute("position").array, 3)
      );
      this.setAttribute(
        "uv",
        new BufferAttribute(src.getAttribute("uv").array, 2)
      );
      this.setAttribute(
        "normal",
        new BufferAttribute(src.getAttribute("normal").array, 3)
      );
      this.setIndex(src.getIndex());
      this.reset(config);
    }

    reset(config) {
      let sw = config.section.width;
      let sh = config.section.height;
      let perUint = Math.max(config.section.countPerSide - 1, 1);
      let swStep = sw / perUint;
      let shStep = sh / perUint;

      let pos = [];
      let col = [];
      let uid = 0;
      for (let i = 0; i < config.count - 1; i++) {
        let z = i / (config.count - 1);
        for (let x = 0; x <= sw; x += swStep) {
          for (let y = 0; y <= sh; y += shStep) {
            //keep onlty outer frame if hollow
            if (config.hollow && !(x == 0 || x == sw || y == 0 || y == sh))
              continue;

            //position en X Y  sur le carr
            pos.push(x - sw / 2, y - sh / 2);

            //position normalise le long du cercle ( 0 -> 1 )
            pos.push(z - 0.5);

            //taille des billes
            pos.push(config.size.default);

            //alatoire: non utilis
            // pos.push(lerp(Math.random(), config.size.min, config.size.max));

            //couleur: utilise la fonction dfinie dans config ou met du blanc
            if (config.color === true) {
              config.colorRule(i, uid, col);
            } else {
              col.push(1, 1, 1);
            }
            uid++;
          }
        }
      }

      this.setAttribute(
        "section",
        new InstancedBufferAttribute(new Float32Array(pos), 4)
      );
      this.setAttribute(
        "color",
        new InstancedBufferAttribute(new Float32Array(col), 3)
      );
      this.needsUpdate = true;
    }
  }

  let tl;
  class MoebiusMaterial extends MeshPhysicalMaterial {
    constructor(config) {
      super({
        envMap: null,
        roughness: config.roughness,
        metalness: config.metalness,
        envMapIntensity: config.envMapIntensity,
      });

      tl = new TextureLoader();
      tl.load("assets/env.png", (t) => {
        this.envMap = t;
        t.mapping = EquirectangularReflectionMapping;
        t.needsUpdate = true;
      });

      const uniforms = {
        time: { value: 0 },
        radius: { value: config.radius },
        turns: { value: config.turns },
        speed: { value: config.speed },
        axialSpeed: { value: config.axialSpeed },
      };
      this.uniforms = uniforms;
      this.onBeforeCompile = (m) => {
        Object.assign(m.uniforms, uniforms);
        let vs = m.vertexShader;
        vs = vs.replace(
          "<common>",
          `<common>
        attribute vec4 section;
        attribute vec3 color;
        uniform float radius;
        uniform float turns;
        uniform float time;
        uniform float speed;
        uniform float axialSpeed;
        #define TAU PI * 2.
        varying vec3 vColor;`
        );
        vs = vs.replace(
          "<begin_vertex>",
          `<begin_vertex>
        
        vec3 pos = position;
        
        //rescale
        pos *= section.w;

        //place sur le carr avec la rotation axiale
        float r = length( section.xy );
        float a = atan( section.y, section.x ) + section.z *( TAU * turns ) + time * axialSpeed;
        pos.x += cos( a ) * r;
        pos.z += sin( a ) * r;
        
        //aligne le long du cercle
        float t = time * speed + section.z * TAU + ( TAU * turns );
        float c = cos( t );
        float s = sin( t );
        mat2 ro = mat2( c, -s, s , c );
        pos.xy *= ro;

        //offset (place sur le rayon)
        vec3 o  = vec3( cos( t ) *radius, sin( t ) *radius , 0. );
        
        transformed = pos + o;;

        //normals
        vec3 tNormal = normal;
        tNormal.x += cos( a ) * r;
        tNormal.z += sin( a ) * r;
        tNormal.xy *= ro;
        vNormal = normalize(tNormal * normalMatrix);

        vColor = color;`
        );
        m.vertexShader = vs;

        let fs = m.fragmentShader;
        fs = fs.replace(
          "<common>",
          `<common>
        uniform float time;
        varying vec3 vColor;`
        );
        fs = fs.replace(
          "<color_fragment>",
          `<color_fragment> 
        diffuseColor.rgb = vColor;`
        );
        fs = fs.replace(
          "<normal_fragment_maps>",
          `<normal_fragment_maps>
        normal = vNormal;//normalize( normal * vNormal );`
        );

        m.fragmentShader = fs;
      };
    }
  }

  class Moebius extends Mesh {
    constructor(config) {
      super(new MoebiusGeometry(config), new MoebiusMaterial(config));
      this.castShadow = true;
      this.receiveShadow = true;
    }

    reset(config) {
      this.geometry = new MoebiusGeometry(config);
    }

    update() {
      this.material.uniforms.time.value = performance.now() * 0.001;
    }
  }

  class Background extends Mesh {
    constructor(parent) {
      let g = new SphereBufferGeometry(1, 64, 32);
      let m = new MeshBasicMaterial({ color: 0xff0000, side: BackSide });
      super(g, m);
      this.scale.multiplyScalar(5000);

      m.onBeforeCompile = (mat) => {
        let vs = mat.vertexShader;
        vs = vs.replace("<common>", `<common> varying float vHeight;`);
        vs = vs.replace("<begin_vertex>", `<begin_vertex> vHeight = position.y;`);
        mat.vertexShader = vs;

        let fs = mat.fragmentShader;
        fs = fs.replace(
          "<common>",
          `<common> varying float vHeight;
        float gain(float x, float k){
            float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);
            return (x<0.5)?a:1.0-a;
        }`
        );
        fs = fs.replace(
          "<dithering_fragment>",
          `<dithering_fragment>
        gl_FragColor.rgb = mix(vec3( 0.35), vec3( .55), gain( smoothstep( -.5, .5, vHeight + .25 ), 4. ) );`
        );
        mat.fragmentShader = fs;
      };
    }
  }

  class Lights {
    constructor(stage) {
      let d0 = new DirectionalLight(0xcccccc, 0.85, 500);
      d0.position.x = 0;
      d0.position.y = 25;
      d0.position.z = 0;
      d0.lookAt(new Vector3());
      stage.add(d0);

      let a = new AmbientLight(0xffffff, 0.75);
      stage.add(a);

      let l1 = new PointLight(0xffffff, 0.5, 500);
      l1.position.y = 50;
      l1.position.z = -100;
      stage.add(l1);
      this.l1 = l1;

      let l2 = new PointLight(0xffffff, 0.5, 500);
      l2.position.y = 50;
      l2.position.z = 100;
      stage.add(l2);
      this.l2 = l2;
    }
    update() {}
  }

  let background, lights;
  class Scene {
    constructor(stage, model) {
      this.model = model;
      stage.add(model);
      background = new Background();
      stage.add(background);
      lights = new Lights(stage);
    }

    update() {
      if (this.model) this.model.update();
      if (lights) lights.update();
    }
  }

  let stage, model, scene;
  class Animation {
    get domElement() {
      return stage.domElement;
    }

    constructor() {
      let w = window.innerWidth;
      let h = window.innerHeight;
      stage = new Stage(w, h);
      model = new Moebius(CONFIG);
      scene = new Scene(stage, model);
    }

    setRadius(value) {
      model.material.uniforms.radius.value = value;
    }
    setTurns(value) {
      model.material.uniforms.turns.value = value;
    }
    setSpeed(value) {
      model.material.uniforms.speed.value = value;
    }
    setAxialSpeed(value) {
      model.material.uniforms.axialSpeed.value = value;
    }
    setMetalness(value) {
      model.material.metalness = value;
    }
    setRoughness(value) {
      model.material.roughness = value;
    }
    setEnvMapIntensity(value) {
      model.material.envMapIntensity = value;
    }

    reset(config) {
      model.reset(config);
    }

    resize() {
      let w = window.innerWidth;
      let h = window.innerHeight;
      stage.resize(w, h);
    }

    start() {
      this.update();
    }
    stop() {
      cancelAnimationFrame(this.raf);
    }

    update() {
      this.raf = requestAnimationFrame(this.update.bind(this));
      if (scene) scene.update();
      stage.render();
    }
  }

  // source animation

  let explorer$1, animation;
  let firstTime = true;
  class AnimatedContent {
    constructor(SDexplorerInstance) {
      explorer$1 = SDexplorerInstance;
      animation = new Animation();
      document.body.appendChild(animation.domElement);
      animation.start();
      {
        document.querySelector(".dg.ac").style.zIndex = 1;
        const cfg = CONFIG;
        gui.add(cfg, "radius", 1, 30).onChange((v) => {
          animation.setRadius(v);
        });
        gui.add(cfg, "count", 3, 200, 1).onChange((v) => {
          animation.reset(cfg);
        });
        gui.add(cfg, "turns", 0, 10 * Math.PI, Math.PI / 180).onChange((v) => {
          animation.setTurns(v);
        });
        gui.add(cfg, "axialSpeed", -1, 1, 0.01).onChange((v) => {
          animation.setAxialSpeed(v);
        });

        gui.add(cfg.section, "countPerSide", 1, 10, 1).onChange((v) => {
          animation.reset(cfg);
        });

        gui
          .add(cfg.size, "default", 0.01, 10, 0.01)
          .name("size")
          .onChange((v) => {
            animation.reset(cfg);
          });
        gui.add(cfg, "color").onChange((v) => {
          animation.reset(cfg);
        });

        gui.add(cfg, "roughness", 0, 1, 0.01).onChange((v) => {
          animation.setRoughness(v);
        });
        gui.add(cfg, "metalness", 0, 1, 0.01).onChange((v) => {
          animation.setMetalness(v);
        });
        gui.add(cfg, "envMapIntensity", 0, 1, 0.01).onChange((v) => {
          animation.setEnvMapIntensity(v);
        });

        // non utiliss (utilisables :) )

        // gui.add(cfg, "hollow").onChange((v) => {
        //   animation.reset(cfg);
        // });
        // gui.add(cfg, "speed", -0.25, 0.25, 0.01).onChange((v) => {
        //   animation.setSpeed(v);
        // });
        // gui.add(cfg.size, "min", 0.01, 10, 0.01).onChange((v) => {
        //   animation.reset(cfg);
        // });
        // gui.add(cfg.size, "max", 0.01, 10, 0.01).onChange((v) => {
        //   animation.reset(cfg);
        // });
        // gui.add(cfg.section, "width", 1, 10, 0.01).onChange((v) => {
        //   animation.reset(cfg);
        // });
        // gui.add(cfg.section, "height", 1, 10, 0.01).onChange((v) => {
        //   animation.reset(cfg);
        // });
      }

      explorer$1.ui.on("inference", () => {
        this.stop();
        animation.domElement.classList.add("hidden");
      });
      explorer$1.ui.on("img2img", () => {
        this.stop();
        animation.domElement.classList.add("hidden");
      });
      explorer$1.ui.on("inpainting", () => {
        this.stop();
        animation.domElement.classList.add("hidden");
      });
      explorer$1.ui.on("clear", () => {
        animation.domElement.classList.remove("hidden");
        this.start();
      });

      this.start();
    }

    start() {
      firstTime = true;
      this.stop();
      animation.start();
      this.update();
    }
    update() {
      this.raf = requestAnimationFrame(this.update.bind(this));
      this.render();
    }
    stop() {
      cancelAnimationFrame(this.raf);
      if (firstTime === true) {
        const rect = {
          x: 0,
          y: 0,
          w: explorer$1.canvas.width,
          h: explorer$1.canvas.height,
        };
        explorer$1.history.pushState(animation.domElement, rect);
        firstTime = false;
      }
    }
    render() {
      let w = window.innerWidth;
      let h = window.innerHeight;
      explorer$1.context.drawImage(animation.domElement, 0, 0, w, h, 0, 0, w, h);
    }
  }

  // main app
  let explorer;
  class Index {
    constructor() {
      // simple editor
      explorer = new SDExplorer();

      //use three js animation as the source
      new AnimatedContent(explorer);
    }
  }

  return Index;

})();
